import{_ as d,c as o,a as i,o as t}from"./app-2O6audqE.js";const l={};function c(n,e){return t(),o("div",null,e[0]||(e[0]=[i(`<h3 id="缩进" tabindex="-1"><a class="header-anchor" href="#缩进"><span>缩进</span></a></h3><hr><ul><li>不直接使用 <code>tab</code> 缩进</li><li>使用任何编辑器写 <code>Python</code>，请把一个 <code>tab</code> 展开为 4 个空格</li><li>不要混用<code>tab</code>和空格，否则容易出现 <code>IndentationError</code></li></ul><hr><h3 id="空格" tabindex="-1"><a class="header-anchor" href="#空格"><span>空格</span></a></h3><ul><li>在 <code>list</code>, <code>dict</code>, <code>tuple</code>, <code>set</code>, 参数列表的 , 后面加一个空格</li><li>在 <code>dict</code> 的 : 后面加一个空格</li><li>在注释符号 # 后面加一个空格，但是 <code>#!/usr/bin/python</code> 的 <code>#</code> 后不能有空格</li><li>操作符两端加一个空格，如 <code>+, -, *, /, |, &amp;, =</code></li><li>接上一条，在参数列表里的 = 两端不需要空格</li><li>括号（<code>(), {}, []</code>）内的两端不需要空格</li></ul><hr><h3 id="空行" tabindex="-1"><a class="header-anchor" href="#空行"><span>空行</span></a></h3><ul><li><code>function</code> 和 <code>class</code> 顶上两个空行</li><li><code>class</code> 的 <code>method</code> 之间一个空行</li><li>函数内逻辑无关的段落之间空一行，不要过度使用空行</li><li>不要把多个语句写在一行，然后用 ; 隔开</li><li><code>if/for/while</code> 语句中，即使执行语句只有一句，也要另起一行</li></ul><hr><h3 id="换行" tabindex="-1"><a class="header-anchor" href="#换行"><span>换行</span></a></h3><ul><li>每一行代码控制在 80 字符以内</li><li>使用 \\ 或 () 控制换行</li></ul><h3 id="命名" tabindex="-1"><a class="header-anchor" href="#命名"><span>命名</span></a></h3><p>使用有意义的，英文单词或词组，不要使用汉语拼音 package/module 名中不要出现 - 各种类型的命名规范：</p><table><thead><tr><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr><td>Modules</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Packages</td><td>lower_with_under</td><td></td></tr><tr><td>Classes CapWords</td><td>_CapWords</td><td></td></tr><tr><td>Exceptions</td><td>CapWords</td><td></td></tr><tr><td>Functions</td><td>lower_with_under()</td><td>_lower_with_under()</td></tr><tr><td>Global/Class Constants</td><td>CAPS_WITH_UNDER</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>Global/Class Variables</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Instance Variables</td><td>lower_with_under</td><td>_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td>Method Names</td><td>lower_with_under()</td><td>_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td>Function/Method Parameters</td><td>lower_with_under</td><td></td></tr><tr><td>Local Variables</td><td>lower_with_under</td><td></td></tr></tbody></table><hr><h3 id="pycharm开发常用快捷键" tabindex="-1"><a class="header-anchor" href="#pycharm开发常用快捷键"><span>Pycharm开发常用快捷键</span></a></h3><ul><li><code>ctrl+alt+L</code>格式化代码，使用<code>ctrl+alt+O</code>格式化导入</li><li><code>shift+F6</code>重命名方法或者变量</li><li><code>ctrl+shift +/-</code>展开/折叠全部代码块</li><li><code>Alt+Enter</code>自动修正导入</li></ul><hr><h3 id="导包" tabindex="-1"><a class="header-anchor" href="#导包"><span>导包</span></a></h3><ul><li><code>import</code> 的次序，先 <code>import Python 内置模块</code>，再 <code>import 第三方模块</code>，最后 <code>import 自己开发的项目中的其它模块</code>；这几种模块用空行分隔开来。</li><li>每个<code>import</code>应该独占一行。</li><li>不要使用 <code>from module import *</code>，除非是 <code>import</code> 常量定义模块或其它你确保不会出现命名空间冲突的模块。</li></ul><hr><h3 id="异常" tabindex="-1"><a class="header-anchor" href="#异常"><span>异常</span></a></h3><ul><li>像这样触发异常: <code>raise MyException(&quot;Error message&quot;)</code> 或者 <code>raise MyException</code> . 不要使用两个参数的形式( <code>raise MyException, &quot;Error message&quot;</code> )或者过时的字符串异常( <code>raise &quot;Error message&quot;</code> )</li><li>模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的<code>Exception</code>类继承. 模块的异常基类应该叫做”<code>Error</code>”.</li><li>永远不要使用 <code>except</code>: 语句来捕获所有异常, 也不要捕获 <code>Exception</code> 或者 <code>StandardError</code> , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, <code>except:</code> 真的会捕获包括Python语法错误在内的任何错误. 使用 <code>except:</code> 很容易隐藏真正的bug.</li><li>尽量减少<code>try/except</code>块中的代码量. <code>try</code>块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, <code>try/except</code>块将隐藏真正的错误.</li><li>使用<code>finally</code>子句来执行那些无论<code>try</code>块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</li></ul><hr><h2 id="python编码" tabindex="-1"><a class="header-anchor" href="#python编码"><span>Python编码</span></a></h2><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较</span></a></h3><ul><li>空的 <code>list</code>, <code>str</code>, <code>tuple</code>, <code>set</code>, <code>dict</code> 和 <code>0</code>, <code>0.0</code>, <code>None</code> 都是 <code>False</code></li><li>使用 <code>if some_list</code> 而不是 <code>if len(some_list)</code> 判断某个 <code>list</code> 是否为空，其他类型同理</li><li>使用 <code>is</code> 和 <code>is not</code> 与单例（如 <code>None</code>）进行比较，而不是用 <code>==</code> 和 <code>!=</code> 使用 <code>if a is not None</code> 而不是 <code>if not a is None</code></li><li>用 <code>isinstance</code> 而不是 <code>type</code> 判断类型 不要用 <code>==</code> 和 <code>!=</code> 与 <code>True</code> 和 <code>False</code> 比较（除非有特殊情况，如在 <code>sqlalchemy</code> 中可能用到)</li></ul><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h3><ul><li>需要查询操作时用<code>dict</code></li><li>使用<code>in</code>操作时用 <code>set</code> 加速 “存在性” 检查，<code>list</code> 的查找是线性的，复杂度 <code>O(n)</code>，<code>set</code> 底层是 <code>hash table</code>, 复杂度 <code>O(1)</code>，但用 <code>set</code> 需要比 <code>list</code> 更多内存空间</li><li><code>set</code> 的 <code>union</code>， <code>intersection</code>，<code>difference</code> 操作要比 <code>list</code> 的迭代要快。因此如果涉及到求 <code>list</code> 交集，并集或者差的问题可以转换为 <code>set</code> 来操作。</li><li>python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，所以在字符串连接的使用尽量使用 <code>join()</code> 而不是 <code>+</code></li><li>当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 <code>str.isalpha()</code>，<code>str.isdigit()</code>，<code>str.startswith((&#39;x&#39;, &#39;yz&#39;))</code>，<code>str.endswith((&#39;x&#39;, &#39;yz&#39;))</code></li><li>对字符进行格式化比直接串联读取要快，因此要使用</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">out_put = &quot;she&#39;s name is {},and she is a {}&quot;.format(lili,girl)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而不是</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">out_put = &quot;she&#39;s name is&quot; + lili + &quot;,and she is a &quot; + girl</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>使用列表解析（<code>list comprehension</code>）和生成器表达式（<code>generator expression</code>）</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"># 列表解析要比在循环中重新构建一个新的 list 更为高效，因此我们可以利用这一特性来提高运行的效率。</span>
<span class="line">for i in range (1000000): </span>
<span class="line">     for w in list: </span>
<span class="line">         total.append(w) </span>
<span class="line"># 使用列表解析</span>
<span class="line">for i in range (1000000): </span>
<span class="line">    a = [w for w in list]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成器表达式则是直接返回一个生成器，在迭代的时候调用，效率很高</p><ul><li>交换变量值时使用<code>a,b = b,a</code>而不是借助中间变量 <code>t=a</code>;<code>a=b</code>;<code>b=t</code>;</li><li>python 定位程序性能瓶颈<br><strong>python 内置了丰富的性能分析工具，如 <code>profile</code>,<code>cProfile</code> 与 <code>hotshot</code> 等。其中 <code>Profiler</code> 是 <code>python</code> 自带的一组程序，能够描述程序运行时候的性能，并提供各种统计帮助用户定位程序的性能瓶颈。Python 标准模块提供三种 <code>profilers</code>:<code>cProfile</code>,<code>profile</code> 以及 <code>hotshot</code>。</strong></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"># 使用 profile 进行性能分析</span>
<span class="line">import profile </span>
<span class="line">def profileTest(): </span>
<span class="line">   Total =1; </span>
<span class="line">   for i in range(10): </span>
<span class="line">       Total=Total*(i+1) </span>
<span class="line">       print Total </span>
<span class="line">   return Total </span>
<span class="line">if __name__ == &quot;__main__&quot;: </span>
<span class="line">   profile.run(&quot;profileTest()&quot;)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要将输出以日志的形式保存，只需要在调用的时候加入另外一个参数。如 <code>profile.run(&quot;profileTest()&quot;,&quot;testprof&quot;)</code>。</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><ul><li>使用 <code>for item in list</code> 迭代 <code>list</code>, <code>for index, item in enumerate(list)</code> 迭代 <code>list</code> 并获取下标</li><li>使用内建函数 <code>sorted</code> 和 <code>list.sort</code> 进行排序</li><li>使用装饰器(<code>decorator</code>)</li><li>使用 <code>with</code> 语句处理上下文</li><li>使用 <code>logging</code> 记录日志，配置好格式和级别</li><li>适量使用 <code>map</code>, <code>reduce</code>, <code>filter</code> 和 <code>lambda</code>，使用内建的 <code>all</code>, <code>any</code> 处理多个条件的判断</li></ul>`,41)]))}const a=d(l,[["render",c]]),r=JSON.parse('{"path":"/blogs/python/python_checklist.html","title":"python checklist","lang":"en-US","frontmatter":{"title":"python checklist","date":"2019-06-03T00:00:00.000Z","tags":["python","代码规范","开发规范","pep8","工程实践","入门级","开发工具"],"categories":["python"],"sidebar":"auto"},"headers":[{"level":3,"title":"缩进","slug":"缩进","link":"#缩进","children":[]},{"level":3,"title":"空格","slug":"空格","link":"#空格","children":[]},{"level":3,"title":"空行","slug":"空行","link":"#空行","children":[]},{"level":3,"title":"换行","slug":"换行","link":"#换行","children":[]},{"level":3,"title":"命名","slug":"命名","link":"#命名","children":[]},{"level":3,"title":"Pycharm开发常用快捷键","slug":"pycharm开发常用快捷键","link":"#pycharm开发常用快捷键","children":[]},{"level":3,"title":"导包","slug":"导包","link":"#导包","children":[]},{"level":3,"title":"异常","slug":"异常","link":"#异常","children":[]},{"level":2,"title":"Python编码","slug":"python编码","link":"#python编码","children":[{"level":3,"title":"比较","slug":"比较","link":"#比较","children":[]},{"level":3,"title":"性能","slug":"性能","link":"#性能","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]}],"git":{"createdTime":1754503646000,"updatedTime":1754503646000,"contributors":[{"name":"hushengnian","email":"hushengnian@example.com","commits":1}]},"filePathRelative":"blogs/python/python_checklist.md"}');export{a as comp,r as data};
