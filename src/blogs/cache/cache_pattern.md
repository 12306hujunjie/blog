---
title: 缓存模式设计与实践
date: 2022-03-01
tags:
 - 最佳实践
categories:
 - 缓存
 - 设计模式
 - 缓存
sidebar: auto
---
# 缓存主要有以下几种模式
1. `cache-aside`  
   应用请求先走缓存，缓存未命中则查数据库，然后由应用更新到缓存(常用的业务缓存模式，对缓存失效有一定的容忍性，缓存中数据模型与数据库中的数据模型可以不同)
2. 直读(`read-through`)  
   与`cache-aside`很接近，应用请求走缓存，但是应用与数据库不链接，由缓存自动从数据库同步数据
3. 直写(`write-through`)  
   与上两种读缓存不一样的是，应用会将数据直接写入缓存，由缓存自动同步数据到数据库
   (与`read-through`相结合可以很好的解决读写数据不一致的问题，由缓存写入数据库)
4. 绕写(`write-around`)  
   其实不会用到缓存，而是直接写入到数据库中(配合`cache-aside`/`read-through`使用, 只在缓存未命中的情况下写缓存)
5. 回写(`write-back`)  
   与`write-through`写入数据库时机不同，每隔一段时间或者当数据将要被移除缓存的时候将数据批量更新到数据库

---

# 主要搭配使用类型
## 1. `cache-aside`  
   ### 1. 第一种策略:
      1. 更新数据库  
      2. 更新缓存

   ::: warning
   这个策略有线程安全的问题，可能出现缓存和数据库不一致的问题(如果有两个写线程先后写完数据库，但旧数据后写缓存就会导致脏数据)。这里可以考虑做增量缓存更新的场景, 比如：  
    1. 点赞和取消点赞
    2. 点踩或者取消点踩  
    3. 评论计数增量更新 等
   :::

   ### 2. 第二种策略:   
      1. 更新数据库  
      2. 删除缓存
   
   ::: tip
   这个策略也可能会出现线程安全的问题(A读B写，A线程`cache miss`从数据库中获取数据,B写数据库，B删缓存，A由于网络延迟，将脏数据写入缓存)   
   但是这个策略由于需要满足比较苛刻的条件(即统一时间内写操作比读操作快且写操作在读写缓存操作的中间时间段)几乎不太可能发生,所以我们一般可以使用这种策略 ,另外再设置合适的过期时间，即使发生脏数据的情况，也不会发生很长时间(适合写频率适中且读操作偏多的情况)  
   :::

   PS:**应用于缓存不支持`read-through/write-through`的系统，适用于读写频次适中的系统**  

   ::: tip
   优点:  
      1. 缓存仅用于被请求的数据,属于惰性加载(`lazy-loading`)    
   
   缺点:  
   1. 发生`cache miss` 的情况时比较慢，因为要处理三个步骤：查询缓存，读数据库，写缓存  
   2. 缓存逻辑都放在应用程序中，增加了复杂度  
   ::: 

## 2. `read-through/write-through`直读直写  
在这种模式中，应用将缓存作为数据源，更新数据和读取数据由缓存代理，减少应用处理缓存的复杂度  适合读多，写频次适中的应用

   ::: tip
   优点:  
   1. 读写非常快  
   2. 缓存不存在脏数据  
   3. 相比较`cache-aside`模式，读取速度更高  
   4. 应用逻辑比较简单  
   缺点:  
   1. 对于写多读少的应用, `write-through`很浪费性能，多次写入却很少读取，白白增加了每次都写入缓存的延迟  
   2. 由缓存代理数据库，缓存模型必须与数据库模型保持一致  
   :::
## 3.  `read-through/write-back`直读回写
与直写的写入实际不同，回写将缓存作为可靠数据源，每次都只写入缓存，写入数据库则采用异步批量写入， 适用于读写频次都非常高的应用
   ::: tip
   优点:  
   1. 读写非常快  
   2. 减少了写库的频率，增加写入性能  
   缺点:   
   1. 有数据批量丢失的风险，如果缓存挂掉而没有即时写到数据库中，那么缓存中的数据将永久丢失 
   ::: 
## 4.  `read-through/write-around`直读绕写  
更新直接写入数据库，不写缓存，由缓存自动从数据库拉取数据，应用读取缓存，适用于写少读少的应用
   ::: tip
   优点:  
   1. 相比较`write-through`写入的时候的效率较高，如果数据写入后很少被读取，缓存也不会被没用到的数据占满。  
   
   缺点:  
   1. 如果数据会写入多次，那么可能存在缓存和数据库不一致  
   :::

## 具体实践场景(`redis`)
::: tip 
日常使用比较常用的就是`cache-aside`了，但是不同策略针对的缓存处理也不同，
如果在点赞的场景，更新评论数点赞数等都是高频写入，就不建议做删除缓存的策略
:::
## `cache-aside`
- 第一种场景，更新缓存时会出现线程安全问题，这时候可以考虑一下redis watch机制，操作新增一个user_id或者减少一个user_id,
  重点是要基于redis缓存内数据的修改，`python`代码如下
```python
with redis.pipeline() as p:
    while True:
        try:
            p.watch(cache_key)
            # do something like
            # 1. get value from redis 此时 value 对应的 cache_key 在 watch 时不会发生变化，可以放心读取
            # 2. update value to add id or delete id  # 内存操作增删数据
            #p.multi()
            #p.set | sadd | hset 写入数据
            p.execute()
            break
        except WatchError:
            continue
```
watch时如果这个缓存有修改，就会直接抛`watchError`，保证该更新(在`redis pipline`的`multi`操作和`execute`操作之间的更新操作)是原子独立的，
如果对应数据是数字的话，可以用`redis`自带的`increment`机制，先判断缓存是否存在，没有就从数据库获取最新数据并写入缓存  
当每个操作只涉及到对具体缓存的增量修改的时候, 就不在乎先后了，每个操作都是原子的独立的
通过更新缓存减少`cache miss` 的频率
- 第二种场景, 适用于写少读多的场景，在操作数据库修改数据之后直接删除缓存，方便快捷