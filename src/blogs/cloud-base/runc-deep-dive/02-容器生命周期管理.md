# 容器生命周期管理

> **系列导航：** [runc 容器运行时深度解析系列](./README.md) → 第二篇：容器生命周期管理  
> **上一篇：** [runc概述与架构](./01-runc概述与架构.md)  
> **最后更新：** 2024

## 概述

容器生命周期管理是 runc 的核心功能，包括容器的创建、启动、暂停、恢复、停止和删除等操作。本文深入分析 runc 如何管理容器状态转换、进程同步以及状态持久化机制。

## 容器状态模型

### 1.1 四种基本状态

runc 定义了四种容器状态，这些状态反映了容器在其生命周期中的不同阶段：

```go
// libcontainer/container.go:17
type Status int

const (
    // Created: 容器已创建但尚未运行
    Created Status = iota
    // Running: 容器正在运行
    Running
    // Paused: 容器存在，但所有进程都被暂停
    Paused
    // Stopped: 容器没有运行的进程
    Stopped
)
```

### 1.2 状态详细说明

| 状态 | 含义 | 特征 | 典型触发 |
|------|------|------|----------|
| **Created** | 容器已创建但初始化进程未启动 | - 配置已加载<br>- 资源已分配<br>- 进程未执行 | `runc create` |
| **Running** | 容器正常运行 | - 初始化进程正在执行<br>- 所有资源可用<br>- 可以接收信号 | `runc start`<br>`runc run` |
| **Paused** | 容器进程被冻结 | - 进程存在但被挂起<br>- 内存状态保持<br>- 不消耗 CPU | `runc pause` |
| **Stopped** | 容器已停止 | - 没有运行的进程<br>- 资源可能仍被占用<br>- 可以被删除 | 进程退出<br>`runc kill` |

### 1.3 状态转换图

```
    [容器不存在]
          │
          │ runc create
          ▼
    ┌──────────┐     runc start     ┌─────────┐
    │ Created  │ ──────────────────▶│ Running │
    └─────┬────┘                    └────┬────┘
          │                              │
          │ runc delete                  │ runc pause
          │ (force)                      ▼
          │                         ┌─────────┐
          │                         │ Paused  │
          │                         └────┬────┘
          │                              │
          │                              │ runc resume
          │                              │
          ▼                              ▼
    ┌──────────┐    runc delete     ┌─────────┐
    │ Stopped  │◀───────────────────│ Running │
    └─────┬────┘                    └─────────┘
          │                              ▲
          │ 进程退出 / runc kill           │
          └───────────────────────────────┘
```

## 2. 状态管理实现

### 2.1 状态机接口

runc 使用状态机模式来管理容器状态：

```go
// libcontainer/state_linux.go
type containerState interface {
    transition(containerState) error  // 状态转换
    destroy() error                   // 销毁容器
    status() Status                   // 获取当前状态
}
```

### 2.2 具体状态实现

```go
// 已停止状态
type stoppedState struct {
    c *Container
}

// 已创建状态  
type createdState struct {
    c *Container
}

// 运行状态
type runningState struct {
    c *Container
}

// 暂停状态
type pausedState struct {
    c *Container
}
```

### 2.3 状态转换验证

每个状态都定义了允许的转换：

```go
// createdState 的转换逻辑
func (i *createdState) transition(s containerState) error {
    switch s.(type) {
    case *runningState, *pausedState, *stoppedState:
        i.c.state = s  // 允许的转换
        return nil
    case *createdState:
        return nil     // 保持当前状态
    }
    return newStateTransitionError(i, s)  // 非法转换
}
```

## 3. 核心命令实现

### 3.1 命令类型定义

```go
// utils.go
type CtAct uint8

const (
    CT_ACT_CREATE CtAct = iota + 1  // 创建容器
    CT_ACT_RUN                      // 运行容器
    CT_ACT_RESTORE                  // 从检查点恢复
)
```

### 3.2 `runc create` - 创建容器

#### 执行流程

```go
// create.go:35
var createCommand = cli.Command{
    Name:  "create",
    Usage: "create a container",
    Action: func(context *cli.Context) error {
        if err := checkArgs(context, 1, exactArgs); err != nil {
            return err
        }
        spec, err := setupSpec(context)
        if err != nil {
            return err
        }
        return startContainer(context, CT_ACT_CREATE, spec)
    },
}
```

#### 关键步骤分析

1. **参数验证**: 确保提供了容器 ID
2. **配置加载**: 读取和解析 `config.json`
3. **容器创建**: 调用 `startContainer()` 执行创建逻辑

```go
// utils.go:161 - startContainer 函数核心逻辑
func startContainer(context *cli.Context, action CtAct, spec *specs.Spec) (int, error) {
    id := context.Args().First()
    
    // 1. 创建或加载容器
    container, err := createContainer(context, id, spec)
    if err != nil {
        return -1, err
    }
    
    // 2. 根据动作类型执行不同逻辑
    switch action {
    case CT_ACT_CREATE:
        // 只创建，不启动
        return 0, container.Start(process)
    case CT_ACT_RUN:
        // 创建并运行
        return container.Run(process)
    }
}
```

#### `create` 命令的详细执行过程

```
runc create mycontainer
        │
        ▼
┌─────────────────────────────────────┐
│ 1. CLI 解析和验证                   │
│    - 检查参数数量                   │
│    - 提取容器 ID                    │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 2. 配置加载 (setupSpec)             │
│    - 读取 config.json               │
│    - 验证 OCI 规范兼容性            │
│    - 处理默认值                     │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 3. 容器创建 (createContainer)       │
│    - OCI → libcontainer 配置转换    │
│    - 创建 Container 对象            │
│    - 设置状态目录                   │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 4. 进程准备 (container.Start)       │
│    - 创建 namespace                 │
│    - 设置 cgroups                   │
│    - 初始化文件系统                  │
│    - 启动初始化进程                  │
│    - 状态: nil → Created            │
└─────────────────────────────────────┘
```

### 3.3 `runc start` - 启动容器

#### 执行流程

```go
// start.go:15
var startCommand = cli.Command{
    Name:  "start",
    Usage: "executes the user defined process in a created container",
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            return err
        }
        
        status, err := container.Status()
        if err != nil {
            return err
        }
        
        switch status {
        case libcontainer.Created:
            // 只有 Created 状态的容器可以被启动
            return container.Exec()
        case libcontainer.Stopped:
            return errors.New("cannot start a container that has stopped")
        case libcontainer.Running:
            return errors.New("cannot start an already running container")
        default:
            return fmt.Errorf("cannot start a container in the %s state", status)
        }
    },
}
```

#### 关键特点

1. **状态检查**: 只能启动 `Created` 状态的容器
2. **状态加载**: 从磁盘加载容器状态
3. **进程启动**: 使用 `container.Exec()` 启动初始化进程

#### Exec Fifo 同步机制

`runc start` 使用 **exec fifo** 机制来精确控制进程启动时机：

```go
// libcontainer/container_linux.go:298
func (c *Container) Exec() error {
    path := filepath.Join(c.stateDir, execFifoFilename)
    blockingFifoOpenCh := awaitFifoOpen(path)
    
    for {
        select {
        case result := <-blockingFifoOpenCh:
            return handleFifoResult(result)
        case <-time.After(time.Millisecond * 100):
            // 定期检查进程是否仍然存活
            stat, err := system.Stat(pid)
            if err != nil || stat.State == system.Zombie {
                return errors.New("container process is already dead")
            }
        }
    }
}
```

**Exec Fifo 工作原理**：
1. `runc create` 创建容器时，创建一个名为 `exec.fifo` 的文件
2. 初始化进程等待有人打开这个 fifo 文件
3. `runc start` 打开 fifo 文件，触发初始化进程开始执行
4. 状态转换：`Created` → `Running`

### 3.4 `runc run` - 一步运行

#### 执行流程

```go
// run.go:28
var runCommand = cli.Command{
    Name:  "run",
    Usage: "create and run a container",
    Action: func(context *cli.Context) error {
        spec, err := setupSpec(context)
        if err != nil {
            return err
        }
        
        status, err := startContainer(context, CT_ACT_RUN, spec)
        if err == nil {
            // 等待容器进程结束并返回退出状态
            os.Exit(status)
        }
        return fmt.Errorf("runc run failed: %w", err)
    },
}
```

#### 与 `create` + `start` 的区别

| 特性 | `runc run` | `runc create` + `runc start` |
|------|------------|-------------------------------|
| 步骤数 | 一步完成 | 两步操作 |
| 状态转换 | 直接 `nil` → `Running` | `nil` → `Created` → `Running` |
| 使用场景 | 简单快速启动 | 需要在启动前进行配置 |
| 控制粒度 | 较粗 | 较细 |

```go
// utils.go 中 CT_ACT_RUN 的处理
case CT_ACT_RUN:
    // 直接运行，跳过 Created 状态
    if err := container.Run(process); err != nil {
        container.Destroy()
        return -1, err
    }
    // 等待进程结束
    status, err := process.Wait()
    return status, err
```

### 3.5 `runc state` - 查询状态

#### 执行流程

```go
// state.go:15
var stateCommand = cli.Command{
    Name:  "state",
    Usage: "output the state of a container",
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            return err
        }
        
        // 获取容器状态
        containerStatus, err := container.Status()
        if err != nil {
            return err
        }
        
        state, err := container.State()
        if err != nil {
            return err
        }
        
        // 构建输出格式
        cs := containerState{
            Version:        state.BaseState.Config.Version,
            ID:             state.BaseState.ID,
            Status:         containerStatus.String(),
            Bundle:         bundle,
            Created:        state.BaseState.Created,
            InitProcessPid: pid,
            // ... 更多字段
        }
        
        // JSON 格式输出
        data, err := json.MarshalIndent(cs, "", "  ")
        fmt.Fprintf(os.Stdout, "%s", data)
        return nil
    },
}
```

#### 输出示例

```json
{
  "ociVersion": "1.0.2",
  "id": "mycontainer",
  "status": "running",
  "pid": 1234,
  "bundle": "/tmp/mycontainer",
  "rootfs": "/tmp/mycontainer/rootfs",
  "created": "2023-01-01T12:00:00.000000000Z",
  "annotations": {
    "mykey": "myvalue"
  }
}
```

### 3.6 `runc delete` - 删除容器

#### 执行流程

```go
// delete.go:20
var deleteCommand = cli.Command{
    Name:  "delete",
    Usage: "delete any resources held by the container often used with detached container",
    Flags: []cli.Flag{
        cli.BoolFlag{
            Name:  "force, f",
            Usage: "Forcibly deletes the container if it is still running (uses SIGKILL)",
        },
    },
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            // 容器不存在，考虑已删除成功
            if os.IsNotExist(err) {
                return nil
            }
            return err
        }
        
        force := context.Bool("force")
        if force {
            return killContainer(container)
        }
        
        s, err := container.Status()
        if err != nil {
            return err
        }
        
        switch s {
        case libcontainer.Stopped:
            return container.Destroy()  // 正常删除
        case libcontainer.Created:
            return killContainer(container)  // 强制删除
        default:
            return fmt.Errorf("cannot delete container %s that is not stopped: %s", id, s)
        }
    },
}
```

#### 删除逻辑

1. **状态检查**: 只能删除 `Stopped` 状态的容器
2. **强制删除**: `--force` 标志可以删除任何状态的容器
3. **资源清理**: 删除状态文件、清理 cgroups、清理 namespace

```go
// container.Destroy() 的清理步骤
func (c *Container) Destroy() error {
    c.m.Lock()
    defer c.m.Unlock()
    
    // 1. 清理 cgroups
    if err := c.cgroupManager.Destroy(); err != nil {
        return err
    }
    
    // 2. 删除状态目录
    if err := os.RemoveAll(c.stateDir); err != nil {
        return err
    }
    
    // 3. 更新状态
    c.state = &stoppedState{c: c}
    return nil
}
```

## 4. 状态持久化机制

### 4.1 状态存储结构

容器状态持久化在以下位置：

```
/run/runc/<container-id>/
├── state.json          # 容器状态数据
├── exec.fifo          # 启动同步机制
└── hooks/             # 钩子函数相关文件
```

### 4.2 状态数据结构

```go
// libcontainer/state.go
type State struct {
    BaseState
    
    // Linux 特定状态
    Rootless       bool                              `json:"rootless"`
    CgroupPaths    map[string]string                 `json:"cgroup_paths"`
    NamespacePaths map[configs.NamespaceType]string  `json:"namespace_paths"`
    ExternalDescriptors []string                      `json:"external_descriptors"`
    IntelRdtPath   string                            `json:"intel_rdt_path"`
}

type BaseState struct {
    ID                   string        `json:"id"`
    InitProcessPid       int           `json:"init_process_pid"`  
    InitProcessStartTime uint64        `json:"init_process_start"`
    Created              time.Time     `json:"created"`
    Config               configs.Config `json:"config"`
}
```

### 4.3 状态加载过程

```go
// libcontainer/factory_linux.go:190
func Load(root, id string) (*Container, error) {
    stateDir, err := securejoin.SecureJoin(root, id)
    if err != nil {
        return nil, err
    }
    
    // 1. 从 state.json 加载状态
    state, err := loadState(stateDir)
    if err != nil {
        return nil, err
    }
    
    // 2. 重建容器对象
    container := &Container{
        initProcess:          nonChildProcess{...},
        initProcessStartTime: state.InitProcessStartTime,
        id:                   id,
        config:               &state.Config,
        stateDir:             stateDir,
        created:              state.Created,
    }
    
    // 3. 刷新运行时状态
    container.state = &loadedState{c: container}
    if err := container.refreshState(); err != nil {
        return nil, err
    }
    
    return container, nil
}
```

### 4.4 状态同步机制

`refreshState()` 方法负责将磁盘状态与实际运行时状态同步：

```go
// libcontainer/container_linux.go:156
func (c *Container) refreshState() error {
    // 1. 检查是否被暂停
    paused, err := c.isPaused()
    if err != nil {
        return err
    }
    if paused {
        return c.state.transition(&pausedState{c: c})
    }
    
    // 2. 检查初始化进程是否存在
    if !c.hasInit() {
        return c.state.transition(&stoppedState{c: c})
    }
    
    // 3. 检查是否处于 Created 状态
    // 通过检查 exec.fifo 文件是否存在来判断
    fifoPath := filepath.Join(c.stateDir, execFifoFilename)
    if _, err := os.Stat(fifoPath); err == nil {
        return c.state.transition(&createdState{c: c})
    }
    
    // 4. 默认为 Running 状态
    return c.state.transition(&runningState{c: c})
}
```

## 5. 进程管理与同步

### 5.1 初始化进程模型

runc 使用分层的进程模型来管理容器：

```
┌─────────────────┐
│   runc 主进程   │  ← 用户调用的 runc 命令
└─────────┬───────┘
          │ fork()
          ▼
┌─────────────────┐
│  bootstrap 进程 │  ← 负责 namespace 设置和初始化
└─────────┬───────┘
          │ exec()
          ▼
┌─────────────────┐
│  container 进程 │  ← 最终的用户进程
└─────────────────┘
```

### 5.2 进程接口定义

```go
// libcontainer/process.go:52
type parentProcess interface {
    pid() int                           // 获取进程 PID
    start() error                       // 启动进程
    signal(os.Signal) error             // 发送信号
    terminate() error                   // 终止进程
    wait() (*os.ProcessState, error)    // 等待进程结束
    startTime() (uint64, error)         // 获取启动时间
    externalDescriptors() []string      // 外部文件描述符
}
```

### 5.3 进程创建流程

```go
// libcontainer/container_linux.go:485
func (c *Container) Start(process *Process) error {
    c.m.Lock()
    defer c.m.Unlock()
    
    // 1. 状态检查
    if c.config.Cgroups != nil && c.config.Cgroups.Resources != nil {
        // 验证 cgroups 配置
    }
    
    // 2. 创建父进程
    parent, err := c.newParentProcess(process)
    if err != nil {
        return err
    }
    
    // 3. 启动进程
    if err := parent.start(); err != nil {
        return err
    }
    
    // 4. 保存进程信息
    c.initProcess = parent
    c.initProcessStartTime, _ = parent.startTime()
    
    // 5. 状态转换
    if err := c.state.transition(&createdState{c: c}); err != nil {
        return err
    }
    
    return nil
}
```

### 5.4 同步机制

#### Exec Fifo 详解

```go
// libcontainer/utils.go:45
func awaitFifoOpen(path string) <-chan openResult {
    fifoOpened := make(chan openResult)
    
    go func() {
        defer close(fifoOpened)
        
        // 创建 fifo 文件
        if err := unix.Mkfifo(path, 0622); err != nil && !os.IsExist(err) {
            fifoOpened <- openResult{err: err}
            return
        }
        
        // 等待另一端打开 fifo
        fd, err := unix.Open(path, unix.O_RDONLY, 0)
        if err != nil {
            fifoOpened <- openResult{err: err}
            return
        }
        
        fifoOpened <- openResult{file: os.NewFile(uintptr(fd), path)}
    }()
    
    return fifoOpened
}
```

**工作流程**：
1. **创建阶段** (`runc create`): 创建 `exec.fifo` 文件，初始化进程等待
2. **启动阶段** (`runc start`): 打开 `exec.fifo` 文件，释放等待的初始化进程
3. **清理阶段**: 删除 `exec.fifo` 文件，状态转换到 `Running`

## 6. 实践练习

### 6.1 状态转换实验

创建一个容器并观察状态变化：

```bash
# 1. 准备容器环境
mkdir /tmp/container-lifecycle
cd /tmp/container-lifecycle
mkdir rootfs

# 2. 准备根文件系统
docker export $(docker create busybox) | tar -C rootfs -xf -

# 3. 生成配置文件
runc spec

# 4. 观察状态转换
echo "=== 创建容器 ==="
runc create test-container
runc state test-container

echo "=== 启动容器 ==="
runc start test-container &
sleep 1
runc state test-container

echo "=== 暂停容器 ==="
runc pause test-container
runc state test-container

echo "=== 恢复容器 ==="
runc resume test-container
runc state test-container

echo "=== 删除容器 ==="
runc kill test-container
runc delete test-container
```

### 6.2 代码跟踪练习

在关键位置添加日志来跟踪状态转换：

```go
// 在 libcontainer/state_linux.go 中添加日志
func (i *createdState) transition(s containerState) error {
    fmt.Printf("DEBUG: Transitioning from 'created' to '%T'\n", s)
    
    switch s.(type) {
    case *runningState:
        fmt.Printf("DEBUG: Container starting execution\n")
        i.c.state = s
        return nil
    // ... 其他状态
    }
    return newStateTransitionError(i, s)
}
```

### 6.3 Exec Fifo 实验

观察 exec fifo 的创建和使用：

```bash
# 终端 1: 创建容器并监控 fifo
runc create test-container
ls -la /run/runc/test-container/
watch -n 0.1 "ls -la /run/runc/test-container/ | grep fifo"

# 终端 2: 启动容器
runc start test-container

# 观察 exec.fifo 文件的创建和删除
```

## 7. 深入思考

### 7.1 设计问题

1. **为什么需要 Created 状态？**
   - 允许在实际执行前进行额外配置
   - 支持复杂的启动编排
   - 符合 OCI 规范要求

2. **Exec Fifo 的作用是什么？**
   - 精确控制进程启动时机
   - 避免竞态条件
   - 支持同步和异步操作模式

3. **状态持久化的必要性？**
   - 跨进程状态共享
   - 故障恢复能力
   - 支持容器管理工具集成

### 7.2 性能考虑

1. **状态检查的开销**: 频繁的状态查询可能影响性能
2. **进程同步成本**: Fifo 机制增加了启动延迟
3. **持久化 I/O**: 状态文件的读写操作

### 7.3 错误处理

1. **状态不一致**: 如何处理磁盘状态与实际状态不符？
2. **进程清理**: 异常情况下如何确保资源清理？
3. **并发控制**: 多个 runc 进程同时操作同一容器？

## 8. 扩展阅读

- [OCI Runtime Specification - Container Lifecycle](https://github.com/opencontainers/runtime-spec/blob/main/runtime.md#lifecycle)
- [Linux Process State Management](https://man7.org/linux/man-pages/man5/proc.5.html)
- [Container State in Kubernetes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/)

## 🎯 模块总结

通过本模块的学习，你应该已经掌握了：

✅ 容器的四种基本状态和转换规则  
✅ runc 核心命令的实现原理和执行流程  
✅ 状态持久化和同步机制  
✅ 进程管理和 Exec Fifo 同步机制  
✅ 容器生命周期管理的设计模式  

**下一步**: 进入 [模块 3: Namespace 隔离实现](./03-Namespace隔离实现.md)，深入了解容器隔离的核心技术。