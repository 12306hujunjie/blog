# å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†

> **ç³»åˆ—å¯¼èˆªï¼š** [runc å®¹å™¨è¿è¡Œæ—¶æ·±åº¦è§£æç³»åˆ—](./README.md) â†’ ç¬¬äºŒç¯‡ï¼šå®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†  
> **ä¸Šä¸€ç¯‡ï¼š** [runcæ¦‚è¿°ä¸æ¶æ„](./01-runcæ¦‚è¿°ä¸æ¶æ„.md)  
> **æœ€åæ›´æ–°ï¼š** 2024

## æ¦‚è¿°

å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†æ˜¯ runc çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬å®¹å™¨çš„åˆ›å»ºã€å¯åŠ¨ã€æš‚åœã€æ¢å¤ã€åœæ­¢å’Œåˆ é™¤ç­‰æ“ä½œã€‚æœ¬æ–‡æ·±å…¥åˆ†æ runc å¦‚ä½•ç®¡ç†å®¹å™¨çŠ¶æ€è½¬æ¢ã€è¿›ç¨‹åŒæ­¥ä»¥åŠçŠ¶æ€æŒä¹…åŒ–æœºåˆ¶ã€‚

## å®¹å™¨çŠ¶æ€æ¨¡å‹

### 1.1 å››ç§åŸºæœ¬çŠ¶æ€

runc å®šä¹‰äº†å››ç§å®¹å™¨çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€åæ˜ äº†å®¹å™¨åœ¨å…¶ç”Ÿå‘½å‘¨æœŸä¸­çš„ä¸åŒé˜¶æ®µï¼š

```go
// libcontainer/container.go:17
type Status int

const (
    // Created: å®¹å™¨å·²åˆ›å»ºä½†å°šæœªè¿è¡Œ
    Created Status = iota
    // Running: å®¹å™¨æ­£åœ¨è¿è¡Œ
    Running
    // Paused: å®¹å™¨å­˜åœ¨ï¼Œä½†æ‰€æœ‰è¿›ç¨‹éƒ½è¢«æš‚åœ
    Paused
    // Stopped: å®¹å™¨æ²¡æœ‰è¿è¡Œçš„è¿›ç¨‹
    Stopped
)
```

### 1.2 çŠ¶æ€è¯¦ç»†è¯´æ˜

| çŠ¶æ€ | å«ä¹‰ | ç‰¹å¾ | å…¸å‹è§¦å‘ |
|------|------|------|----------|
| **Created** | å®¹å™¨å·²åˆ›å»ºä½†åˆå§‹åŒ–è¿›ç¨‹æœªå¯åŠ¨ | - é…ç½®å·²åŠ è½½<br>- èµ„æºå·²åˆ†é…<br>- è¿›ç¨‹æœªæ‰§è¡Œ | `runc create` |
| **Running** | å®¹å™¨æ­£å¸¸è¿è¡Œ | - åˆå§‹åŒ–è¿›ç¨‹æ­£åœ¨æ‰§è¡Œ<br>- æ‰€æœ‰èµ„æºå¯ç”¨<br>- å¯ä»¥æ¥æ”¶ä¿¡å· | `runc start`<br>`runc run` |
| **Paused** | å®¹å™¨è¿›ç¨‹è¢«å†»ç»“ | - è¿›ç¨‹å­˜åœ¨ä½†è¢«æŒ‚èµ·<br>- å†…å­˜çŠ¶æ€ä¿æŒ<br>- ä¸æ¶ˆè€— CPU | `runc pause` |
| **Stopped** | å®¹å™¨å·²åœæ­¢ | - æ²¡æœ‰è¿è¡Œçš„è¿›ç¨‹<br>- èµ„æºå¯èƒ½ä»è¢«å ç”¨<br>- å¯ä»¥è¢«åˆ é™¤ | è¿›ç¨‹é€€å‡º<br>`runc kill` |

### 1.3 çŠ¶æ€è½¬æ¢å›¾

```
    [å®¹å™¨ä¸å­˜åœ¨]
          â”‚
          â”‚ runc create
          â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     runc start     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Created  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Running â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
          â”‚                              â”‚
          â”‚ runc delete                  â”‚ runc pause
          â”‚ (force)                      â–¼
          â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                         â”‚ Paused  â”‚
          â”‚                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
          â”‚                              â”‚
          â”‚                              â”‚ runc resume
          â”‚                              â”‚
          â–¼                              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    runc delete     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Stopped  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Running â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                              â–²
          â”‚ è¿›ç¨‹é€€å‡º / runc kill           â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. çŠ¶æ€ç®¡ç†å®ç°

### 2.1 çŠ¶æ€æœºæ¥å£

runc ä½¿ç”¨çŠ¶æ€æœºæ¨¡å¼æ¥ç®¡ç†å®¹å™¨çŠ¶æ€ï¼š

```go
// libcontainer/state_linux.go
type containerState interface {
    transition(containerState) error  // çŠ¶æ€è½¬æ¢
    destroy() error                   // é”€æ¯å®¹å™¨
    status() Status                   // è·å–å½“å‰çŠ¶æ€
}
```

### 2.2 å…·ä½“çŠ¶æ€å®ç°

```go
// å·²åœæ­¢çŠ¶æ€
type stoppedState struct {
    c *Container
}

// å·²åˆ›å»ºçŠ¶æ€  
type createdState struct {
    c *Container
}

// è¿è¡ŒçŠ¶æ€
type runningState struct {
    c *Container
}

// æš‚åœçŠ¶æ€
type pausedState struct {
    c *Container
}
```

### 2.3 çŠ¶æ€è½¬æ¢éªŒè¯

æ¯ä¸ªçŠ¶æ€éƒ½å®šä¹‰äº†å…è®¸çš„è½¬æ¢ï¼š

```go
// createdState çš„è½¬æ¢é€»è¾‘
func (i *createdState) transition(s containerState) error {
    switch s.(type) {
    case *runningState, *pausedState, *stoppedState:
        i.c.state = s  // å…è®¸çš„è½¬æ¢
        return nil
    case *createdState:
        return nil     // ä¿æŒå½“å‰çŠ¶æ€
    }
    return newStateTransitionError(i, s)  // éæ³•è½¬æ¢
}
```

## 3. æ ¸å¿ƒå‘½ä»¤å®ç°

### 3.1 å‘½ä»¤ç±»å‹å®šä¹‰

```go
// utils.go
type CtAct uint8

const (
    CT_ACT_CREATE CtAct = iota + 1  // åˆ›å»ºå®¹å™¨
    CT_ACT_RUN                      // è¿è¡Œå®¹å™¨
    CT_ACT_RESTORE                  // ä»æ£€æŸ¥ç‚¹æ¢å¤
)
```

### 3.2 `runc create` - åˆ›å»ºå®¹å™¨

#### æ‰§è¡Œæµç¨‹

```go
// create.go:35
var createCommand = cli.Command{
    Name:  "create",
    Usage: "create a container",
    Action: func(context *cli.Context) error {
        if err := checkArgs(context, 1, exactArgs); err != nil {
            return err
        }
        spec, err := setupSpec(context)
        if err != nil {
            return err
        }
        return startContainer(context, CT_ACT_CREATE, spec)
    },
}
```

#### å…³é”®æ­¥éª¤åˆ†æ

1. **å‚æ•°éªŒè¯**: ç¡®ä¿æä¾›äº†å®¹å™¨ ID
2. **é…ç½®åŠ è½½**: è¯»å–å’Œè§£æ `config.json`
3. **å®¹å™¨åˆ›å»º**: è°ƒç”¨ `startContainer()` æ‰§è¡Œåˆ›å»ºé€»è¾‘

```go
// utils.go:161 - startContainer å‡½æ•°æ ¸å¿ƒé€»è¾‘
func startContainer(context *cli.Context, action CtAct, spec *specs.Spec) (int, error) {
    id := context.Args().First()
    
    // 1. åˆ›å»ºæˆ–åŠ è½½å®¹å™¨
    container, err := createContainer(context, id, spec)
    if err != nil {
        return -1, err
    }
    
    // 2. æ ¹æ®åŠ¨ä½œç±»å‹æ‰§è¡Œä¸åŒé€»è¾‘
    switch action {
    case CT_ACT_CREATE:
        // åªåˆ›å»ºï¼Œä¸å¯åŠ¨
        return 0, container.Start(process)
    case CT_ACT_RUN:
        // åˆ›å»ºå¹¶è¿è¡Œ
        return container.Run(process)
    }
}
```

#### `create` å‘½ä»¤çš„è¯¦ç»†æ‰§è¡Œè¿‡ç¨‹

```
runc create mycontainer
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. CLI è§£æå’ŒéªŒè¯                   â”‚
â”‚    - æ£€æŸ¥å‚æ•°æ•°é‡                   â”‚
â”‚    - æå–å®¹å™¨ ID                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. é…ç½®åŠ è½½ (setupSpec)             â”‚
â”‚    - è¯»å– config.json               â”‚
â”‚    - éªŒè¯ OCI è§„èŒƒå…¼å®¹æ€§            â”‚
â”‚    - å¤„ç†é»˜è®¤å€¼                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. å®¹å™¨åˆ›å»º (createContainer)       â”‚
â”‚    - OCI â†’ libcontainer é…ç½®è½¬æ¢    â”‚
â”‚    - åˆ›å»º Container å¯¹è±¡            â”‚
â”‚    - è®¾ç½®çŠ¶æ€ç›®å½•                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. è¿›ç¨‹å‡†å¤‡ (container.Start)       â”‚
â”‚    - åˆ›å»º namespace                 â”‚
â”‚    - è®¾ç½® cgroups                   â”‚
â”‚    - åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿ                  â”‚
â”‚    - å¯åŠ¨åˆå§‹åŒ–è¿›ç¨‹                  â”‚
â”‚    - çŠ¶æ€: nil â†’ Created            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 `runc start` - å¯åŠ¨å®¹å™¨

#### æ‰§è¡Œæµç¨‹

```go
// start.go:15
var startCommand = cli.Command{
    Name:  "start",
    Usage: "executes the user defined process in a created container",
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            return err
        }
        
        status, err := container.Status()
        if err != nil {
            return err
        }
        
        switch status {
        case libcontainer.Created:
            // åªæœ‰ Created çŠ¶æ€çš„å®¹å™¨å¯ä»¥è¢«å¯åŠ¨
            return container.Exec()
        case libcontainer.Stopped:
            return errors.New("cannot start a container that has stopped")
        case libcontainer.Running:
            return errors.New("cannot start an already running container")
        default:
            return fmt.Errorf("cannot start a container in the %s state", status)
        }
    },
}
```

#### å…³é”®ç‰¹ç‚¹

1. **çŠ¶æ€æ£€æŸ¥**: åªèƒ½å¯åŠ¨ `Created` çŠ¶æ€çš„å®¹å™¨
2. **çŠ¶æ€åŠ è½½**: ä»ç£ç›˜åŠ è½½å®¹å™¨çŠ¶æ€
3. **è¿›ç¨‹å¯åŠ¨**: ä½¿ç”¨ `container.Exec()` å¯åŠ¨åˆå§‹åŒ–è¿›ç¨‹

#### Exec Fifo åŒæ­¥æœºåˆ¶

`runc start` ä½¿ç”¨ **exec fifo** æœºåˆ¶æ¥ç²¾ç¡®æ§åˆ¶è¿›ç¨‹å¯åŠ¨æ—¶æœºï¼š

```go
// libcontainer/container_linux.go:298
func (c *Container) Exec() error {
    path := filepath.Join(c.stateDir, execFifoFilename)
    blockingFifoOpenCh := awaitFifoOpen(path)
    
    for {
        select {
        case result := <-blockingFifoOpenCh:
            return handleFifoResult(result)
        case <-time.After(time.Millisecond * 100):
            // å®šæœŸæ£€æŸ¥è¿›ç¨‹æ˜¯å¦ä»ç„¶å­˜æ´»
            stat, err := system.Stat(pid)
            if err != nil || stat.State == system.Zombie {
                return errors.New("container process is already dead")
            }
        }
    }
}
```

**Exec Fifo å·¥ä½œåŸç†**ï¼š
1. `runc create` åˆ›å»ºå®¹å™¨æ—¶ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `exec.fifo` çš„æ–‡ä»¶
2. åˆå§‹åŒ–è¿›ç¨‹ç­‰å¾…æœ‰äººæ‰“å¼€è¿™ä¸ª fifo æ–‡ä»¶
3. `runc start` æ‰“å¼€ fifo æ–‡ä»¶ï¼Œè§¦å‘åˆå§‹åŒ–è¿›ç¨‹å¼€å§‹æ‰§è¡Œ
4. çŠ¶æ€è½¬æ¢ï¼š`Created` â†’ `Running`

### 3.4 `runc run` - ä¸€æ­¥è¿è¡Œ

#### æ‰§è¡Œæµç¨‹

```go
// run.go:28
var runCommand = cli.Command{
    Name:  "run",
    Usage: "create and run a container",
    Action: func(context *cli.Context) error {
        spec, err := setupSpec(context)
        if err != nil {
            return err
        }
        
        status, err := startContainer(context, CT_ACT_RUN, spec)
        if err == nil {
            // ç­‰å¾…å®¹å™¨è¿›ç¨‹ç»“æŸå¹¶è¿”å›é€€å‡ºçŠ¶æ€
            os.Exit(status)
        }
        return fmt.Errorf("runc run failed: %w", err)
    },
}
```

#### ä¸ `create` + `start` çš„åŒºåˆ«

| ç‰¹æ€§ | `runc run` | `runc create` + `runc start` |
|------|------------|-------------------------------|
| æ­¥éª¤æ•° | ä¸€æ­¥å®Œæˆ | ä¸¤æ­¥æ“ä½œ |
| çŠ¶æ€è½¬æ¢ | ç›´æ¥ `nil` â†’ `Running` | `nil` â†’ `Created` â†’ `Running` |
| ä½¿ç”¨åœºæ™¯ | ç®€å•å¿«é€Ÿå¯åŠ¨ | éœ€è¦åœ¨å¯åŠ¨å‰è¿›è¡Œé…ç½® |
| æ§åˆ¶ç²’åº¦ | è¾ƒç²— | è¾ƒç»† |

```go
// utils.go ä¸­ CT_ACT_RUN çš„å¤„ç†
case CT_ACT_RUN:
    // ç›´æ¥è¿è¡Œï¼Œè·³è¿‡ Created çŠ¶æ€
    if err := container.Run(process); err != nil {
        container.Destroy()
        return -1, err
    }
    // ç­‰å¾…è¿›ç¨‹ç»“æŸ
    status, err := process.Wait()
    return status, err
```

### 3.5 `runc state` - æŸ¥è¯¢çŠ¶æ€

#### æ‰§è¡Œæµç¨‹

```go
// state.go:15
var stateCommand = cli.Command{
    Name:  "state",
    Usage: "output the state of a container",
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            return err
        }
        
        // è·å–å®¹å™¨çŠ¶æ€
        containerStatus, err := container.Status()
        if err != nil {
            return err
        }
        
        state, err := container.State()
        if err != nil {
            return err
        }
        
        // æ„å»ºè¾“å‡ºæ ¼å¼
        cs := containerState{
            Version:        state.BaseState.Config.Version,
            ID:             state.BaseState.ID,
            Status:         containerStatus.String(),
            Bundle:         bundle,
            Created:        state.BaseState.Created,
            InitProcessPid: pid,
            // ... æ›´å¤šå­—æ®µ
        }
        
        // JSON æ ¼å¼è¾“å‡º
        data, err := json.MarshalIndent(cs, "", "  ")
        fmt.Fprintf(os.Stdout, "%s", data)
        return nil
    },
}
```

#### è¾“å‡ºç¤ºä¾‹

```json
{
  "ociVersion": "1.0.2",
  "id": "mycontainer",
  "status": "running",
  "pid": 1234,
  "bundle": "/tmp/mycontainer",
  "rootfs": "/tmp/mycontainer/rootfs",
  "created": "2023-01-01T12:00:00.000000000Z",
  "annotations": {
    "mykey": "myvalue"
  }
}
```

### 3.6 `runc delete` - åˆ é™¤å®¹å™¨

#### æ‰§è¡Œæµç¨‹

```go
// delete.go:20
var deleteCommand = cli.Command{
    Name:  "delete",
    Usage: "delete any resources held by the container often used with detached container",
    Flags: []cli.Flag{
        cli.BoolFlag{
            Name:  "force, f",
            Usage: "Forcibly deletes the container if it is still running (uses SIGKILL)",
        },
    },
    Action: func(context *cli.Context) error {
        container, err := getContainer(context)
        if err != nil {
            // å®¹å™¨ä¸å­˜åœ¨ï¼Œè€ƒè™‘å·²åˆ é™¤æˆåŠŸ
            if os.IsNotExist(err) {
                return nil
            }
            return err
        }
        
        force := context.Bool("force")
        if force {
            return killContainer(container)
        }
        
        s, err := container.Status()
        if err != nil {
            return err
        }
        
        switch s {
        case libcontainer.Stopped:
            return container.Destroy()  // æ­£å¸¸åˆ é™¤
        case libcontainer.Created:
            return killContainer(container)  // å¼ºåˆ¶åˆ é™¤
        default:
            return fmt.Errorf("cannot delete container %s that is not stopped: %s", id, s)
        }
    },
}
```

#### åˆ é™¤é€»è¾‘

1. **çŠ¶æ€æ£€æŸ¥**: åªèƒ½åˆ é™¤ `Stopped` çŠ¶æ€çš„å®¹å™¨
2. **å¼ºåˆ¶åˆ é™¤**: `--force` æ ‡å¿—å¯ä»¥åˆ é™¤ä»»ä½•çŠ¶æ€çš„å®¹å™¨
3. **èµ„æºæ¸…ç†**: åˆ é™¤çŠ¶æ€æ–‡ä»¶ã€æ¸…ç† cgroupsã€æ¸…ç† namespace

```go
// container.Destroy() çš„æ¸…ç†æ­¥éª¤
func (c *Container) Destroy() error {
    c.m.Lock()
    defer c.m.Unlock()
    
    // 1. æ¸…ç† cgroups
    if err := c.cgroupManager.Destroy(); err != nil {
        return err
    }
    
    // 2. åˆ é™¤çŠ¶æ€ç›®å½•
    if err := os.RemoveAll(c.stateDir); err != nil {
        return err
    }
    
    // 3. æ›´æ–°çŠ¶æ€
    c.state = &stoppedState{c: c}
    return nil
}
```

## 4. çŠ¶æ€æŒä¹…åŒ–æœºåˆ¶

### 4.1 çŠ¶æ€å­˜å‚¨ç»“æ„

å®¹å™¨çŠ¶æ€æŒä¹…åŒ–åœ¨ä»¥ä¸‹ä½ç½®ï¼š

```
/run/runc/<container-id>/
â”œâ”€â”€ state.json          # å®¹å™¨çŠ¶æ€æ•°æ®
â”œâ”€â”€ exec.fifo          # å¯åŠ¨åŒæ­¥æœºåˆ¶
â””â”€â”€ hooks/             # é’©å­å‡½æ•°ç›¸å…³æ–‡ä»¶
```

### 4.2 çŠ¶æ€æ•°æ®ç»“æ„

```go
// libcontainer/state.go
type State struct {
    BaseState
    
    // Linux ç‰¹å®šçŠ¶æ€
    Rootless       bool                              `json:"rootless"`
    CgroupPaths    map[string]string                 `json:"cgroup_paths"`
    NamespacePaths map[configs.NamespaceType]string  `json:"namespace_paths"`
    ExternalDescriptors []string                      `json:"external_descriptors"`
    IntelRdtPath   string                            `json:"intel_rdt_path"`
}

type BaseState struct {
    ID                   string        `json:"id"`
    InitProcessPid       int           `json:"init_process_pid"`  
    InitProcessStartTime uint64        `json:"init_process_start"`
    Created              time.Time     `json:"created"`
    Config               configs.Config `json:"config"`
}
```

### 4.3 çŠ¶æ€åŠ è½½è¿‡ç¨‹

```go
// libcontainer/factory_linux.go:190
func Load(root, id string) (*Container, error) {
    stateDir, err := securejoin.SecureJoin(root, id)
    if err != nil {
        return nil, err
    }
    
    // 1. ä» state.json åŠ è½½çŠ¶æ€
    state, err := loadState(stateDir)
    if err != nil {
        return nil, err
    }
    
    // 2. é‡å»ºå®¹å™¨å¯¹è±¡
    container := &Container{
        initProcess:          nonChildProcess{...},
        initProcessStartTime: state.InitProcessStartTime,
        id:                   id,
        config:               &state.Config,
        stateDir:             stateDir,
        created:              state.Created,
    }
    
    // 3. åˆ·æ–°è¿è¡Œæ—¶çŠ¶æ€
    container.state = &loadedState{c: container}
    if err := container.refreshState(); err != nil {
        return nil, err
    }
    
    return container, nil
}
```

### 4.4 çŠ¶æ€åŒæ­¥æœºåˆ¶

`refreshState()` æ–¹æ³•è´Ÿè´£å°†ç£ç›˜çŠ¶æ€ä¸å®é™…è¿è¡Œæ—¶çŠ¶æ€åŒæ­¥ï¼š

```go
// libcontainer/container_linux.go:156
func (c *Container) refreshState() error {
    // 1. æ£€æŸ¥æ˜¯å¦è¢«æš‚åœ
    paused, err := c.isPaused()
    if err != nil {
        return err
    }
    if paused {
        return c.state.transition(&pausedState{c: c})
    }
    
    // 2. æ£€æŸ¥åˆå§‹åŒ–è¿›ç¨‹æ˜¯å¦å­˜åœ¨
    if !c.hasInit() {
        return c.state.transition(&stoppedState{c: c})
    }
    
    // 3. æ£€æŸ¥æ˜¯å¦å¤„äº Created çŠ¶æ€
    // é€šè¿‡æ£€æŸ¥ exec.fifo æ–‡ä»¶æ˜¯å¦å­˜åœ¨æ¥åˆ¤æ–­
    fifoPath := filepath.Join(c.stateDir, execFifoFilename)
    if _, err := os.Stat(fifoPath); err == nil {
        return c.state.transition(&createdState{c: c})
    }
    
    // 4. é»˜è®¤ä¸º Running çŠ¶æ€
    return c.state.transition(&runningState{c: c})
}
```

## 5. è¿›ç¨‹ç®¡ç†ä¸åŒæ­¥

### 5.1 åˆå§‹åŒ–è¿›ç¨‹æ¨¡å‹

runc ä½¿ç”¨åˆ†å±‚çš„è¿›ç¨‹æ¨¡å‹æ¥ç®¡ç†å®¹å™¨ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   runc ä¸»è¿›ç¨‹   â”‚  â† ç”¨æˆ·è°ƒç”¨çš„ runc å‘½ä»¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ fork()
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  bootstrap è¿›ç¨‹ â”‚  â† è´Ÿè´£ namespace è®¾ç½®å’Œåˆå§‹åŒ–
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ exec()
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  container è¿›ç¨‹ â”‚  â† æœ€ç»ˆçš„ç”¨æˆ·è¿›ç¨‹
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 è¿›ç¨‹æ¥å£å®šä¹‰

```go
// libcontainer/process.go:52
type parentProcess interface {
    pid() int                           // è·å–è¿›ç¨‹ PID
    start() error                       // å¯åŠ¨è¿›ç¨‹
    signal(os.Signal) error             // å‘é€ä¿¡å·
    terminate() error                   // ç»ˆæ­¢è¿›ç¨‹
    wait() (*os.ProcessState, error)    // ç­‰å¾…è¿›ç¨‹ç»“æŸ
    startTime() (uint64, error)         // è·å–å¯åŠ¨æ—¶é—´
    externalDescriptors() []string      // å¤–éƒ¨æ–‡ä»¶æè¿°ç¬¦
}
```

### 5.3 è¿›ç¨‹åˆ›å»ºæµç¨‹

```go
// libcontainer/container_linux.go:485
func (c *Container) Start(process *Process) error {
    c.m.Lock()
    defer c.m.Unlock()
    
    // 1. çŠ¶æ€æ£€æŸ¥
    if c.config.Cgroups != nil && c.config.Cgroups.Resources != nil {
        // éªŒè¯ cgroups é…ç½®
    }
    
    // 2. åˆ›å»ºçˆ¶è¿›ç¨‹
    parent, err := c.newParentProcess(process)
    if err != nil {
        return err
    }
    
    // 3. å¯åŠ¨è¿›ç¨‹
    if err := parent.start(); err != nil {
        return err
    }
    
    // 4. ä¿å­˜è¿›ç¨‹ä¿¡æ¯
    c.initProcess = parent
    c.initProcessStartTime, _ = parent.startTime()
    
    // 5. çŠ¶æ€è½¬æ¢
    if err := c.state.transition(&createdState{c: c}); err != nil {
        return err
    }
    
    return nil
}
```

### 5.4 åŒæ­¥æœºåˆ¶

#### Exec Fifo è¯¦è§£

```go
// libcontainer/utils.go:45
func awaitFifoOpen(path string) <-chan openResult {
    fifoOpened := make(chan openResult)
    
    go func() {
        defer close(fifoOpened)
        
        // åˆ›å»º fifo æ–‡ä»¶
        if err := unix.Mkfifo(path, 0622); err != nil && !os.IsExist(err) {
            fifoOpened <- openResult{err: err}
            return
        }
        
        // ç­‰å¾…å¦ä¸€ç«¯æ‰“å¼€ fifo
        fd, err := unix.Open(path, unix.O_RDONLY, 0)
        if err != nil {
            fifoOpened <- openResult{err: err}
            return
        }
        
        fifoOpened <- openResult{file: os.NewFile(uintptr(fd), path)}
    }()
    
    return fifoOpened
}
```

**å·¥ä½œæµç¨‹**ï¼š
1. **åˆ›å»ºé˜¶æ®µ** (`runc create`): åˆ›å»º `exec.fifo` æ–‡ä»¶ï¼Œåˆå§‹åŒ–è¿›ç¨‹ç­‰å¾…
2. **å¯åŠ¨é˜¶æ®µ** (`runc start`): æ‰“å¼€ `exec.fifo` æ–‡ä»¶ï¼Œé‡Šæ”¾ç­‰å¾…çš„åˆå§‹åŒ–è¿›ç¨‹
3. **æ¸…ç†é˜¶æ®µ**: åˆ é™¤ `exec.fifo` æ–‡ä»¶ï¼ŒçŠ¶æ€è½¬æ¢åˆ° `Running`

## 6. å®è·µç»ƒä¹ 

### 6.1 çŠ¶æ€è½¬æ¢å®éªŒ

åˆ›å»ºä¸€ä¸ªå®¹å™¨å¹¶è§‚å¯ŸçŠ¶æ€å˜åŒ–ï¼š

```bash
# 1. å‡†å¤‡å®¹å™¨ç¯å¢ƒ
mkdir /tmp/container-lifecycle
cd /tmp/container-lifecycle
mkdir rootfs

# 2. å‡†å¤‡æ ¹æ–‡ä»¶ç³»ç»Ÿ
docker export $(docker create busybox) | tar -C rootfs -xf -

# 3. ç”Ÿæˆé…ç½®æ–‡ä»¶
runc spec

# 4. è§‚å¯ŸçŠ¶æ€è½¬æ¢
echo "=== åˆ›å»ºå®¹å™¨ ==="
runc create test-container
runc state test-container

echo "=== å¯åŠ¨å®¹å™¨ ==="
runc start test-container &
sleep 1
runc state test-container

echo "=== æš‚åœå®¹å™¨ ==="
runc pause test-container
runc state test-container

echo "=== æ¢å¤å®¹å™¨ ==="
runc resume test-container
runc state test-container

echo "=== åˆ é™¤å®¹å™¨ ==="
runc kill test-container
runc delete test-container
```

### 6.2 ä»£ç è·Ÿè¸ªç»ƒä¹ 

åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—æ¥è·Ÿè¸ªçŠ¶æ€è½¬æ¢ï¼š

```go
// åœ¨ libcontainer/state_linux.go ä¸­æ·»åŠ æ—¥å¿—
func (i *createdState) transition(s containerState) error {
    fmt.Printf("DEBUG: Transitioning from 'created' to '%T'\n", s)
    
    switch s.(type) {
    case *runningState:
        fmt.Printf("DEBUG: Container starting execution\n")
        i.c.state = s
        return nil
    // ... å…¶ä»–çŠ¶æ€
    }
    return newStateTransitionError(i, s)
}
```

### 6.3 Exec Fifo å®éªŒ

è§‚å¯Ÿ exec fifo çš„åˆ›å»ºå’Œä½¿ç”¨ï¼š

```bash
# ç»ˆç«¯ 1: åˆ›å»ºå®¹å™¨å¹¶ç›‘æ§ fifo
runc create test-container
ls -la /run/runc/test-container/
watch -n 0.1 "ls -la /run/runc/test-container/ | grep fifo"

# ç»ˆç«¯ 2: å¯åŠ¨å®¹å™¨
runc start test-container

# è§‚å¯Ÿ exec.fifo æ–‡ä»¶çš„åˆ›å»ºå’Œåˆ é™¤
```

## 7. æ·±å…¥æ€è€ƒ

### 7.1 è®¾è®¡é—®é¢˜

1. **ä¸ºä»€ä¹ˆéœ€è¦ Created çŠ¶æ€ï¼Ÿ**
   - å…è®¸åœ¨å®é™…æ‰§è¡Œå‰è¿›è¡Œé¢å¤–é…ç½®
   - æ”¯æŒå¤æ‚çš„å¯åŠ¨ç¼–æ’
   - ç¬¦åˆ OCI è§„èŒƒè¦æ±‚

2. **Exec Fifo çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ**
   - ç²¾ç¡®æ§åˆ¶è¿›ç¨‹å¯åŠ¨æ—¶æœº
   - é¿å…ç«æ€æ¡ä»¶
   - æ”¯æŒåŒæ­¥å’Œå¼‚æ­¥æ“ä½œæ¨¡å¼

3. **çŠ¶æ€æŒä¹…åŒ–çš„å¿…è¦æ€§ï¼Ÿ**
   - è·¨è¿›ç¨‹çŠ¶æ€å…±äº«
   - æ•…éšœæ¢å¤èƒ½åŠ›
   - æ”¯æŒå®¹å™¨ç®¡ç†å·¥å…·é›†æˆ

### 7.2 æ€§èƒ½è€ƒè™‘

1. **çŠ¶æ€æ£€æŸ¥çš„å¼€é”€**: é¢‘ç¹çš„çŠ¶æ€æŸ¥è¯¢å¯èƒ½å½±å“æ€§èƒ½
2. **è¿›ç¨‹åŒæ­¥æˆæœ¬**: Fifo æœºåˆ¶å¢åŠ äº†å¯åŠ¨å»¶è¿Ÿ
3. **æŒä¹…åŒ– I/O**: çŠ¶æ€æ–‡ä»¶çš„è¯»å†™æ“ä½œ

### 7.3 é”™è¯¯å¤„ç†

1. **çŠ¶æ€ä¸ä¸€è‡´**: å¦‚ä½•å¤„ç†ç£ç›˜çŠ¶æ€ä¸å®é™…çŠ¶æ€ä¸ç¬¦ï¼Ÿ
2. **è¿›ç¨‹æ¸…ç†**: å¼‚å¸¸æƒ…å†µä¸‹å¦‚ä½•ç¡®ä¿èµ„æºæ¸…ç†ï¼Ÿ
3. **å¹¶å‘æ§åˆ¶**: å¤šä¸ª runc è¿›ç¨‹åŒæ—¶æ“ä½œåŒä¸€å®¹å™¨ï¼Ÿ

## 8. æ‰©å±•é˜…è¯»

- [OCI Runtime Specification - Container Lifecycle](https://github.com/opencontainers/runtime-spec/blob/main/runtime.md#lifecycle)
- [Linux Process State Management](https://man7.org/linux/man-pages/man5/proc.5.html)
- [Container State in Kubernetes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/)

## ğŸ¯ æ¨¡å—æ€»ç»“

é€šè¿‡æœ¬æ¨¡å—çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

âœ… å®¹å™¨çš„å››ç§åŸºæœ¬çŠ¶æ€å’Œè½¬æ¢è§„åˆ™  
âœ… runc æ ¸å¿ƒå‘½ä»¤çš„å®ç°åŸç†å’Œæ‰§è¡Œæµç¨‹  
âœ… çŠ¶æ€æŒä¹…åŒ–å’ŒåŒæ­¥æœºåˆ¶  
âœ… è¿›ç¨‹ç®¡ç†å’Œ Exec Fifo åŒæ­¥æœºåˆ¶  
âœ… å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†çš„è®¾è®¡æ¨¡å¼  

**ä¸‹ä¸€æ­¥**: è¿›å…¥ [æ¨¡å— 3: Namespace éš”ç¦»å®ç°](./03-Namespaceéš”ç¦»å®ç°.md)ï¼Œæ·±å…¥äº†è§£å®¹å™¨éš”ç¦»çš„æ ¸å¿ƒæŠ€æœ¯ã€‚