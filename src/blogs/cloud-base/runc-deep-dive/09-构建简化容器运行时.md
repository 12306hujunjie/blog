---
title: 构建简化容器运行时
date: 2025-08-09
tags:
 - runc
 - 云原生
 - 实践
categories:
 - 云原生
sidebar: auto
---

# 构建简化容器运行时

> **系列导航：** [runc 容器运行时深度解析系列](./README.md) → 第九篇：构建简化容器运行时  
> **上一篇：** [通信与监控系统](./08-通信与监控系统.md)  
> **最后更新：** 2024

## 概述

本文将指导你从零开始构建一个简化的容器运行时 minirunc，通过实际编程加深对容器技术原理的理解。这个项目将包含容器的核心功能：进程隔离、资源限制和文件系统管理。

## 概述

通过前面8个模块的学习，我们已经深入理解了runc的核心实现原理。现在，让我们将这些知识付诸实践，从零开始构建一个简化但功能完整的容器运行时"minirunc"。这个实践项目将帮助你真正掌握容器技术的精髓。

## 1. 项目架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    MiniRunc 架构设计                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   CLI层                      核心层                          │
│  ┌──────────┐            ┌────────────┐                    │
│  │   main   │───────────>│  Runtime   │                    │
│  │          │            │  Manager   │                    │
│  └──────────┘            └────────────┘                    │
│       │                        │                            │
│  ┌──────────┐            ┌────────────┐                    │
│  │ Commands │            │ Container  │                    │
│  │  - run   │            │   Engine   │                    │
│  │  - exec  │            └────────────┘                    │
│  │  - ps    │                  │                            │
│  │  - kill  │            ┌────────────────────────┐        │
│  └──────────┘            │    Subsystems         │        │
│                          ├────────────────────────┤        │
│                          │ • Namespace Manager    │        │
│                          │ • Cgroups Controller   │        │
│                          │ • Filesystem Handler   │        │
│                          │ • Security Module      │        │
│                          │ • Network Manager      │        │
│                          │ • Process Monitor      │        │
│                          └────────────────────────┘        │
│                                                            │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 项目结构

```bash
minirunc/
├── cmd/                    # CLI命令实现
│   ├── run.go             # run命令
│   ├── exec.go            # exec命令
│   ├── ps.go              # ps命令
│   └── kill.go            # kill命令
├── container/             # 容器核心实现
│   ├── container.go       # 容器主逻辑
│   ├── init.go           # init进程
│   └── process.go        # 进程管理
├── namespace/            # 命名空间管理
│   ├── namespace.go      # 命名空间接口
│   ├── mount.go          # Mount命名空间
│   ├── pid.go           # PID命名空间
│   ├── network.go       # 网络命名空间
│   └── user.go          # 用户命名空间
├── cgroups/             # Cgroups资源管理
│   ├── manager.go       # Cgroups管理器
│   ├── cpu.go          # CPU限制
│   ├── memory.go       # 内存限制
│   └── blkio.go        # I/O限制
├── rootfs/              # 文件系统管理
│   ├── rootfs.go       # rootfs管理
│   └── mount.go        # 挂载处理
├── network/            # 网络管理
│   ├── bridge.go       # 网桥管理
│   └── veth.go         # veth设备
├── security/           # 安全模块
│   ├── capabilities.go # 能力管理
│   └── seccomp.go     # Seccomp过滤
└── main.go            # 程序入口
```

## 2. 核心数据结构

### 2.1 容器配置

```go
// container/types.go
package container

import (
    "time"
)

// Container 容器结构
type Container struct {
    ID         string            `json:"id"`
    Name       string            `json:"name"`
    State      ContainerState    `json:"state"`
    Config     *ContainerConfig  `json:"config"`
    Created    time.Time         `json:"created"`
    Pid        int               `json:"pid"`
    RootPath   string            `json:"root_path"`
    ConfigPath string            `json:"config_path"`
}

// ContainerState 容器状态
type ContainerState string

const (
    StateCreated  ContainerState = "created"
    StateRunning  ContainerState = "running"
    StateStopped  ContainerState = "stopped"
    StatePaused   ContainerState = "paused"
)

// ContainerConfig 容器配置
type ContainerConfig struct {
    // 基础配置
    Hostname     string            `json:"hostname"`
    Rootfs       string            `json:"rootfs"`
    Cmd          []string          `json:"cmd"`
    Env          []string          `json:"env"`
    WorkingDir   string            `json:"working_dir"`
    
    // 资源限制
    Resources    *Resources        `json:"resources"`
    
    // 命名空间
    Namespaces   []NamespaceConfig `json:"namespaces"`
    
    // 挂载配置
    Mounts       []Mount           `json:"mounts"`
    
    // 网络配置
    Network      *NetworkConfig    `json:"network"`
    
    // 安全配置
    Capabilities []string          `json:"capabilities"`
    SeccompProfile string          `json:"seccomp_profile"`
}

// Resources 资源限制配置
type Resources struct {
    Memory       *MemoryResource   `json:"memory,omitempty"`
    CPU          *CPUResource      `json:"cpu,omitempty"`
    BlockIO      *BlockIOResource  `json:"blkio,omitempty"`
}

type MemoryResource struct {
    Limit       int64  `json:"limit,omitempty"`        // 内存限制(bytes)
    Reservation int64  `json:"reservation,omitempty"`  // 内存预留
    Swap        int64  `json:"swap,omitempty"`         // Swap限制
}

type CPUResource struct {
    Shares  uint64  `json:"shares,omitempty"`  // CPU份额
    Quota   int64   `json:"quota,omitempty"`   // CPU配额
    Period  uint64  `json:"period,omitempty"`  // CPU周期
    Cpus    string  `json:"cpus,omitempty"`    // CPU核心
}

// NamespaceConfig 命名空间配置
type NamespaceConfig struct {
    Type string `json:"type"`
    Path string `json:"path,omitempty"`
}

// Mount 挂载配置
type Mount struct {
    Source      string   `json:"source"`
    Destination string   `json:"destination"`
    Type        string   `json:"type"`
    Options     []string `json:"options"`
}
```

## 3. 容器运行时实现

### 3.1 主程序入口

```go
// main.go
package main

import (
    "fmt"
    "os"
    
    "github.com/urfave/cli/v2"
    "minirunc/cmd"
)

func main() {
    app := &cli.App{
        Name:    "minirunc",
        Usage:   "A minimal container runtime",
        Version: "0.1.0",
        Commands: []*cli.Command{
            cmd.RunCommand,
            cmd.ExecCommand,
            cmd.PsCommand,
            cmd.KillCommand,
        },
    }
    
    if err := app.Run(os.Args); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

### 3.2 Run命令实现

```go
// cmd/run.go
package cmd

import (
    "encoding/json"
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "syscall"
    
    "github.com/urfave/cli/v2"
    "minirunc/container"
)

var RunCommand = &cli.Command{
    Name:  "run",
    Usage: "Create and run a container",
    Flags: []cli.Flag{
        &cli.StringFlag{
            Name:  "bundle",
            Value: ".",
            Usage: "path to the bundle directory",
        },
        &cli.BoolFlag{
            Name:  "detach",
            Usage: "run container in background",
        },
    },
    Action: runAction,
}

func runAction(ctx *cli.Context) error {
    if ctx.NArg() < 1 {
        return fmt.Errorf("container id is required")
    }
    
    containerID := ctx.Args().Get(0)
    bundle := ctx.String("bundle")
    
    // 1. 加载配置
    configPath := filepath.Join(bundle, "config.json")
    config, err := loadConfig(configPath)
    if err != nil {
        return fmt.Errorf("failed to load config: %v", err)
    }
    
    // 2. 创建容器
    c := &container.Container{
        ID:         containerID,
        Config:     config,
        RootPath:   bundle,
        ConfigPath: configPath,
        State:      container.StateCreated,
    }
    
    // 3. 判断是否是init进程
    if os.Args[0] == "/proc/self/exe" && os.Args[1] == "init" {
        // 这是容器内的init进程
        return container.RunInit()
    }
    
    // 4. 创建新进程运行容器
    return runContainer(c, ctx.Bool("detach"))
}

func runContainer(c *container.Container, detach bool) error {
    // 准备命令
    cmd := exec.Command("/proc/self/exe", "init")
    
    // 设置进程属性
    cmd.SysProcAttr = &syscall.SysProcAttr{
        Cloneflags: syscall.CLONE_NEWUTS |
                   syscall.CLONE_NEWPID |
                   syscall.CLONE_NEWNS |
                   syscall.CLONE_NEWNET |
                   syscall.CLONE_NEWIPC,
    }
    
    // 设置用户映射(如果需要)
    if needsUserNamespace(c.Config) {
        cmd.SysProcAttr.Cloneflags |= syscall.CLONE_NEWUSER
        cmd.SysProcAttr.UidMappings = []syscall.SysProcIDMap{
            {
                ContainerID: 0,
                HostID:      os.Getuid(),
                Size:        1,
            },
        }
        cmd.SysProcAttr.GidMappings = []syscall.SysProcIDMap{
            {
                ContainerID: 0,
                HostID:      os.Getgid(),
                Size:        1,
            },
        }
    }
    
    // 创建管道传递配置
    r, w, err := os.Pipe()
    if err != nil {
        return err
    }
    
    cmd.ExtraFiles = []*os.File{r}
    
    // 设置标准输入输出
    if !detach {
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
    }
    
    // 启动进程
    if err := cmd.Start(); err != nil {
        return fmt.Errorf("failed to start container: %v", err)
    }
    
    // 发送配置给init进程
    encoder := json.NewEncoder(w)
    if err := encoder.Encode(c.Config); err != nil {
        return err
    }
    w.Close()
    
    // 记录容器PID
    c.Pid = cmd.Process.Pid
    c.State = container.StateRunning
    
    // 设置cgroups
    if err := setupCgroups(c); err != nil {
        return fmt.Errorf("failed to setup cgroups: %v", err)
    }
    
    // 等待进程退出(如果不是后台运行)
    if !detach {
        if err := cmd.Wait(); err != nil {
            return fmt.Errorf("container exited with error: %v", err)
        }
    }
    
    return nil
}
```

### 3.3 Init进程实现

```go
// container/init.go
package container

import (
    "encoding/json"
    "fmt"
    "os"
    "path/filepath"
    "syscall"
)

// RunInit 容器init进程入口
func RunInit() error {
    // 从管道读取配置
    configFile := os.NewFile(3, "config")
    decoder := json.NewDecoder(configFile)
    
    var config ContainerConfig
    if err := decoder.Decode(&config); err != nil {
        return fmt.Errorf("failed to decode config: %v", err)
    }
    configFile.Close()
    
    // 设置主机名
    if err := syscall.Sethostname([]byte(config.Hostname)); err != nil {
        return fmt.Errorf("failed to set hostname: %v", err)
    }
    
    // 准备根文件系统
    if err := setupRootfs(&config); err != nil {
        return fmt.Errorf("failed to setup rootfs: %v", err)
    }
    
    // 设置环境变量
    for _, env := range config.Env {
        if err := os.Setenv(env[:strings.Index(env, "=")], 
            env[strings.Index(env, "=")+1:]); err != nil {
            return err
        }
    }
    
    // 切换工作目录
    if config.WorkingDir != "" {
        if err := os.Chdir(config.WorkingDir); err != nil {
            return err
        }
    }
    
    // 设置能力
    if err := setupCapabilities(config.Capabilities); err != nil {
        return fmt.Errorf("failed to setup capabilities: %v", err)
    }
    
    // 执行用户命令
    path, err := exec.LookPath(config.Cmd[0])
    if err != nil {
        return fmt.Errorf("command not found: %v", err)
    }
    
    return syscall.Exec(path, config.Cmd, os.Environ())
}

// setupRootfs 设置根文件系统
func setupRootfs(config *ContainerConfig) error {
    // 挂载/proc
    if err := mountProc(config.Rootfs); err != nil {
        return err
    }
    
    // 挂载/dev
    if err := mountDev(config.Rootfs); err != nil {
        return err
    }
    
    // 挂载/sys
    if err := mountSys(config.Rootfs); err != nil {
        return err
    }
    
    // 处理用户定义的挂载
    for _, mount := range config.Mounts {
        if err := doMount(mount, config.Rootfs); err != nil {
            return fmt.Errorf("failed to mount %s: %v", mount.Destination, err)
        }
    }
    
    // 切换根文件系统
    if err := pivotRoot(config.Rootfs); err != nil {
        return fmt.Errorf("failed to pivot root: %v", err)
    }
    
    return nil
}

// pivotRoot 切换根文件系统
func pivotRoot(newroot string) error {
    // 为put_old创建临时目录
    putold := filepath.Join(newroot, ".pivot_root")
    if err := os.MkdirAll(putold, 0700); err != nil {
        return err
    }
    
    // 调用pivot_root
    if err := syscall.PivotRoot(newroot, putold); err != nil {
        return err
    }
    
    // 切换当前工作目录到新根
    if err := os.Chdir("/"); err != nil {
        return err
    }
    
    // 卸载put_old
    putold = "/.pivot_root"
    if err := syscall.Unmount(putold, syscall.MNT_DETACH); err != nil {
        return err
    }
    
    // 删除临时目录
    return os.RemoveAll(putold)
}
```

## 4. 命名空间管理

### 4.1 命名空间管理器

```go
// namespace/namespace.go
package namespace

import (
    "fmt"
    "os"
    "path/filepath"
    "syscall"
)

// NamespaceType 命名空间类型
type NamespaceType string

const (
    NEWNET  NamespaceType = "net"
    NEWUTS  NamespaceType = "uts"
    NEWIPC  NamespaceType = "ipc"
    NEWPID  NamespaceType = "pid"
    NEWNS   NamespaceType = "mnt"
    NEWUSER NamespaceType = "user"
    NEWCGROUP NamespaceType = "cgroup"
)

// NamespaceManager 命名空间管理器
type NamespaceManager struct {
    pid int
}

// NewNamespaceManager 创建命名空间管理器
func NewNamespaceManager(pid int) *NamespaceManager {
    return &NamespaceManager{pid: pid}
}

// Enter 进入指定命名空间
func (nm *NamespaceManager) Enter(nsType NamespaceType) error {
    nsPath := filepath.Join("/proc", fmt.Sprintf("%d", nm.pid), "ns", string(nsType))
    
    // 打开命名空间文件
    fd, err := syscall.Open(nsPath, syscall.O_RDONLY, 0)
    if err != nil {
        return fmt.Errorf("failed to open namespace %s: %v", nsType, err)
    }
    defer syscall.Close(fd)
    
    // 进入命名空间
    if err := syscall.Setns(fd, 0); err != nil {
        return fmt.Errorf("failed to enter namespace %s: %v", nsType, err)
    }
    
    return nil
}

// Create 创建新的命名空间
func (nm *NamespaceManager) Create(nsTypes []NamespaceType) error {
    var cloneFlags uintptr
    
    for _, nsType := range nsTypes {
        switch nsType {
        case NEWNET:
            cloneFlags |= syscall.CLONE_NEWNET
        case NEWUTS:
            cloneFlags |= syscall.CLONE_NEWUTS
        case NEWIPC:
            cloneFlags |= syscall.CLONE_NEWIPC
        case NEWPID:
            cloneFlags |= syscall.CLONE_NEWPID
        case NEWNS:
            cloneFlags |= syscall.CLONE_NEWNS
        case NEWUSER:
            cloneFlags |= syscall.CLONE_NEWUSER
        case NEWCGROUP:
            cloneFlags |= 0x02000000 // CLONE_NEWCGROUP
        }
    }
    
    // 使用unshare创建新命名空间
    if err := syscall.Unshare(int(cloneFlags)); err != nil {
        return fmt.Errorf("failed to unshare namespaces: %v", err)
    }
    
    return nil
}
```

### 4.2 网络命名空间

```go
// namespace/network.go
package namespace

import (
    "fmt"
    "net"
    "github.com/vishvananda/netlink"
)

// NetworkNamespace 网络命名空间管理
type NetworkNamespace struct {
    name string
}

// CreateVethPair 创建veth设备对
func (nn *NetworkNamespace) CreateVethPair(hostName, containerName string) error {
    // 创建veth对
    veth := &netlink.Veth{
        LinkAttrs: netlink.LinkAttrs{
            Name: hostName,
        },
        PeerName: containerName,
    }
    
    if err := netlink.LinkAdd(veth); err != nil {
        return fmt.Errorf("failed to create veth pair: %v", err)
    }
    
    // 启动主机端接口
    hostVeth, err := netlink.LinkByName(hostName)
    if err != nil {
        return err
    }
    
    if err := netlink.LinkSetUp(hostVeth); err != nil {
        return fmt.Errorf("failed to set up host veth: %v", err)
    }
    
    return nil
}

// MoveVethToNamespace 将veth设备移动到容器命名空间
func (nn *NetworkNamespace) MoveVethToNamespace(vethName string, pid int) error {
    veth, err := netlink.LinkByName(vethName)
    if err != nil {
        return err
    }
    
    // 移动到目标命名空间
    if err := netlink.LinkSetNsPid(veth, pid); err != nil {
        return fmt.Errorf("failed to move veth to namespace: %v", err)
    }
    
    return nil
}

// ConfigureContainerNetwork 配置容器网络
func (nn *NetworkNamespace) ConfigureContainerNetwork(vethName, ipAddr string) error {
    // 获取veth设备
    veth, err := netlink.LinkByName(vethName)
    if err != nil {
        return err
    }
    
    // 配置IP地址
    addr, err := netlink.ParseAddr(ipAddr)
    if err != nil {
        return err
    }
    
    if err := netlink.AddrAdd(veth, addr); err != nil {
        return fmt.Errorf("failed to add IP address: %v", err)
    }
    
    // 启动接口
    if err := netlink.LinkSetUp(veth); err != nil {
        return fmt.Errorf("failed to set up container veth: %v", err)
    }
    
    // 配置lo接口
    lo, err := netlink.LinkByName("lo")
    if err == nil {
        netlink.LinkSetUp(lo)
    }
    
    return nil
}
```

## 5. Cgroups资源管理

### 5.1 Cgroups管理器

```go
// cgroups/manager.go
package cgroups

import (
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
    "strconv"
    "strings"
)

// CgroupManager cgroups管理器
type CgroupManager struct {
    containerID string
    cgroupPath  string
    subsystems  []Subsystem
}

// Subsystem cgroup子系统接口
type Subsystem interface {
    Name() string
    Set(cgroupPath string, res *Resources) error
    Apply(cgroupPath string, pid int) error
    Remove(cgroupPath string) error
}

// NewCgroupManager 创建cgroup管理器
func NewCgroupManager(containerID string) *CgroupManager {
    return &CgroupManager{
        containerID: containerID,
        cgroupPath:  filepath.Join("/sys/fs/cgroup", "minirunc", containerID),
        subsystems: []Subsystem{
            &MemorySubsystem{},
            &CPUSubsystem{},
            &CpusetSubsystem{},
        },
    }
}

// Set 设置资源限制
func (m *CgroupManager) Set(res *Resources) error {
    for _, subsystem := range m.subsystems {
        subsysPath := filepath.Join(m.cgroupPath, subsystem.Name())
        
        // 创建cgroup目录
        if err := os.MkdirAll(subsysPath, 0755); err != nil {
            return err
        }
        
        // 设置资源限制
        if err := subsystem.Set(subsysPath, res); err != nil {
            return fmt.Errorf("failed to set %s: %v", subsystem.Name(), err)
        }
    }
    
    return nil
}

// Apply 将进程加入cgroup
func (m *CgroupManager) Apply(pid int) error {
    for _, subsystem := range m.subsystems {
        subsysPath := filepath.Join(m.cgroupPath, subsystem.Name())
        
        if err := subsystem.Apply(subsysPath, pid); err != nil {
            return fmt.Errorf("failed to apply %s: %v", subsystem.Name(), err)
        }
    }
    
    return nil
}

// Destroy 销毁cgroup
func (m *CgroupManager) Destroy() error {
    for _, subsystem := range m.subsystems {
        subsysPath := filepath.Join(m.cgroupPath, subsystem.Name())
        
        if err := subsystem.Remove(subsysPath); err != nil {
            return err
        }
    }
    
    return os.RemoveAll(m.cgroupPath)
}
```

### 5.2 内存子系统

```go
// cgroups/memory.go
package cgroups

import (
    "fmt"
    "io/ioutil"
    "path/filepath"
    "strconv"
)

// MemorySubsystem 内存子系统
type MemorySubsystem struct{}

func (s *MemorySubsystem) Name() string {
    return "memory"
}

func (s *MemorySubsystem) Set(cgroupPath string, res *Resources) error {
    if res.Memory == nil {
        return nil
    }
    
    // 设置内存限制
    if res.Memory.Limit > 0 {
        limitFile := filepath.Join(cgroupPath, "memory.limit_in_bytes")
        if err := ioutil.WriteFile(limitFile, []byte(strconv.FormatInt(res.Memory.Limit, 10)), 0644); err != nil {
            return fmt.Errorf("failed to set memory limit: %v", err)
        }
    }
    
    // 设置swap限制
    if res.Memory.Swap > 0 {
        swapFile := filepath.Join(cgroupPath, "memory.memsw.limit_in_bytes")
        if err := ioutil.WriteFile(swapFile, []byte(strconv.FormatInt(res.Memory.Swap, 10)), 0644); err != nil {
            return fmt.Errorf("failed to set swap limit: %v", err)
        }
    }
    
    // 设置OOM控制
    oomControlFile := filepath.Join(cgroupPath, "memory.oom_control")
    if err := ioutil.WriteFile(oomControlFile, []byte("0"), 0644); err != nil {
        return fmt.Errorf("failed to set oom control: %v", err)
    }
    
    return nil
}

func (s *MemorySubsystem) Apply(cgroupPath string, pid int) error {
    procsFile := filepath.Join(cgroupPath, "cgroup.procs")
    return ioutil.WriteFile(procsFile, []byte(strconv.Itoa(pid)), 0644)
}

func (s *MemorySubsystem) Remove(cgroupPath string) error {
    return os.RemoveAll(cgroupPath)
}

// GetMemoryStats 获取内存统计
func (s *MemorySubsystem) GetMemoryStats(cgroupPath string) (*MemoryStats, error) {
    stats := &MemoryStats{}
    
    // 读取当前使用量
    usageFile := filepath.Join(cgroupPath, "memory.usage_in_bytes")
    usage, err := ioutil.ReadFile(usageFile)
    if err != nil {
        return nil, err
    }
    stats.Usage, _ = strconv.ParseUint(strings.TrimSpace(string(usage)), 10, 64)
    
    // 读取最大使用量
    maxUsageFile := filepath.Join(cgroupPath, "memory.max_usage_in_bytes")
    maxUsage, err := ioutil.ReadFile(maxUsageFile)
    if err != nil {
        return nil, err
    }
    stats.MaxUsage, _ = strconv.ParseUint(strings.TrimSpace(string(maxUsage)), 10, 64)
    
    // 读取限制
    limitFile := filepath.Join(cgroupPath, "memory.limit_in_bytes")
    limit, err := ioutil.ReadFile(limitFile)
    if err != nil {
        return nil, err
    }
    stats.Limit, _ = strconv.ParseUint(strings.TrimSpace(string(limit)), 10, 64)
    
    return stats, nil
}
```

### 5.3 CPU子系统

```go
// cgroups/cpu.go
package cgroups

import (
    "fmt"
    "io/ioutil"
    "path/filepath"
    "strconv"
)

// CPUSubsystem CPU子系统
type CPUSubsystem struct{}

func (s *CPUSubsystem) Name() string {
    return "cpu"
}

func (s *CPUSubsystem) Set(cgroupPath string, res *Resources) error {
    if res.CPU == nil {
        return nil
    }
    
    // 设置CPU份额
    if res.CPU.Shares > 0 {
        sharesFile := filepath.Join(cgroupPath, "cpu.shares")
        if err := ioutil.WriteFile(sharesFile, []byte(strconv.FormatUint(res.CPU.Shares, 10)), 0644); err != nil {
            return fmt.Errorf("failed to set cpu shares: %v", err)
        }
    }
    
    // 设置CPU配额
    if res.CPU.Quota > 0 {
        quotaFile := filepath.Join(cgroupPath, "cpu.cfs_quota_us")
        if err := ioutil.WriteFile(quotaFile, []byte(strconv.FormatInt(res.CPU.Quota, 10)), 0644); err != nil {
            return fmt.Errorf("failed to set cpu quota: %v", err)
        }
    }
    
    // 设置CPU周期
    if res.CPU.Period > 0 {
        periodFile := filepath.Join(cgroupPath, "cpu.cfs_period_us")
        if err := ioutil.WriteFile(periodFile, []byte(strconv.FormatUint(res.CPU.Period, 10)), 0644); err != nil {
            return fmt.Errorf("failed to set cpu period: %v", err)
        }
    }
    
    return nil
}

func (s *CPUSubsystem) Apply(cgroupPath string, pid int) error {
    procsFile := filepath.Join(cgroupPath, "cgroup.procs")
    return ioutil.WriteFile(procsFile, []byte(strconv.Itoa(pid)), 0644)
}

func (s *CPUSubsystem) Remove(cgroupPath string) error {
    return os.RemoveAll(cgroupPath)
}
```

## 6. 文件系统管理

### 6.1 Rootfs管理

```go
// rootfs/rootfs.go
package rootfs

import (
    "fmt"
    "os"
    "path/filepath"
    "syscall"
)

// RootfsManager rootfs管理器
type RootfsManager struct {
    rootPath string
}

// NewRootfsManager 创建rootfs管理器
func NewRootfsManager(rootPath string) *RootfsManager {
    return &RootfsManager{
        rootPath: rootPath,
    }
}

// PrepareRootfs 准备根文件系统
func (rm *RootfsManager) PrepareRootfs() error {
    // 绑定挂载rootfs
    if err := syscall.Mount(rm.rootPath, rm.rootPath, "bind", syscall.MS_BIND|syscall.MS_REC, ""); err != nil {
        return fmt.Errorf("failed to bind mount rootfs: %v", err)
    }
    
    // 设置为私有挂载
    if err := syscall.Mount("", rm.rootPath, "", syscall.MS_PRIVATE|syscall.MS_REC, ""); err != nil {
        return fmt.Errorf("failed to make rootfs private: %v", err)
    }
    
    return nil
}

// MountSpecialFilesystems 挂载特殊文件系统
func (rm *RootfsManager) MountSpecialFilesystems() error {
    // 挂载/proc
    procPath := filepath.Join(rm.rootPath, "proc")
    if err := os.MkdirAll(procPath, 0755); err != nil {
        return err
    }
    if err := syscall.Mount("proc", procPath, "proc", 0, ""); err != nil {
        return fmt.Errorf("failed to mount proc: %v", err)
    }
    
    // 挂载/dev
    devPath := filepath.Join(rm.rootPath, "dev")
    if err := os.MkdirAll(devPath, 0755); err != nil {
        return err
    }
    if err := syscall.Mount("tmpfs", devPath, "tmpfs", syscall.MS_NOSUID|syscall.MS_STRICTATIME, "mode=755"); err != nil {
        return fmt.Errorf("failed to mount dev: %v", err)
    }
    
    // 创建必要的设备节点
    if err := rm.createDeviceNodes(); err != nil {
        return err
    }
    
    // 挂载/dev/pts
    ptsPath := filepath.Join(rm.rootPath, "dev", "pts")
    if err := os.MkdirAll(ptsPath, 0755); err != nil {
        return err
    }
    if err := syscall.Mount("devpts", ptsPath, "devpts", 0, "newinstance,ptmxmode=0666,mode=620"); err != nil {
        return fmt.Errorf("failed to mount devpts: %v", err)
    }
    
    // 挂载/dev/shm
    shmPath := filepath.Join(rm.rootPath, "dev", "shm")
    if err := os.MkdirAll(shmPath, 0755); err != nil {
        return err
    }
    if err := syscall.Mount("tmpfs", shmPath, "tmpfs", syscall.MS_NOSUID|syscall.MS_NODEV|syscall.MS_NOEXEC, ""); err != nil {
        return fmt.Errorf("failed to mount shm: %v", err)
    }
    
    // 挂载/sys
    sysPath := filepath.Join(rm.rootPath, "sys")
    if err := os.MkdirAll(sysPath, 0755); err != nil {
        return err
    }
    if err := syscall.Mount("sysfs", sysPath, "sysfs", syscall.MS_NOSUID|syscall.MS_NODEV|syscall.MS_NOEXEC|syscall.MS_RDONLY, ""); err != nil {
        return fmt.Errorf("failed to mount sys: %v", err)
    }
    
    return nil
}

// createDeviceNodes 创建设备节点
func (rm *RootfsManager) createDeviceNodes() error {
    devices := []struct {
        path  string
        mode  uint32
        dev   int
    }{
        {"/dev/null", syscall.S_IFCHR | 0666, makedev(1, 3)},
        {"/dev/zero", syscall.S_IFCHR | 0666, makedev(1, 5)},
        {"/dev/random", syscall.S_IFCHR | 0666, makedev(1, 8)},
        {"/dev/urandom", syscall.S_IFCHR | 0666, makedev(1, 9)},
        {"/dev/console", syscall.S_IFCHR | 0600, makedev(5, 1)},
        {"/dev/tty", syscall.S_IFCHR | 0666, makedev(5, 0)},
        {"/dev/ptmx", syscall.S_IFCHR | 0666, makedev(5, 2)},
    }
    
    for _, dev := range devices {
        devPath := filepath.Join(rm.rootPath, dev.path)
        
        // 删除已存在的设备
        os.Remove(devPath)
        
        // 创建设备节点
        if err := syscall.Mknod(devPath, dev.mode, dev.dev); err != nil {
            return fmt.Errorf("failed to create device %s: %v", dev.path, err)
        }
    }
    
    // 创建符号链接
    links := map[string]string{
        "/dev/fd":     "/proc/self/fd",
        "/dev/stdin":  "/proc/self/fd/0",
        "/dev/stdout": "/proc/self/fd/1",
        "/dev/stderr": "/proc/self/fd/2",
    }
    
    for link, target := range links {
        linkPath := filepath.Join(rm.rootPath, link)
        os.Remove(linkPath)
        if err := os.Symlink(target, linkPath); err != nil {
            return fmt.Errorf("failed to create symlink %s: %v", link, err)
        }
    }
    
    return nil
}

func makedev(major, minor int) int {
    return (major << 8) | minor
}
```

## 7. 安全模块

### 7.1 Capabilities管理

```go
// security/capabilities.go
package security

import (
    "fmt"
    "syscall"
    "unsafe"
)

// Capability Linux能力
type Capability int

const (
    CAP_CHOWN Capability = iota
    CAP_DAC_OVERRIDE
    CAP_DAC_READ_SEARCH
    CAP_FOWNER
    CAP_FSETID
    CAP_KILL
    CAP_SETGID
    CAP_SETUID
    CAP_SETPCAP
    CAP_NET_BIND_SERVICE
    CAP_NET_RAW
    CAP_SYS_CHROOT
    CAP_MKNOD
    CAP_AUDIT_WRITE
    CAP_SETFCAP
)

// capHeader 能力头结构
type capHeader struct {
    version uint32
    pid     int32
}

// capData 能力数据结构
type capData struct {
    effective   uint32
    permitted   uint32
    inheritable uint32
}

// CapabilityManager 能力管理器
type CapabilityManager struct {
    caps []Capability
}

// NewCapabilityManager 创建能力管理器
func NewCapabilityManager(caps []string) *CapabilityManager {
    cm := &CapabilityManager{}
    
    // 解析能力列表
    for _, cap := range caps {
        if c, ok := parseCapability(cap); ok {
            cm.caps = append(cm.caps, c)
        }
    }
    
    return cm
}

// Apply 应用能力设置
func (cm *CapabilityManager) Apply() error {
    // 获取当前能力
    header := &capHeader{
        version: 0x20080522, // _LINUX_CAPABILITY_VERSION_3
        pid:     0,          // 当前进程
    }
    
    var data [2]capData
    
    // 获取当前能力
    if _, _, err := syscall.Syscall(syscall.SYS_CAPGET, 
        uintptr(unsafe.Pointer(header)),
        uintptr(unsafe.Pointer(&data[0])),
        0); err != 0 {
        return fmt.Errorf("capget failed: %v", err)
    }
    
    // 清空所有能力
    data[0].effective = 0
    data[0].permitted = 0
    data[0].inheritable = 0
    data[1].effective = 0
    data[1].permitted = 0
    data[1].inheritable = 0
    
    // 设置需要的能力
    for _, cap := range cm.caps {
        if cap < 32 {
            data[0].effective |= 1 << uint(cap)
            data[0].permitted |= 1 << uint(cap)
        } else {
            data[1].effective |= 1 << uint(cap-32)
            data[1].permitted |= 1 << uint(cap-32)
        }
    }
    
    // 应用能力设置
    if _, _, err := syscall.Syscall(syscall.SYS_CAPSET,
        uintptr(unsafe.Pointer(header)),
        uintptr(unsafe.Pointer(&data[0])),
        0); err != 0 {
        return fmt.Errorf("capset failed: %v", err)
    }
    
    return nil
}

// DropAllCapabilities 丢弃所有能力
func DropAllCapabilities() error {
    header := &capHeader{
        version: 0x20080522,
        pid:     0,
    }
    
    var data [2]capData
    
    // 清空所有能力
    if _, _, err := syscall.Syscall(syscall.SYS_CAPSET,
        uintptr(unsafe.Pointer(header)),
        uintptr(unsafe.Pointer(&data[0])),
        0); err != 0 {
        return fmt.Errorf("failed to drop capabilities: %v", err)
    }
    
    return nil
}
```

## 8. 测试和调试

### 8.1 单元测试

```go
// container/container_test.go
package container

import (
    "testing"
    "os"
    "path/filepath"
)

func TestCreateContainer(t *testing.T) {
    // 准备测试环境
    testDir := "/tmp/minirunc-test"
    os.MkdirAll(testDir, 0755)
    defer os.RemoveAll(testDir)
    
    // 创建测试配置
    config := &ContainerConfig{
        Hostname: "test-container",
        Rootfs:   filepath.Join(testDir, "rootfs"),
        Cmd:      []string{"/bin/sh"},
        Env:      []string{"PATH=/bin:/usr/bin"},
    }
    
    // 创建容器
    c := &Container{
        ID:     "test-001",
        Config: config,
        State:  StateCreated,
    }
    
    // 验证容器创建
    if c.ID != "test-001" {
        t.Errorf("Expected container ID test-001, got %s", c.ID)
    }
    
    if c.State != StateCreated {
        t.Errorf("Expected container state Created, got %s", c.State)
    }
}

func TestNamespaceCreation(t *testing.T) {
    // 测试命名空间创建
    nm := NewNamespaceManager(os.Getpid())
    
    // 测试创建UTS命名空间
    err := nm.Create([]NamespaceType{NEWUTS})
    if err != nil && os.Getuid() != 0 {
        t.Skip("Skipping namespace test: requires root privileges")
    }
    
    if err != nil {
        t.Errorf("Failed to create UTS namespace: %v", err)
    }
}
```

### 8.2 集成测试

```bash
#!/bin/bash
# test/integration_test.sh

# 构建minirunc
go build -o minirunc main.go

# 准备测试rootfs
TEST_DIR="/tmp/minirunc-integration"
ROOTFS="$TEST_DIR/rootfs"

mkdir -p $ROOTFS
tar -xf alpine-rootfs.tar.gz -C $ROOTFS

# 创建配置文件
cat > $TEST_DIR/config.json <<EOF
{
    "hostname": "minirunc-test",
    "rootfs": "$ROOTFS",
    "cmd": ["/bin/sh", "-c", "echo 'Hello from container' && exit 0"],
    "env": ["PATH=/bin:/usr/bin"],
    "namespaces": [
        {"type": "pid"},
        {"type": "net"},
        {"type": "ipc"},
        {"type": "uts"},
        {"type": "mnt"}
    ],
    "resources": {
        "memory": {
            "limit": 134217728
        },
        "cpu": {
            "shares": 512
        }
    }
}
EOF

# 运行容器
./minirunc run --bundle $TEST_DIR test-container

# 清理
rm -rf $TEST_DIR
```

### 8.3 调试技巧

```go
// 调试辅助函数
package debug

import (
    "fmt"
    "runtime"
    "strings"
)

// Debug 输出调试信息
func Debug(format string, args ...interface{}) {
    if os.Getenv("DEBUG") != "1" {
        return
    }
    
    // 获取调用位置
    _, file, line, _ := runtime.Caller(1)
    file = filepath.Base(file)
    
    // 输出调试信息
    prefix := fmt.Sprintf("[DEBUG %s:%d]", file, line)
    msg := fmt.Sprintf(format, args...)
    fmt.Fprintf(os.Stderr, "%s %s\n", prefix, msg)
}

// TraceCall 跟踪函数调用
func TraceCall(name string) func() {
    Debug("Entering %s", name)
    return func() {
        Debug("Leaving %s", name)
    }
}

// 使用示例
func someFunction() {
    defer TraceCall("someFunction")()
    
    Debug("Processing data...")
    // 函数逻辑
}
```

## 9. 部署和使用

### 9.1 编译和安装

```bash
# 编译
go build -o minirunc main.go

# 安装到系统路径
sudo cp minirunc /usr/local/bin/

# 设置权限
sudo chmod +x /usr/local/bin/minirunc
```

### 9.2 使用示例

```bash
# 1. 准备bundle目录
mkdir -p /tmp/container/rootfs
cd /tmp/container

# 2. 解压rootfs
tar -xf /path/to/alpine-rootfs.tar.gz -C rootfs/

# 3. 创建配置文件
cat > config.json <<EOF
{
    "hostname": "my-container",
    "rootfs": "./rootfs",
    "cmd": ["/bin/sh"],
    "env": ["PATH=/bin:/usr/bin:/sbin:/usr/sbin"],
    "namespaces": [
        {"type": "pid"},
        {"type": "net"},
        {"type": "ipc"},
        {"type": "uts"},
        {"type": "mnt"}
    ],
    "mounts": [
        {
            "source": "/etc/resolv.conf",
            "destination": "/etc/resolv.conf",
            "type": "bind",
            "options": ["ro", "bind"]
        }
    ],
    "resources": {
        "memory": {
            "limit": 268435456
        },
        "cpu": {
            "shares": 1024,
            "quota": 100000,
            "period": 100000
        }
    },
    "capabilities": [
        "CAP_CHOWN",
        "CAP_DAC_OVERRIDE",
        "CAP_FSETID",
        "CAP_FOWNER",
        "CAP_SETGID",
        "CAP_SETUID",
        "CAP_SETPCAP",
        "CAP_NET_BIND_SERVICE",
        "CAP_SYS_CHROOT",
        "CAP_KILL",
        "CAP_AUDIT_WRITE"
    ]
}
EOF

# 4. 运行容器
sudo minirunc run my-container

# 5. 在另一个终端查看容器
sudo minirunc ps

# 6. 进入容器
sudo minirunc exec my-container /bin/sh

# 7. 停止容器
sudo minirunc kill my-container
```

## 10. 性能优化

### 10.1 启动时间优化

```go
// 并行初始化
func parallelInit(config *ContainerConfig) error {
    errCh := make(chan error, 3)
    
    // 并行执行初始化任务
    go func() {
        errCh <- setupRootfs(config)
    }()
    
    go func() {
        errCh <- setupNetwork(config)
    }()
    
    go func() {
        errCh <- setupCgroups(config)
    }()
    
    // 等待所有任务完成
    for i := 0; i < 3; i++ {
        if err := <-errCh; err != nil {
            return err
        }
    }
    
    return nil
}
```

### 10.2 内存优化

```go
// 使用对象池减少内存分配
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

func readWithPool(r io.Reader) ([]byte, error) {
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf)
    
    n, err := r.Read(buf)
    if err != nil {
        return nil, err
    }
    
    result := make([]byte, n)
    copy(result, buf[:n])
    return result, nil
}
```

## 总结

通过构建这个简化的容器运行时，我们实践了runc的核心技术:

1. **进程隔离**: 使用Linux命名空间实现进程、网络、文件系统等隔离
2. **资源管理**: 通过Cgroups限制和监控容器资源使用
3. **文件系统**: 实现rootfs切换和特殊文件系统挂载
4. **安全机制**: 应用Linux Capabilities和其他安全特性
5. **通信监控**: 建立容器与主机的通信通道

这个minirunc项目虽然简化，但涵盖了容器运行时的核心功能，是深入理解容器技术的绝佳实践。通过亲手实现这些功能，你将真正掌握容器技术的本质，为进一步的容器技术研究和开发打下坚实基础。

## 下一步建议

1. **增强功能**: 添加镜像管理、层文件系统支持
2. **提升性能**: 优化启动时间、减少资源开销
3. **完善安全**: 实现Seccomp、AppArmor/SELinux集成
4. **扩展网络**: 支持更多网络模式和CNI插件
5. **添加存储**: 实现volume管理和持久化存储
6. **集成编排**: 与Kubernetes CRI接口对接