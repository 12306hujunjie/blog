# å®‰å…¨ç‰¹æ€§å®ç°

> **ç³»åˆ—å¯¼èˆªï¼š** [runc å®¹å™¨è¿è¡Œæ—¶æ·±åº¦è§£æç³»åˆ—](./README.md) â†’ ç¬¬å…­ç¯‡ï¼šå®‰å…¨ç‰¹æ€§å®ç°  
> **ä¸Šä¸€ç¯‡ï¼š** [æ–‡ä»¶ç³»ç»Ÿä¸æŒ‚è½½ç®¡ç†](./05-æ–‡ä»¶ç³»ç»Ÿä¸æŒ‚è½½ç®¡ç†.md)  
> **æœ€åæ›´æ–°ï¼š** 2024

## æ¦‚è¿°

æœ¬æ–‡æ·±å…¥åˆ†æ runc çš„å®‰å…¨ç‰¹æ€§å®ç°ï¼ŒåŒ…æ‹¬ Capabilitiesã€Seccompã€AppArmor/SELinux ç­‰å¤šå±‚å®‰å…¨é˜²æŠ¤æœºåˆ¶ã€‚è¿™äº›å®‰å…¨ç‰¹æ€§ä¿éšœäº†å®¹å™¨çš„éš”ç¦»æ€§å’Œå®‰å…¨æ€§ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ¨¡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- æ·±å…¥ç†è§£å®¹å™¨å®‰å…¨çš„å¤šå±‚é˜²æŠ¤ä½“ç³»å’Œæ”»å‡»é¢
- æŒæ¡ Linux Capabilities çš„ç»†ç²’åº¦æƒé™æ§åˆ¶æœºåˆ¶
- ç†è§£ seccomp ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤çš„å®ç°åŸç†å’Œé…ç½®æ–¹æ³•
- ç†Ÿæ‚‰ AppArmor/SELinux å¼ºåˆ¶è®¿é—®æ§åˆ¶çš„é›†æˆæ–¹å¼
- æŒæ¡ç”¨æˆ·å‘½åç©ºé—´æƒé™æ˜ å°„çš„å®‰å…¨æ¨¡å‹
- å…·å¤‡è®¾è®¡å’Œå®æ–½å®¹å™¨å®‰å…¨ç­–ç•¥çš„å®è·µèƒ½åŠ›

## 1. å®¹å™¨å®‰å…¨å¨èƒæ¨¡å‹

### 1.1 å®¹å™¨å®‰å…¨è¾¹ç•Œ

å®¹å™¨å®‰å…¨éœ€è¦åœ¨å¤šä¸ªå±‚é¢å»ºç«‹é˜²æŠ¤è¾¹ç•Œï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                åº”ç”¨å±‚                           â”‚ â† åº”ç”¨æ¼æ´ã€æ¶æ„ä»£ç 
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              å®¹å™¨è¿è¡Œæ—¶å±‚                       â”‚ â† å®¹å™¨é€ƒé€¸ã€æƒé™æå‡
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           runc å®‰å…¨æœºåˆ¶             â”‚    â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
â”‚  â”‚ â”‚ Capabilitiesâ”‚    seccomp         â”‚ â”‚    â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
â”‚  â”‚ â”‚ AppArmor/   â”‚  User Namespaces   â”‚ â”‚    â”‚
â”‚  â”‚ â”‚ SELinux     â”‚                    â”‚ â”‚    â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Linux å†…æ ¸å±‚                     â”‚ â† å†…æ ¸æ¼æ´ã€é©±åŠ¨é—®é¢˜
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                ç¡¬ä»¶å±‚                           â”‚ â† ç¡¬ä»¶æ¼æ´ã€ä¾§ä¿¡é“æ”»å‡»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ä¸»è¦æ”»å‡»å‘é‡

| æ”»å‡»ç±»å‹ | æè¿° | runc é˜²æŠ¤æœºåˆ¶ |
|----------|------|--------------|
| **å®¹å™¨é€ƒé€¸** | çªç ´å®¹å™¨è¾¹ç•Œè®¿é—®å®¿ä¸»æœº | Namespaces + Capabilities + seccomp |
| **æƒé™æå‡** | è·å¾—è¶…å‡ºé¢„æœŸçš„æƒé™ | User Namespaces + Capabilities |
| **èµ„æºè€—å°½** | DOSæ”»å‡»è€—å°½ç³»ç»Ÿèµ„æº | Cgroups + rlimits |
| **ä¿¡æ¯æ³„éœ²** | è®¿é—®ä¸åº”è®¿é—®çš„ä¿¡æ¯ | /procæ£€æŸ¥ + æ–‡ä»¶ç³»ç»Ÿéš”ç¦» |
| **ç³»ç»Ÿè°ƒç”¨æ»¥ç”¨** | åˆ©ç”¨å±é™©ç³»ç»Ÿè°ƒç”¨ | seccomp è¿‡æ»¤ |
| **æ¨ªå‘ç§»åŠ¨** | æ”»å‡»å…¶ä»–å®¹å™¨æˆ–æœåŠ¡ | ç½‘ç»œéš”ç¦» + SELinux/AppArmor |

### 1.3 å®‰å…¨æ¶æ„è®¾è®¡åŸåˆ™

```go
// å®‰å…¨é…ç½®çš„æ ¸å¿ƒç»“æ„
type SecurityConfig struct {
    // æƒé™æ§åˆ¶
    Capabilities     *Capabilities    `json:"capabilities,omitempty"`
    NoNewPrivileges  bool            `json:"no_new_privileges,omitempty"`
    
    // ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤
    Seccomp          *Seccomp        `json:"seccomp,omitempty"`
    
    // å¼ºåˆ¶è®¿é—®æ§åˆ¶
    AppArmorProfile  string          `json:"apparmor_profile,omitempty"`
    ProcessLabel     string          `json:"process_label,omitempty"`    // SELinux
    MountLabel       string          `json:"mount_label,omitempty"`      // SELinux
    
    // ç”¨æˆ·æƒé™æ˜ å°„
    UIDMappings      []IDMap         `json:"uid_mappings,omitempty"`
    GIDMappings      []IDMap         `json:"gid_mappings,omitempty"`
    
    // æ–‡ä»¶ç³»ç»Ÿå®‰å…¨
    MaskPaths        []string        `json:"mask_paths,omitempty"`
    ReadonlyPaths    []string        `json:"readonly_paths,omitempty"`
    Readonlyfs       bool            `json:"readonlyfs,omitempty"`
}
```

**æ ¸å¿ƒåŸåˆ™**ï¼š
- ğŸ”’ **æœ€å°æƒé™åŸåˆ™**: åªæˆäºˆå¿…è¦çš„æœ€å°æƒé™
- ğŸ›¡ï¸ **æ·±åº¦é˜²æŠ¤**: å¤šå±‚å®‰å…¨æœºåˆ¶ç›¸äº’è¡¥å……
- ğŸš« **é»˜è®¤æ‹’ç»**: é™¤éæ˜ç¡®å…è®¸ï¼Œå¦åˆ™æ‹’ç»è®¿é—®
- ğŸ“ **å®¡è®¡è·Ÿè¸ª**: è®°å½•å®‰å…¨ç›¸å…³çš„æ“ä½œå’Œå†³ç­–

## 2. Linux Capabilities æƒé™æ§åˆ¶

### 2.1 Capabilities åŸºç¡€æ¦‚å¿µ

ä¼ ç»Ÿçš„ Unix æƒé™æ¨¡å‹åªæœ‰ **ç‰¹æƒç”¨æˆ· (root)** å’Œ **æ™®é€šç”¨æˆ·** çš„åŒºåˆ†ã€‚Linux Capabilities å°† root çš„è¶…çº§æƒé™åˆ†è§£ä¸ºç»†ç²’åº¦çš„èƒ½åŠ›ä½ï¼š

```
ä¼ ç»Ÿæƒé™æ¨¡å‹:              Capabilities æ¨¡å‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     root     â”‚   åˆ†è§£   â”‚ CAP_NET_ADMIN  (ç½‘ç»œç®¡ç†)   â”‚
â”‚  (æ‰€æœ‰æƒé™)   â”‚  â”€â”€â”€â”€â†’  â”‚ CAP_SYS_ADMIN  (ç³»ç»Ÿç®¡ç†)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚ CAP_KILL       (å‘é€ä¿¡å·)   â”‚
       â”‚                 â”‚ CAP_CHOWN      (æ–‡ä»¶æ‰€æœ‰æƒ) â”‚
       â”‚                 â”‚ CAP_SETUID     (åˆ‡æ¢ç”¨æˆ·)   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚ CAP_MKNOD      (åˆ›å»ºè®¾å¤‡)   â”‚
â”‚  æ™®é€šç”¨æˆ·     â”‚         â”‚ ... 38+ ç§èƒ½åŠ›             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 äº”ç§ Capabilities é›†åˆ

```go
// libcontainer/configs/config.go:145
type Capabilities struct {
    // è¾¹ç•Œé›†ï¼šå†…æ ¸æ£€æŸ¥çš„èƒ½åŠ›ä¸Šé™
    Bounding    []string `json:"bounding,omitempty"`
    
    // æœ‰æ•ˆé›†ï¼šå½“å‰æ­£åœ¨ä½¿ç”¨çš„èƒ½åŠ›
    Effective   []string `json:"effective,omitempty"`
    
    // å¯ç»§æ‰¿é›†ï¼šå¯ä»¥ä¼ é€’ç»™å­è¿›ç¨‹çš„èƒ½åŠ›
    Inheritable []string `json:"inheritable,omitempty"`
    
    // è®¸å¯é›†ï¼šè¿›ç¨‹è¢«å…è®¸æ‹¥æœ‰çš„èƒ½åŠ›ä¸Šé™
    Permitted   []string `json:"permitted,omitempty"`
    
    // ç¯å¢ƒé›†ï¼šåœ¨ execve åè‡ªåŠ¨æ·»åŠ åˆ°è®¸å¯å’Œæœ‰æ•ˆé›†çš„èƒ½åŠ›
    Ambient     []string `json:"ambient,omitempty"`
}
```

**é›†åˆå…³ç³»å›¾**ï¼š

```
è¿›ç¨‹æ‰§è¡Œå‰:                    execve() å:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bounding    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ æ–°è¿›ç¨‹ Bounding â”‚ (ä¸å˜)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Permitted   â”‚â”€â”             â”‚ æ–°è¿›ç¨‹ Permittedâ”‚ (æŒ‰è§„åˆ™è®¡ç®—)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ è®¡ç®—         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Inheritable â”‚â”€â”¼â”€è§„åˆ™â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ æ–°è¿›ç¨‹ Effectiveâ”‚ (æŒ‰è§„åˆ™è®¡ç®—)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ambient     â”‚â”€â”˜             â”‚ æ–°è¿›ç¨‹ Inheritableâ”‚ (ç»§æ‰¿)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 å¸¸ç”¨ Capabilities è¯¦è§£

| Capability | åŠŸèƒ½ | å®¹å™¨ä¸­çš„åº”ç”¨ |
|------------|------|-------------|
| **CAP_NET_ADMIN** | ç½‘ç»œç®¡ç†æƒé™ | é…ç½®ç½‘ç»œæ¥å£ã€è·¯ç”±ã€iptables |
| **CAP_NET_BIND_SERVICE** | ç»‘å®šç‰¹æƒç«¯å£(<1024) | WebæœåŠ¡å™¨ç›‘å¬80/443ç«¯å£ |
| **CAP_SYS_ADMIN** | ç³»ç»Ÿç®¡ç†æƒé™ | æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿã€è®¾ç½®ä¸»æœºå |
| **CAP_SYS_TIME** | ä¿®æ”¹ç³»ç»Ÿæ—¶é—´ | NTPæœåŠ¡ã€æ—¶é—´åŒæ­¥ |
| **CAP_KILL** | å‘é€ä¿¡å·åˆ°ä»»æ„è¿›ç¨‹ | è¿›ç¨‹ç›‘æ§ã€ä¿¡å·ä¼ é€’ |
| **CAP_CHOWN** | ä¿®æ”¹æ–‡ä»¶æ‰€æœ‰æƒ | æ–‡ä»¶æƒé™ç®¡ç† |
| **CAP_SETUID/SETGID** | åˆ‡æ¢ç”¨æˆ·ID | sudoã€è®¤è¯æœåŠ¡ |
| **CAP_MKNOD** | åˆ›å»ºè®¾å¤‡æ–‡ä»¶ | è®¾å¤‡é©±åŠ¨ã€ç‰¹æ®Šè®¾å¤‡ |

### 2.4 runc ä¸­çš„ Capabilities å®ç°

#### åº”ç”¨æµç¨‹

```go
// libcontainer/capabilities/capabilities.go:61
func ApplyCapabilities(c *configs.Capabilities) error {
    // 1. æ¸…é™¤æ‰€æœ‰ capabilities é›†åˆ
    if err := clearCapabilities(); err != nil {
        return err
    }
    
    // 2. æŒ‰ç…§ç‰¹å®šé¡ºåºè®¾ç½® capabilities
    // é¡ºåºå¾ˆé‡è¦ï¼Œå› ä¸ºä¸åŒé›†åˆä¹‹é—´æœ‰ä¾èµ–å…³ç³»
    if err := setCapabilities(c.Effective, effective); err != nil {
        return fmt.Errorf("failed to set effective capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Permitted, permitted); err != nil {
        return fmt.Errorf("failed to set permitted capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Inheritable, inheritable); err != nil {
        return fmt.Errorf("failed to set inheritable capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Bounding, bounding); err != nil {
        return fmt.Errorf("failed to set bounding capabilities: %w", err)
    }
    
    // 3. Ambient é›†åˆéœ€è¦ç‰¹æ®Šå¤„ç†
    if err := setAmbientCapabilities(c.Ambient); err != nil {
        return fmt.Errorf("failed to set ambient capabilities: %w", err)
    }
    
    return nil
}
```

#### Ambient Capabilities ç‰¹æ®Šå¤„ç†

```go
func setAmbientCapabilities(caps []string) error {
    // Ambient capabilities æ˜¯è¾ƒæ–°çš„ç‰¹æ€§ï¼Œéœ€è¦ç‰¹åˆ«å¤„ç†
    for _, cap := range caps {
        capInt, err := getCapabilityNumber(cap)
        if err != nil {
            continue  // å¿½ç•¥ä¸æ”¯æŒçš„ capability
        }
        
        // é‡ç½® ambient é›†åˆ
        if err := unix.Prctl(unix.PR_CAP_AMBIENT, 
                           unix.PR_CAP_AMBIENT_CLEAR_ALL, 0, 0, 0); err != nil {
            return err
        }
        
        // é€ä¸ªæ·»åŠ  capability åˆ° ambient é›†åˆ
        if err := unix.Prctl(unix.PR_CAP_AMBIENT, 
                           unix.PR_CAP_AMBIENT_RAISE, capInt, 0, 0); err != nil {
            // å¦‚æœå¤±è´¥ï¼Œå¯èƒ½æ˜¯å› ä¸ºè¯¥ capability ä¸åœ¨ permitted æˆ– inheritable é›†åˆä¸­
            return fmt.Errorf("failed to add %s to ambient set: %w", cap, err)
        }
    }
    
    return nil
}
```

#### å…¼å®¹æ€§å¤„ç†

```go
func setCapabilities(caps []string, capType capabilityType) error {
    for _, cap := range caps {
        capInt, err := getCapabilityNumber(cap)
        if err != nil {
            // å¯¹äºæœªçŸ¥çš„ capabilityï¼Œè®°å½•è­¦å‘Šä½†ä¸æŠ¥é”™
            // è¿™ä¿è¯äº†å‘å‰å…¼å®¹æ€§
            logrus.WithError(err).Warnf("Ignoring unknown capability %q", cap)
            continue
        }
        
        if err := applySingleCapability(capInt, capType); err != nil {
            // æŸäº› capability åœ¨ç‰¹å®šå†…æ ¸ç‰ˆæœ¬ä¸­å¯èƒ½ä¸å¯ç”¨
            if errors.Is(err, unix.EINVAL) {
                logrus.WithError(err).Warnf("Capability %s not supported", cap)
                continue
            }
            return err
        }
    }
    
    return nil
}
```

### 2.5 é»˜è®¤ Capabilities ç­–ç•¥

runc ä½¿ç”¨ä¿å®ˆçš„é»˜è®¤ capabilities ç­–ç•¥ï¼š

```go
// é»˜è®¤æˆäºˆçš„ capabilitiesï¼ˆæœ€å°é›†åˆï¼‰
var defaultCapabilities = []string{
    "CAP_CHOWN",           // ä¿®æ”¹æ–‡ä»¶æ‰€æœ‰æƒ
    "CAP_DAC_OVERRIDE",    // ç»•è¿‡æ–‡ä»¶æƒé™æ£€æŸ¥
    "CAP_FSETID",          // è®¾ç½®æ–‡ä»¶ set-user-ID ä½
    "CAP_FOWNER",          // ç»•è¿‡æ–‡ä»¶æ‰€æœ‰æƒæ£€æŸ¥
    "CAP_MKNOD",           // åˆ›å»ºè®¾å¤‡æ–‡ä»¶
    "CAP_NET_RAW",         // ä½¿ç”¨ RAW å’Œ PACKET å¥—æ¥å­—
    "CAP_SETGID",          // ä¿®æ”¹è¿›ç¨‹ GID
    "CAP_SETUID",          // ä¿®æ”¹è¿›ç¨‹ UID
    "CAP_SETFCAP",         // è®¾ç½®æ–‡ä»¶ capabilities
    "CAP_SETPCAP",         // ä¿®æ”¹è¿›ç¨‹ capabilities
    "CAP_NET_BIND_SERVICE", // ç»‘å®šç‰¹æƒç«¯å£
    "CAP_SYS_CHROOT",      // ä½¿ç”¨ chroot
    "CAP_KILL",            // å‘é€ä¿¡å·
    "CAP_AUDIT_WRITE",     // å†™å…¥å®¡è®¡æ—¥å¿—
}

// æ˜ç¡®ç¦ç”¨çš„å±é™© capabilities
var droppedCapabilities = []string{
    "CAP_SYS_ADMIN",       // ç³»ç»Ÿç®¡ç†æƒé™
    "CAP_SYS_TIME",        // ä¿®æ”¹ç³»ç»Ÿæ—¶é—´
    "CAP_NET_ADMIN",       // ç½‘ç»œç®¡ç†æƒé™
    "CAP_SYS_MODULE",      // åŠ è½½å†…æ ¸æ¨¡å—
    "CAP_SYS_RAWIO",       // ç›´æ¥ I/O è®¿é—®
    "CAP_SYS_PTRACE",      // è°ƒè¯•å…¶ä»–è¿›ç¨‹
    "CAP_SYS_NICE",        // ä¿®æ”¹è¿›ç¨‹ä¼˜å…ˆçº§
    "CAP_IPC_LOCK",        // é”å®šå†…å­˜é¡µ
    "CAP_SYS_RESOURCE",    // ä¿®æ”¹èµ„æºé™åˆ¶
    "CAP_SYS_TTY_CONFIG",  // ä¿®æ”¹ TTY é…ç½®
    "CAP_LEASE",           // æ–‡ä»¶ç§Ÿçº¦
    "CAP_WAKE_ALARM",      // è®¾ç½®å®æ—¶æ—¶é’Ÿè­¦æŠ¥
    "CAP_BLOCK_SUSPEND",   // é˜»æ­¢ç³»ç»Ÿä¼‘çœ 
}
```

## 3. seccomp ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤

### 3.1 seccomp åŸºç¡€åŸç†

**seccomp (secure computing mode)** æ˜¯ Linux å†…æ ¸çš„å®‰å…¨æœºåˆ¶ï¼Œå¯ä»¥é™åˆ¶è¿›ç¨‹èƒ½å¤Ÿè°ƒç”¨çš„ç³»ç»Ÿè°ƒç”¨ã€‚

```
ç”¨æˆ·ç©ºé—´ç¨‹åº                    å†…æ ¸ç©ºé—´
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨ç¨‹åº       â”‚            â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   ç³»ç»Ÿè°ƒç”¨  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  open()   â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  â”‚   seccomp BPF   â”‚ â”‚
â”‚  â”‚  write()  â”‚  â”‚            â”‚  â”‚     è¿‡æ»¤å™¨       â”‚ â”‚
â”‚  â”‚  exec()   â”‚  â”‚            â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚        â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚        â–¼             â”‚
                               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                               â”‚  â”‚ ALLOW/DENY/TRAP â”‚ â”‚
                               â”‚  â”‚ TRACE/LOG/ERRNO â”‚ â”‚
                               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 seccomp é…ç½®ç»“æ„

```go
// libcontainer/configs/config.go:207
type Seccomp struct {
    // é»˜è®¤åŠ¨ä½œï¼šå¯¹æœªåŒ¹é…è§„åˆ™çš„ç³»ç»Ÿè°ƒç”¨æ‰§è¡Œçš„åŠ¨ä½œ
    DefaultAction    Action                   `json:"default_action"`
    
    // æ¶æ„åˆ—è¡¨ï¼šé™åˆ¶åœ¨ç‰¹å®šCPUæ¶æ„ä¸Š
    Architectures    []string                 `json:"architectures"`
    
    // æ ‡å¿—ï¼šseccompçš„è¡Œä¸ºæ§åˆ¶æ ‡å¿—
    Flags            []specs.LinuxSeccompFlag `json:"flags"`
    
    // ç³»ç»Ÿè°ƒç”¨è§„åˆ™åˆ—è¡¨
    Syscalls         []*Syscall               `json:"syscalls"`
    
    // é»˜è®¤é”™è¯¯è¿”å›å€¼ï¼šå½“åŠ¨ä½œä¸ºERRNOæ—¶è¿”å›çš„é”™è¯¯ç 
    DefaultErrnoRet  *uint                    `json:"default_errno_ret"`
    
    // ç›‘å¬è·¯å¾„ï¼šç”¨äº seccomp notify æœºåˆ¶
    ListenerPath     string                   `json:"listener_path,omitempty"`
    
    // ç›‘å¬å…ƒæ•°æ®ï¼šä¼ é€’ç»™ç›‘å¬å™¨çš„é¢å¤–ä¿¡æ¯
    ListenerMetadata string                   `json:"listener_metadata,omitempty"`
}

// ç³»ç»Ÿè°ƒç”¨è§„åˆ™
type Syscall struct {
    Name     string `json:"name"`          // ç³»ç»Ÿè°ƒç”¨åç§°
    Action   Action `json:"action"`        // æ‰§è¡Œçš„åŠ¨ä½œ
    ErrnoRet *uint  `json:"errnoRet"`      // ERRNOåŠ¨ä½œçš„è¿”å›å€¼
    Args     []*Arg `json:"args"`          // å‚æ•°è¿‡æ»¤æ¡ä»¶
}

// å‚æ•°è¿‡æ»¤æ¡ä»¶
type Arg struct {
    Index    uint     `json:"index"`    // å‚æ•°ç´¢å¼• (0-5)
    Value    uint64   `json:"value"`    // æ¯”è¾ƒå€¼
    ValueTwo *uint64  `json:"valueTwo"` // èŒƒå›´æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼
    Op       Operator `json:"op"`       // æ¯”è¾ƒæ“ä½œç¬¦
}
```

### 3.3 seccomp åŠ¨ä½œç±»å‹

| åŠ¨ä½œ | æè¿° | åº”ç”¨åœºæ™¯ |
|------|------|----------|
| **KILL/KILL_THREAD** | ç»ˆæ­¢è¿›ç¨‹/çº¿ç¨‹ | ç»å¯¹ç¦æ­¢çš„ç³»ç»Ÿè°ƒç”¨ |
| **ERRNO** | è¿”å›é”™è¯¯ç  | ä¼˜é›…å¤„ç†ä¸å…è®¸çš„è°ƒç”¨ |
| **TRAP** | å‘é€ SIGSYS ä¿¡å· | è°ƒè¯•å’Œç›‘æ§ |
| **ALLOW** | å…è®¸æ‰§è¡Œ | ç™½åå•æ¨¡å¼ |
| **TRACE** | è·Ÿè¸ªæ‰§è¡Œ | å®‰å…¨å®¡è®¡ |
| **LOG** | è®°å½•æ—¥å¿— | ç›‘æ§å¯ç–‘è°ƒç”¨ |
| **NOTIFY** | é€šçŸ¥ç”¨æˆ·ç©ºé—´ | åŠ¨æ€å®‰å…¨å†³ç­– |

### 3.4 runc ä¸­çš„ seccomp å®ç°

#### è¿‡æ»¤å™¨åˆå§‹åŒ–

```go
// libcontainer/seccomp/seccomp_linux.go:89
func InitSeccomp(config *configs.Seccomp) error {
    if config == nil {
        return errors.New("cannot initialize Seccomp - nil config passed")
    }
    
    // åˆ›å»º seccomp è¿‡æ»¤å™¨ä¸Šä¸‹æ–‡
    filter, err := libseccomp.NewFilter(seccompAction(config.DefaultAction))
    if err != nil {
        return fmt.Errorf("failed to create seccomp filter: %w", err)
    }
    defer filter.Release()
    
    // è®¾ç½®æ¶æ„é™åˆ¶
    for _, arch := range config.Architectures {
        scmpArch, err := libseccomp.GetArchFromString(arch)
        if err != nil {
            return fmt.Errorf("invalid architecture %s: %w", arch, err)
        }
        
        if err := filter.AddArch(scmpArch); err != nil {
            return fmt.Errorf("failed to add architecture %s: %w", arch, err)
        }
    }
    
    // æ·»åŠ ç³»ç»Ÿè°ƒç”¨è§„åˆ™
    for _, syscall := range config.Syscalls {
        if err := addSyscallRule(filter, syscall); err != nil {
            return fmt.Errorf("failed to add syscall rule for %s: %w", 
                             syscall.Name, err)
        }
    }
    
    // åº”ç”¨ BPF è¡¥ä¸ä¼˜åŒ–
    if err := patchbpf.PatchAndLoad(config, filter); err != nil {
        return fmt.Errorf("failed to patch and load seccomp filter: %w", err)
    }
    
    return nil
}
```

#### ç³»ç»Ÿè°ƒç”¨è§„åˆ™æ·»åŠ 

```go
func addSyscallRule(filter *libseccomp.ScmpFilter, syscall *Syscall) error {
    // è·å–ç³»ç»Ÿè°ƒç”¨å·
    scmpSyscall, err := libseccomp.GetSyscallFromName(syscall.Name)
    if err != nil {
        // å¿½ç•¥æœªçŸ¥çš„ç³»ç»Ÿè°ƒç”¨ï¼Œæé«˜å…¼å®¹æ€§
        logrus.WithError(err).Debugf("Ignoring unknown syscall %s", syscall.Name)
        return nil
    }
    
    // æ„å»ºå‚æ•°æ¡ä»¶
    var conditions []libseccomp.ScmpCondition
    for _, arg := range syscall.Args {
        condition := libseccomp.ScmpCondition{
            Argument: arg.Index,
            Op:       libseccomp.ScmpCompareOp(arg.Op),
            Operand1: arg.Value,
        }
        
        // å¤„ç†èŒƒå›´æ¯”è¾ƒ
        if arg.ValueTwo != nil {
            condition.Operand2 = *arg.ValueTwo
        }
        
        conditions = append(conditions, condition)
    }
    
    // æ·»åŠ è§„åˆ™åˆ°è¿‡æ»¤å™¨
    action := seccompAction(syscall.Action)
    if err := filter.AddRuleConditional(scmpSyscall, action, conditions); err != nil {
        return fmt.Errorf("failed to add conditional rule: %w", err)
    }
    
    return nil
}
```

### 3.5 BPF è¡¥ä¸ä¼˜åŒ–

runc å®ç°äº† BPF ç¨‹åºè¡¥ä¸æœºåˆ¶æ¥ä¼˜åŒ– seccomp æ€§èƒ½ï¼š

```go
// libcontainer/seccomp/patchbpf/enosys_linux.go:45
func PatchAndLoad(config *configs.Seccomp, filter *libseccomp.ScmpFilter) error {
    // ç”Ÿæˆ BPF å­—èŠ‚ç 
    program, err := filter.ExportBPF()
    if err != nil {
        return err
    }
    
    // åº”ç”¨ ENOSYS è¡¥ä¸ï¼šå¯¹æœªçŸ¥ç³»ç»Ÿè°ƒç”¨è¿”å› ENOSYS è€Œä¸æ˜¯ kill
    if needsEnosysPatch(config) {
        program, err = patchEnosys(program)
        if err != nil {
            return fmt.Errorf("failed to patch BPF program: %w", err)
        }
    }
    
    // åŠ è½½è¡¥ä¸åçš„ BPF ç¨‹åº
    if err := unix.Prctl(unix.PR_SET_SECCOMP, unix.SECCOMP_MODE_FILTER, 
                        uintptr(unsafe.Pointer(&program[0])), 0, 0); err != nil {
        return fmt.Errorf("failed to load seccomp filter: %w", err)
    }
    
    return nil
}

func needsEnosysPatch(config *configs.Seccomp) bool {
    // å½“é»˜è®¤åŠ¨ä½œä¸æ˜¯ ALLOW ä¸”æ²¡æœ‰ä½¿ç”¨ notify æœºåˆ¶æ—¶éœ€è¦è¡¥ä¸
    return config.DefaultAction != configs.Kill && 
           config.DefaultAction != configs.KillThread &&
           config.ListenerPath == ""
}
```

### 3.6 é«˜çº§ç‰¹æ€§ï¼šseccomp notify

seccomp notify æ˜¯è¾ƒæ–°çš„ç‰¹æ€§ï¼Œå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºåŠ¨æ€å¤„ç†ç³»ç»Ÿè°ƒç”¨ï¼š

```go
// æ£€æŸ¥ notify æœºåˆ¶çš„é™åˆ¶
func validateNotifyConfig(config *configs.Seccomp) error {
    if config.ListenerPath == "" {
        return nil
    }
    
    // notify æœºåˆ¶éœ€è¦ Linux 5.7+ å’Œ libseccomp 2.5.0+
    if !isNotifySupported() {
        return errors.New("seccomp notify requires Linux 5.7+ and libseccomp 2.5.0+")
    }
    
    // write ç³»ç»Ÿè°ƒç”¨ä¸èƒ½ä½¿ç”¨ notify (é¿å…åˆå§‹åŒ–æ­»é”)
    for _, syscall := range config.Syscalls {
        if syscall.Name == "write" && syscall.Action == configs.Notify {
            return errors.New("write syscall cannot use notify action")
        }
    }
    
    return nil
}
```

### 3.7 é»˜è®¤ seccomp ç­–ç•¥

runc æä¾›äº†ä¿å®ˆçš„é»˜è®¤ seccomp é…ç½®ï¼š

```go
// é»˜è®¤è¢«é˜»æ­¢çš„å±é™©ç³»ç»Ÿè°ƒç”¨
var defaultBlockedSyscalls = []string{
    // å†…æ ¸æ¨¡å—æ“ä½œ
    "init_module", "finit_module", "delete_module",
    
    // ç›´æ¥å†…å­˜è®¿é—®
    "iopl", "ioperm", 
    
    // æ—¶é—´ä¿®æ”¹
    "clock_settime", "settimeofday", "stime",
    
    // æŒ‚è½½æ“ä½œ
    "mount", "umount2", "swapon", "swapoff",
    
    // ç³»ç»Ÿæ§åˆ¶
    "reboot", "sethostname", "setdomainname",
    
    // è¿›ç¨‹è·Ÿè¸ª
    "ptrace",
    
    // æ€§èƒ½ç›‘æ§
    "perf_event_open",
    
    // å®¹å™¨é€ƒé€¸ç›¸å…³
    "unshare", "clone", "setns",
}

// ç”Ÿæˆé»˜è®¤ seccomp é…ç½®
func DefaultProfile() *configs.Seccomp {
    return &configs.Seccomp{
        DefaultAction: configs.Allow,  // é»˜è®¤å…è®¸
        Architectures: []string{runtime.GOARCH},
        Syscalls: []*configs.Syscall{
            // é˜»æ­¢å±é™©ç³»ç»Ÿè°ƒç”¨
            {
                Names:  defaultBlockedSyscalls,
                Action: configs.Errno,
                ErrnoRet: uint(unix.EPERM),
            },
            
            // clone ç³»ç»Ÿè°ƒç”¨ç‰¹æ®Šå¤„ç†
            {
                Names:  []string{"clone"},
                Action: configs.Allow,
                Args: []*configs.Arg{
                    // åªå…è®¸ç‰¹å®šçš„ clone æ ‡å¿—
                    {
                        Index: 0,
                        Value: unix.CLONE_NEWNS,
                        Op:    configs.OpMaskedEqual,
                    },
                },
            },
        },
    }
}
```

## 4. AppArmor/SELinux å¼ºåˆ¶è®¿é—®æ§åˆ¶

### 4.1 MAC vs DAC

**DAC (Discretionary Access Control)**ï¼šä¼ ç»Ÿçš„ Unix æƒé™æ¨¡å‹
- æ–‡ä»¶æ‰€æœ‰è€…å¯ä»¥å†³å®šè®¿é—®æƒé™
- åŸºäºç”¨æˆ·/ç»„/å…¶ä»–çš„ç®€å•ä¸‰å…ƒæ¨¡å‹
- å®¹æ˜“è¢«æ¶æ„ç¨‹åºç»•è¿‡

**MAC (Mandatory Access Control)**ï¼šå¼ºåˆ¶è®¿é—®æ§åˆ¶
- ç³»ç»Ÿç®¡ç†å‘˜è®¾ç½®çš„ç­–ç•¥ä¸èƒ½è¢«ç»•è¿‡
- åŸºäºå®‰å…¨æ ‡ç­¾å’Œç­–ç•¥è§„åˆ™
- æä¾›æ›´å¼ºçš„å®‰å…¨ä¿æŠ¤

```
DAC æ¨¡å‹:                      MAC æ¨¡å‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ–‡ä»¶æ‰€æœ‰è€…     â”‚   å†³å®š     â”‚      ç³»ç»Ÿç®¡ç†å‘˜             â”‚   åˆ¶å®š
â”‚  è®¾ç½®æƒé™       â”‚  â”€â”€â”€â”€â†’    â”‚      åˆ¶å®šå®‰å…¨ç­–ç•¥           â”‚  â”€â”€â”€â”€â†’
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                    â”‚
       â–¼                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ rwx permissions â”‚           â”‚    AppArmor/SELinux ç­–ç•¥    â”‚
â”‚ user:group:otherâ”‚           â”‚      ä¸å¯è¢«è¿›ç¨‹ä¿®æ”¹         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 AppArmor é›†æˆ

#### åŸºç¡€å®ç°

```go
// libcontainer/apparmor/apparmor_linux.go:32
func ApplyProfile(name string) error {
    if name == "" {
        return nil
    }
    
    // æ£€æŸ¥ AppArmor æ˜¯å¦å¯ç”¨
    if !IsEnabled() {
        return errors.New("AppArmor is not enabled on this system")
    }
    
    // åœ¨ exec æ—¶åˆ‡æ¢åˆ°æŒ‡å®šçš„ profile
    return changeOnExec(name)
}

func IsEnabled() bool {
    // æ£€æŸ¥ AppArmor æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦æŒ‚è½½
    if _, err := os.Stat("/sys/kernel/security/apparmor"); err != nil {
        return false
    }
    
    // æ£€æŸ¥å½“å‰è¿›ç¨‹æ˜¯å¦åœ¨ AppArmor æ§åˆ¶ä¸‹
    data, err := os.ReadFile("/proc/self/attr/current")
    if err != nil {
        return false
    }
    
    // å¦‚æœä¸æ˜¯ "unconfined"ï¼Œè¯´æ˜ AppArmor å·²å¯ç”¨
    return !strings.Contains(string(data), "unconfined")
}

func changeOnExec(name string) error {
    // å†™å…¥ exec å±æ€§æ–‡ä»¶ï¼Œåœ¨ä¸‹æ¬¡ exec æ—¶åˆ‡æ¢ profile
    attrPath := "/proc/self/attr/exec"
    
    // å°è¯•æ–°ç‰ˆè·¯å¾„
    if _, err := os.Stat("/proc/self/attr/apparmor/exec"); err == nil {
        attrPath = "/proc/self/attr/apparmor/exec"
    }
    
    file, err := os.OpenFile(attrPath, os.O_WRONLY, 0)
    if err != nil {
        return fmt.Errorf("failed to open AppArmor exec attr: %w", err)
    }
    defer file.Close()
    
    // å†™å…¥ profile åç§°ï¼Œæ ¼å¼ä¸º "exec profilename"
    profileSpec := "exec " + name
    if _, err := file.WriteString(profileSpec); err != nil {
        return fmt.Errorf("failed to set AppArmor profile %s: %w", name, err)
    }
    
    return nil
}
```

#### å®¹å™¨ AppArmor Profile ç¤ºä¾‹

```bash
# /etc/apparmor.d/docker-default
#include <tunables/global>

profile docker-default flags=(attach_disconnected,mediate_deleted) {
  # ç½‘ç»œè®¿é—®
  network inet tcp,
  network inet udp,
  network inet icmp,
  
  # æ–‡ä»¶ç³»ç»Ÿè®¿é—®
  file,
  / r,
  /etc/ r,
  /etc/** r,
  /lib/ r,
  /lib/** r,
  /usr/ r,
  /usr/** r,
  
  # ç¦æ­¢è®¿é—®æ•æ„Ÿè·¯å¾„
  deny /sys/firmware/efi/efivars/ wl,
  deny /sys/kernel/security/ wl,
  deny /proc/sys/kernel/core_pattern wl,
  deny /proc/kcore r,
  deny /proc/kallsyms r,
  
  # å…è®¸çš„ç³»ç»Ÿè°ƒç”¨
  capability chown,
  capability dac_override,
  capability setuid,
  capability setgid,
  capability net_bind_service,
  
  # ç¦æ­¢çš„å±é™©æ“ä½œ
  deny capability sys_admin,
  deny capability sys_time,
  deny capability sys_module,
}
```

### 4.3 SELinux é›†æˆ

#### æ ‡ç­¾è®¾ç½®

```go
// SELinux æ ‡ç­¾åº”ç”¨
func ApplySELinuxLabels(config *configs.Config) error {
    if !selinux.GetEnabled() {
        return nil
    }
    
    // è®¾ç½®è¿›ç¨‹æ‰§è¡Œæ ‡ç­¾
    if config.ProcessLabel != "" {
        if err := selinux.SetExecLabel(config.ProcessLabel); err != nil {
            return fmt.Errorf("failed to set SELinux exec label: %w", err)
        }
    }
    
    // è®¾ç½®å¯†é’¥ç¯æ ‡ç­¾
    if config.ProcessLabel != "" {
        if err := selinux.SetKeyLabel(config.ProcessLabel); err != nil {
            return fmt.Errorf("failed to set SELinux key label: %w", err)
        }
    }
    
    return nil
}
```

#### æŒ‚è½½æ ‡ç­¾å¤„ç†

```go
// æ–‡ä»¶ç³»ç»ŸæŒ‚è½½æ—¶åº”ç”¨ SELinux æ ‡ç­¾
func formatMountLabel(src, mountLabel string) string {
    if mountLabel == "" {
        return ""
    }
    
    // æ ¼å¼åŒ–æŒ‚è½½æ ‡ç­¾
    switch {
    case strings.Contains(mountLabel, "context="):
        return mountLabel
    default:
        return fmt.Sprintf("context=%s", mountLabel)
    }
}
```

#### SELinux ç­–ç•¥ç¤ºä¾‹

```bash
# container.te - å®¹å™¨ SELinux ç­–ç•¥ç¤ºä¾‹
policy_module(container, 1.0.0)

# å®¹å™¨åŸŸå®šä¹‰
type container_t;
type container_exec_t;
domain_type(container_t)
domain_entry_file(container_t, container_exec_t)

# å®¹å™¨æ–‡ä»¶ç±»å‹
type container_file_t;
files_type(container_file_t)

# å…è®¸å®¹å™¨åŸŸçš„åŸºæœ¬æ“ä½œ
allow container_t self:process { fork signal_perms };
allow container_t self:fifo_file rw_fifo_file_perms;
allow container_t self:unix_stream_socket create_stream_socket_perms;

# å…è®¸è®¿é—®å®¹å™¨æ–‡ä»¶
allow container_t container_file_t:dir list_dir_perms;
allow container_t container_file_t:file read_file_perms;

# ç¦æ­¢è®¿é—®æ•æ„Ÿèµ„æº
neverallow container_t kernel_t:system module_load;
neverallow container_t sysctl_t:file write;
neverallow container_t device_t:chr_file write;
```

## 5. ç”¨æˆ·å‘½åç©ºé—´æƒé™æ˜ å°„

### 5.1 ID æ˜ å°„æœºåˆ¶

ç”¨æˆ·å‘½åç©ºé—´å…è®¸å®¹å™¨å†…çš„ UID/GID æ˜ å°„åˆ°å®¿ä¸»æœºçš„ä¸åŒ UID/GIDï¼š

```
å®¹å™¨å†…è§†å›¾:        æ˜ å°„å…³ç³»:           å®¿ä¸»æœºè§†å›¾:
UID 0 (root)  â†â”€â†’  UID 1000 (user)    UID 1000 (æ™®é€šç”¨æˆ·)
UID 1         â†â”€â†’  UID 1001           UID 1001
UID 2         â†â”€â†’  UID 1002           UID 1002
...           â†â”€â†’  ...                ...
UID 65535     â†â”€â†’  UID 66535          UID 66535

æ˜ å°„é…ç½®:
å®¹å™¨ID: 0,  å®¿ä¸»ID: 1000, èŒƒå›´: 65536
```

### 5.2 ID æ˜ å°„é…ç½®

```go
// libcontainer/configs/config.go:85
type IDMap struct {
    ContainerID int64 `json:"container_id"`  // å®¹å™¨å†…èµ·å§‹ ID
    HostID      int64 `json:"host_id"`       // å®¿ä¸»æœºèµ·å§‹ ID  
    Size        int64 `json:"size"`          // æ˜ å°„èŒƒå›´å¤§å°
}

// ç”¨æˆ·æ˜ å°„è·å–
func GetUserNamespaceMappings(nsPath string) ([]IDMap, []IDMap, error) {
    // å¿«é€Ÿè·¯å¾„ï¼šç›´æ¥è¯»å–æ˜ å°„æ–‡ä»¶
    uidMaps, err := readMappingFile(nsPath, "uid_map")
    if err == nil {
        gidMaps, err := readMappingFile(nsPath, "gid_map")
        return uidMaps, gidMaps, err
    }
    
    // æ…¢é€Ÿè·¯å¾„ï¼šä½¿ç”¨ C ä»£ç åœ¨ç”¨æˆ·å‘½åç©ºé—´å†…è¯»å–
    return readMappingsWithC(nsPath)
}
```

### 5.3 æ˜ å°„æ–‡ä»¶è¯»å–

```go
// libcontainer/internal/userns/userns_maps_linux.go:89
func readMappingFile(nsPath, mapType string) ([]IDMap, error) {
    mapPath := filepath.Join("/proc", extractPid(nsPath), mapType)
    
    data, err := os.ReadFile(mapPath)
    if err != nil {
        return nil, err
    }
    
    var mappings []IDMap
    for _, line := range strings.Split(string(data), "\n") {
        line = strings.TrimSpace(line)
        if line == "" {
            continue
        }
        
        // è§£ææ ¼å¼: "å®¹å™¨ID å®¿ä¸»ID èŒƒå›´å¤§å°"
        parts := strings.Fields(line)
        if len(parts) != 3 {
            continue
        }
        
        containerID, _ := strconv.ParseInt(parts[0], 10, 64)
        hostID, _ := strconv.ParseInt(parts[1], 10, 64)
        size, _ := strconv.ParseInt(parts[2], 10, 64)
        
        mappings = append(mappings, IDMap{
            ContainerID: containerID,
            HostID:      hostID,
            Size:        size,
        })
    }
    
    return mappings, nil
}
```

### 5.4 C ä»£ç æ˜ å°„è¯»å–

```c
// libcontainer/internal/userns/userns_maps_linux.c:45
int spawn_userns_cat(const char *file, const char *ns_path, int output_fd) {
    int ns_fd = -1;
    int file_fd = -1;
    
    // æ‰“å¼€ç”¨æˆ·å‘½åç©ºé—´æ–‡ä»¶æè¿°ç¬¦
    ns_fd = open(ns_path, O_RDONLY | O_CLOEXEC);
    if (ns_fd < 0) {
        goto error;
    }
    
    // fork å­è¿›ç¨‹
    pid_t child = fork();
    if (child == 0) {
        // å­è¿›ç¨‹ï¼šè¿›å…¥ç”¨æˆ·å‘½åç©ºé—´
        if (setns(ns_fd, CLONE_NEWUSER) < 0) {
            goto error;
        }
        
        // åœ¨ç”¨æˆ·å‘½åç©ºé—´å†…æ‰“å¼€æ˜ å°„æ–‡ä»¶
        file_fd = open(file, O_RDONLY | O_CLOEXEC);
        if (file_fd < 0) {
            goto error;
        }
        
        // å¤åˆ¶æ–‡ä»¶å†…å®¹åˆ°è¾“å‡ºç®¡é“
        char buffer[4096];
        ssize_t bytes;
        while ((bytes = read(file_fd, buffer, sizeof(buffer))) > 0) {
            if (write(output_fd, buffer, bytes) != bytes) {
                goto error;
            }
        }
        
        close(file_fd);
        close(ns_fd);
        _exit(0);
        
    error:
        if (file_fd >= 0) close(file_fd);
        if (ns_fd >= 0) close(ns_fd);
        _exit(1);
    } else if (child > 0) {
        // çˆ¶è¿›ç¨‹ï¼šç­‰å¾…å­è¿›ç¨‹å®Œæˆ
        int status;
        while (waitpid(child, &status, 0) != child) {
            if (errno != EINTR) {
                break;
            }
        }
        return WEXITSTATUS(status);
    }
    
    return 1;  // fork å¤±è´¥
}
```

### 5.5 Rootless å®¹å™¨å®‰å…¨æ¨¡å‹

Rootless å®¹å™¨ä½¿ç”¨ç”¨æˆ·å‘½åç©ºé—´å®ç°æ— ç‰¹æƒè¿è¡Œï¼š

```bash
# rootless å®¹å™¨çš„å…¸å‹æ˜ å°„é…ç½®
$ cat /proc/self/uid_map
         0       1000          1      # å®¹å™¨root â†’ å®¿ä¸»æ™®é€šç”¨æˆ·
         1     100000      65536      # å…¶ä»–ID â†’ å­IDèŒƒå›´

$ cat /proc/self/gid_map  
         0       1000          1      # å®¹å™¨rootç»„ â†’ å®¿ä¸»æ™®é€šç»„
         1     100000      65536      # å…¶ä»–ç»„ â†’ å­ç»„èŒƒå›´

# æ£€æŸ¥å­IDé…ç½®
$ cat /etc/subuid
user:100000:65536

$ cat /etc/subgid  
user:100000:65536
```

**Rootless å®‰å…¨ä¼˜åŠ¿**ï¼š
- ğŸš« **æ— éœ€ç‰¹æƒ**: ä¸éœ€è¦ root æƒé™å¯åŠ¨å®¹å™¨
- ğŸ”’ **æƒé™éš”ç¦»**: å®¹å™¨å†… root æƒé™è¢«é™åˆ¶åœ¨ç”¨æˆ·å‘½åç©ºé—´å†…
- ğŸ›¡ï¸ **æ”»å‡»é¢ç¼©å°**: å‡å°‘äº†ç‰¹æƒå‡çº§çš„æ”»å‡»é¢

## 6. å®‰å…¨ç­–ç•¥é…ç½®å’Œåº”ç”¨

### 6.1 å®‰å…¨é…ç½®éªŒè¯

```go
// libcontainer/configs/validate/security.go:15
func security(config *configs.Config) error {
    // æ£€æŸ¥ MaskPaths/ReadonlyPaths éœ€è¦ç§æœ‰ mount namespace
    if (len(config.MaskPaths) > 0 || len(config.ReadonlyPaths) > 0) &&
        !config.Namespaces.Contains(configs.NEWNS) {
        return errors.New("cannot restrict paths without private mount namespace")
    }
    
    // æ£€æŸ¥ SELinux é…ç½®
    if config.ProcessLabel != "" && !selinux.GetEnabled() {
        return errors.New("SELinux label specified but SELinux disabled")
    }
    
    // æ£€æŸ¥ AppArmor é…ç½®
    if config.AppArmorProfile != "" && !apparmor.IsEnabled() {
        return errors.New("AppArmor profile specified but AppArmor disabled")
    }
    
    // æ£€æŸ¥ seccomp é…ç½®
    if config.Seccomp != nil {
        if err := validateSeccompConfig(config.Seccomp); err != nil {
            return fmt.Errorf("invalid seccomp config: %w", err)
        }
    }
    
    return nil
}
```

### 6.2 å®‰å…¨ç­–ç•¥åº”ç”¨æµç¨‹

```go
// libcontainer/standard_init_linux.go:200
func finalizeNamespace(config *initConfig) error {
    // 1. åº”ç”¨ AppArmor profile
    if err := apparmor.ApplyProfile(config.AppArmorProfile); err != nil {
        return fmt.Errorf("failed to apply AppArmor profile: %w", err)
    }
    
    // 2. è®¾ç½® SELinux æ ‡ç­¾
    if err := selinux.SetExecLabel(config.ProcessLabel); err != nil {
        return fmt.Errorf("failed to set SELinux label: %w", err)
    }
    
    // 3. åº”ç”¨æ–‡ä»¶ç³»ç»Ÿé™åˆ¶
    if err := applyPathRestrictions(config); err != nil {
        return fmt.Errorf("failed to apply path restrictions: %w", err)
    }
    
    // 4. è®¾ç½® no_new_privs ä½
    if config.NoNewPrivileges {
        if err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {
            return fmt.Errorf("failed to set no_new_privs: %w", err)
        }
    }
    
    // 5. åº”ç”¨ Linux capabilities
    if err := capabilities.ApplyCapabilities(config.Capabilities); err != nil {
        return fmt.Errorf("failed to apply capabilities: %w", err)
    }
    
    // 6. åˆå§‹åŒ– seccomp è¿‡æ»¤å™¨
    if config.Seccomp != nil {
        if err := seccomp.InitSeccomp(config.Seccomp); err != nil {
            return fmt.Errorf("failed to initialize seccomp: %w", err)
        }
    }
    
    return nil
}
```

### 6.3 è·¯å¾„é™åˆ¶å®ç°

```go
// åº”ç”¨æ•æ„Ÿè·¯å¾„çš„è®¿é—®é™åˆ¶
func applyPathRestrictions(config *initConfig) error {
    // å±è”½æ•æ„Ÿè·¯å¾„ (ç”¨ tmpfs è¦†ç›–)
    for _, path := range config.Config.MaskPaths {
        if err := maskPath(path, config.Config.Readonlyfs); err != nil {
            return err
        }
    }
    
    // è®¾ç½®åªè¯»è·¯å¾„
    for _, path := range config.Config.ReadonlyPaths {
        if err := readonlyPath(path); err != nil {
            return err
        }
    }
    
    return nil
}

func maskPath(path string, readonly bool) error {
    // ä½¿ç”¨ tmpfs æŒ‚è½½æ¥å±è”½æ•æ„Ÿè·¯å¾„
    flags := unix.MS_RDONLY
    if !readonly {
        flags = 0
    }
    
    if err := mount("tmpfs", path, "tmpfs", 
                   uintptr(flags), ""); err != nil {
        // å¦‚æœæŒ‚è½½å¤±è´¥ï¼Œå°è¯•åˆ›å»ºç©ºæ–‡ä»¶è¦†ç›–
        if os.IsNotExist(err) {
            return createEmptyFile(path)
        }
        return err
    }
    
    return nil
}

func readonlyPath(path string) error {
    // ç»‘å®šæŒ‚è½½åé‡æ–°æŒ‚è½½ä¸ºåªè¯»
    if err := mount(path, path, "", unix.MS_BIND, ""); err != nil {
        if os.IsNotExist(err) {
            return nil  // è·¯å¾„ä¸å­˜åœ¨ï¼Œå¿½ç•¥
        }
        return err
    }
    
    return mount(path, path, "", 
                unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, "")
}
```

## 7. å®è·µç»ƒä¹ 

### 7.1 Capabilities å®éªŒ

```bash
#!/bin/bash
# å®éªŒ 1: ç†è§£ capabilities çš„ä½œç”¨

# æ£€æŸ¥å½“å‰è¿›ç¨‹çš„ capabilities
echo "=== Current Process Capabilities ==="
cat /proc/self/status | grep Cap

# ä½¿ç”¨ capsh åˆ†æ capabilities
capsh --decode=0x00000000a80425fb
capsh --print

# æµ‹è¯•ç½‘ç»œæƒé™
echo "=== Testing Network Capabilities ==="

# åˆ›å»ºä¸€ä¸ªæ²¡æœ‰ CAP_NET_ADMIN çš„è¿›ç¨‹
capsh --drop=cap_net_admin --print &
PID=$!
sleep 1

# å°è¯•ä¿®æ”¹ç½‘ç»œé…ç½® (åº”è¯¥å¤±è´¥)
nsenter -t $PID -n ip link set lo down 2>&1 || echo "Permission denied (expected)"

# åˆ›å»ºæœ‰ CAP_NET_BIND_SERVICE çš„è¿›ç¨‹æµ‹è¯•ç‰¹æƒç«¯å£
python3 -c "
import socket
try:
    s = socket.socket()
    s.bind(('', 80))  # ç‰¹æƒç«¯å£
    print('Successfully bound to port 80')
    s.close()
except PermissionError:
    print('Cannot bind to privileged port (expected without CAP_NET_BIND_SERVICE)')
"
```

### 7.2 seccomp è¿‡æ»¤å®éªŒ

```go
// å®éªŒ 2: seccomp ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤
package main

import (
    "fmt"
    "os"
    "syscall"
    "unsafe"
    
    "golang.org/x/sys/unix"
    "github.com/seccomp/libseccomp-golang"
)

func main() {
    // åˆ›å»º seccomp è¿‡æ»¤å™¨
    filter, err := seccomp.NewFilter(seccomp.ActAllow)
    if err != nil {
        panic(err)
    }
    defer filter.Release()
    
    // ç¦æ­¢ mkdir ç³»ç»Ÿè°ƒç”¨
    if err := filter.AddRule(seccomp.ScmpSyscall(unix.SYS_MKDIR), 
                            seccomp.ActErrno.SetReturnCode(int16(syscall.EPERM))); err != nil {
        panic(err)
    }
    
    // åŠ è½½è¿‡æ»¤å™¨
    if err := filter.Load(); err != nil {
        panic(err)
    }
    
    fmt.Println("seccomp filter loaded")
    
    // æµ‹è¯•è¢«ç¦æ­¢çš„ç³»ç»Ÿè°ƒç”¨
    if err := os.Mkdir("/tmp/test-mkdir", 0755); err != nil {
        fmt.Printf("mkdir failed as expected: %v\n", err)
    } else {
        fmt.Println("ERROR: mkdir should have been blocked!")
    }
    
    // æµ‹è¯•å…è®¸çš„ç³»ç»Ÿè°ƒç”¨
    if file, err := os.Create("/tmp/test-create"); err == nil {
        fmt.Println("file creation allowed")
        file.Close()
        os.Remove("/tmp/test-create")
    }
}
```

### 7.3 AppArmor Profile æµ‹è¯•

```bash
#!/bin/bash
# å®éªŒ 3: AppArmor profile çº¦æŸæµ‹è¯•

# æ£€æŸ¥ AppArmor çŠ¶æ€
sudo aa-status

# åˆ›å»ºæµ‹è¯• profile
sudo tee /etc/apparmor.d/test-container > /dev/null << 'EOF'
#include <tunables/global>

profile test-container flags=(attach_disconnected) {
  #include <abstractions/base>
  
  # å…è®¸åŸºæœ¬æ–‡ä»¶è®¿é—®
  / r,
  /bin/** ix,
  /lib/** ix,
  /usr/bin/** ix,
  /tmp/** rw,
  
  # ç¦æ­¢è®¿é—®æ•æ„Ÿæ–‡ä»¶
  deny /etc/shadow r,
  deny /proc/*/mem r,
  deny /sys/kernel/security/** rw,
  
  # å…è®¸ç½‘ç»œ
  network inet tcp,
  network inet udp,
  
  # ç¦æ­¢æŸäº› capabilities
  deny capability sys_admin,
  deny capability sys_time,
}
EOF

# åŠ è½½ profile
sudo apparmor_parser -r /etc/apparmor.d/test-container

# æµ‹è¯• profile çº¦æŸ
echo "=== Testing AppArmor Profile Constraints ==="

# åœ¨ profile çº¦æŸä¸‹è¿è¡Œå‘½ä»¤
sudo aa-exec -p test-container /bin/bash -c '
echo "Running under AppArmor profile: $(cat /proc/self/attr/current)"

# å…è®¸çš„æ“ä½œ
echo "test" > /tmp/allowed.txt
cat /tmp/allowed.txt

# è¢«ç¦æ­¢çš„æ“ä½œ
echo "Trying to read /etc/shadow:"
cat /etc/shadow 2>&1 || echo "Access denied (expected)"

echo "Trying to read /proc/1/mem:"
head -c 10 /proc/1/mem 2>&1 || echo "Access denied (expected)"
'

# æ¸…ç†
sudo rm /tmp/allowed.txt
sudo apparmor_parser -R /etc/apparmor.d/test-container
sudo rm /etc/apparmor.d/test-container
```

### 7.4 ç”¨æˆ·å‘½åç©ºé—´æ˜ å°„å®éªŒ

```bash
#!/bin/bash
# å®éªŒ 4: ç”¨æˆ·å‘½åç©ºé—´æƒé™æ˜ å°„

echo "=== User Namespace ID Mapping Test ==="

# æ£€æŸ¥å½“å‰ UID/GID
echo "Current UID/GID outside namespace: $(id)"

# åˆ›å»ºç”¨æˆ·å‘½åç©ºé—´å¹¶è®¾ç½®æ˜ å°„
unshare --user --map-root-user /bin/bash -c '
echo "=== Inside User Namespace ==="
echo "UID/GID inside namespace: $(id)"
echo

# æ£€æŸ¥æ˜ å°„æ–‡ä»¶
echo "UID mapping:"
cat /proc/self/uid_map

echo "GID mapping:"  
cat /proc/self/gid_map

# æµ‹è¯•æ–‡ä»¶æƒé™
echo "=== File Permission Test ==="
echo "Creating file as root inside namespace..."
touch /tmp/userns-test-file
ls -la /tmp/userns-test-file

echo "File ownership as seen from namespace:"
stat -c "UID: %u, GID: %g" /tmp/userns-test-file
'

echo
echo "=== Outside Namespace View ==="
echo "File ownership as seen from host:"
stat -c "UID: %u, GID: %g" /tmp/userns-test-file 2>/dev/null || echo "File not accessible"

# æ¸…ç†
rm -f /tmp/userns-test-file
```

## 8. å®‰å…¨æœ€ä½³å®è·µ

### 8.1 å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•

```bash
#!/bin/bash
# å®¹å™¨å®‰å…¨é…ç½®æ£€æŸ¥è„šæœ¬

check_security_config() {
    local config_file="$1"
    
    echo "=== Container Security Configuration Audit ==="
    
    # æ£€æŸ¥ capabilities
    echo "1. Checking Capabilities:"
    if grep -q '"bounding".*"CAP_SYS_ADMIN"' "$config_file"; then
        echo "  âš ï¸  WARNING: CAP_SYS_ADMIN granted (high risk)"
    else
        echo "  âœ… CAP_SYS_ADMIN not granted"
    fi
    
    if grep -q '"bounding".*"CAP_SYS_MODULE"' "$config_file"; then
        echo "  âŒ CRITICAL: CAP_SYS_MODULE granted (kernel module loading)"
    else
        echo "  âœ… CAP_SYS_MODULE not granted"
    fi
    
    # æ£€æŸ¥ seccomp
    echo "2. Checking seccomp:"
    if grep -q '"defaultAction":"SCMP_ACT_ALLOW"' "$config_file"; then
        echo "  âš ï¸  WARNING: Default seccomp action is ALLOW"
    else
        echo "  âœ… Restrictive seccomp policy"
    fi
    
    # æ£€æŸ¥åªè¯»æ ¹æ–‡ä»¶ç³»ç»Ÿ
    echo "3. Checking root filesystem:"
    if grep -q '"readonly":true' "$config_file"; then
        echo "  âœ… Root filesystem is read-only"
    else
        echo "  âš ï¸  WARNING: Root filesystem is writable"
    fi
    
    # æ£€æŸ¥ç‰¹æƒæ¨¡å¼
    echo "4. Checking privileged mode:"
    if grep -q '"privileged":true' "$config_file"; then
        echo "  âŒ CRITICAL: Container running in privileged mode"
    else
        echo "  âœ… Container not privileged"
    fi
    
    # æ£€æŸ¥ç”¨æˆ·å‘½åç©ºé—´
    echo "5. Checking user namespace:"
    if grep -q '"type":"user"' "$config_file"; then
        echo "  âœ… User namespace enabled"
    else
        echo "  âš ï¸  WARNING: User namespace not enabled"
    fi
}

# ä½¿ç”¨ç¤ºä¾‹
# check_security_config config.json
```

### 8.2 å®‰å…¨ç­–ç•¥æ¨¡æ¿

```json
{
  "ociVersion": "1.0.2",
  "process": {
    "user": {
      "uid": 1000,
      "gid": 1000
    },
    "args": ["/app/server"],
    "capabilities": {
      "bounding": [
        "CAP_CHOWN",
        "CAP_SETGID", 
        "CAP_SETUID",
        "CAP_NET_BIND_SERVICE"
      ],
      "effective": [
        "CAP_CHOWN",
        "CAP_SETGID",
        "CAP_SETUID", 
        "CAP_NET_BIND_SERVICE"
      ],
      "permitted": [
        "CAP_CHOWN",
        "CAP_SETGID",
        "CAP_SETUID",
        "CAP_NET_BIND_SERVICE"
      ]
    },
    "noNewPrivileges": true
  },
  "root": {
    "path": "rootfs",
    "readonly": true
  },
  "linux": {
    "namespaces": [
      {"type": "pid"},
      {"type": "network"},
      {"type": "mount"},
      {"type": "user"},
      {"type": "uts"},
      {"type": "ipc"}
    ],
    "uidMappings": [
      {
        "containerID": 0,
        "hostID": 1000,
        "size": 1
      }
    ],
    "gidMappings": [
      {
        "containerID": 0,
        "hostID": 1000, 
        "size": 1
      }
    ],
    "seccomp": {
      "defaultAction": "SCMP_ACT_ERRNO",
      "architectures": ["SCMP_ARCH_X86_64"],
      "syscalls": [
        {
          "names": [
            "read", "write", "open", "close",
            "stat", "fstat", "lstat", "poll",
            "lseek", "mmap", "mprotect", "munmap",
            "brk", "rt_sigaction", "rt_sigprocmask",
            "access", "pipe", "select", "sched_yield",
            "mremap", "msync", "mincore", "madvise",
            "dup", "dup2", "pause", "nanosleep",
            "getitimer", "alarm", "setitimer", "getpid",
            "sendfile", "socket", "connect", "accept",
            "sendto", "recvfrom", "sendmsg", "recvmsg",
            "shutdown", "bind", "listen", "getsockname",
            "getpeername", "socketpair", "setsockopt", "getsockopt",
            "clone", "fork", "vfork", "execve",
            "exit", "wait4", "kill", "uname",
            "fcntl", "flock", "fsync", "fdatasync",
            "truncate", "ftruncate", "getdents", "getcwd",
            "chdir", "fchdir", "rename", "mkdir",
            "rmdir", "creat", "link", "unlink",
            "symlink", "readlink", "chmod", "fchmod",
            "chown", "fchown", "lchown", "umask"
          ],
          "action": "SCMP_ACT_ALLOW"
        }
      ]
    },
    "maskedPaths": [
      "/proc/acpi",
      "/proc/asound", 
      "/proc/kcore",
      "/proc/keys",
      "/proc/latency_stats",
      "/proc/timer_list",
      "/proc/timer_stats",
      "/proc/sched_debug",
      "/sys/firmware",
      "/sys/fs/cgroup"
    ],
    "readonlyPaths": [
      "/proc/bus",
      "/proc/fs", 
      "/proc/irq",
      "/proc/sys",
      "/proc/sysrq-trigger"
    ]
  }
}
```

### 8.3 å®‰å…¨ç›‘æ§å’Œå®¡è®¡

```go
// å®‰å…¨äº‹ä»¶ç›‘æ§ç¤ºä¾‹
package main

import (
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"
)

type SecurityMonitor struct {
    events chan SecurityEvent
}

type SecurityEvent struct {
    Type      string
    Message   string
    Timestamp time.Time
    Severity  string
}

func (sm *SecurityMonitor) Start() {
    go sm.monitorCapabilities()
    go sm.monitorSeccomp()
    go sm.monitorAppArmor()
    go sm.logEvents()
}

func (sm *SecurityMonitor) monitorCapabilities() {
    // ç›‘æ§ capabilities å˜åŒ–
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        // æ£€æŸ¥å½“å‰è¿›ç¨‹çš„ capabilities
        caps, err := getCurrentCapabilities()
        if err != nil {
            continue
        }
        
        if containsDangerousCapabilities(caps) {
            sm.events <- SecurityEvent{
                Type:      "capability",
                Message:   "Dangerous capabilities detected",
                Timestamp: time.Now(),
                Severity:  "HIGH",
            }
        }
    }
}

func (sm *SecurityMonitor) monitorSeccomp() {
    // ç›‘æ§ seccomp è¿è§„
    // é€šè¿‡è§£æ /proc/self/status æ£€æŸ¥ seccomp çŠ¶æ€
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if !isSeccompActive() {
            sm.events <- SecurityEvent{
                Type:      "seccomp", 
                Message:   "seccomp filter not active",
                Timestamp: time.Now(),
                Severity:  "MEDIUM",
            }
        }
    }
}

func (sm *SecurityMonitor) logEvents() {
    for event := range sm.events {
        log.Printf("[%s] %s: %s (%s)", 
                  event.Severity, event.Type, event.Message, 
                  event.Timestamp.Format(time.RFC3339))
    }
}

func main() {
    monitor := &SecurityMonitor{
        events: make(chan SecurityEvent, 100),
    }
    
    monitor.Start()
    
    // ç­‰å¾…é€€å‡ºä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    <-sigChan
    
    log.Println("Security monitor shutting down")
}
```

## 9. æ€è€ƒé¢˜

### 9.1 å®‰å…¨æ¨¡å‹æ€è€ƒ

1. **å¤šå±‚é˜²æŠ¤**: ä¸ºä»€ä¹ˆéœ€è¦ capabilities + seccomp + MAC çš„å¤šå±‚å®‰å…¨æœºåˆ¶ï¼Ÿå•ä¸€æœºåˆ¶çš„å±€é™æ€§æ˜¯ä»€ä¹ˆï¼Ÿ

2. **æƒé™æœ€å°åŒ–**: å¦‚ä½•å¹³è¡¡å®‰å…¨æ€§å’ŒåŠŸèƒ½æ€§ï¼Ÿè¿‡åº¦é™åˆ¶æƒé™å¯èƒ½å¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿ

3. **å®‰å…¨ç­–ç•¥**: å¦‚ä½•ä¸ºä¸åŒç±»å‹çš„åº”ç”¨ï¼ˆWebæœåŠ¡ã€æ•°æ®åº“ã€æ‰¹å¤„ç†ä»»åŠ¡ï¼‰è®¾è®¡åˆé€‚çš„å®‰å…¨ç­–ç•¥ï¼Ÿ

### 9.2 å®ç°ç»†èŠ‚æ€è€ƒ

4. **Capabilitiesç»§æ‰¿**: ambient capabilities è§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿä¸ºä»€ä¹ˆéœ€è¦è¿™ç§å¤æ‚çš„ç»§æ‰¿æ¨¡å‹ï¼Ÿ

5. **seccompæ€§èƒ½**: BPFè¿‡æ»¤å™¨å¯¹ç³»ç»Ÿè°ƒç”¨æ€§èƒ½çš„å½±å“å¦‚ä½•ï¼Ÿæœ‰ä»€ä¹ˆä¼˜åŒ–ç­–ç•¥ï¼Ÿ

6. **ç”¨æˆ·æ˜ å°„**: åœ¨å¤§è§„æ¨¡å®¹å™¨ç¯å¢ƒä¸­ï¼Œå¦‚ä½•æœ‰æ•ˆç®¡ç†ç”¨æˆ·IDæ˜ å°„ï¼Ÿsubuid/subgid çš„åˆ†é…ç­–ç•¥ï¼Ÿ

### 9.3 å®‰å…¨æŒ‘æˆ˜æ€è€ƒ

7. **å®¹å™¨é€ƒé€¸**: å½“å‰çš„å®‰å…¨æœºåˆ¶èƒ½é˜²æŠ¤å“ªäº›ç±»å‹çš„å®¹å™¨é€ƒé€¸ï¼Ÿè¿˜æœ‰ä»€ä¹ˆæ½œåœ¨æ¼æ´ï¼Ÿ

8. **å…¼å®¹æ€§é—®é¢˜**: ä¸¥æ ¼çš„å®‰å…¨ç­–ç•¥å¯èƒ½å½±å“åº”ç”¨å…¼å®¹æ€§ï¼Œå¦‚ä½•å¤„ç†è¿™ç§å†²çªï¼Ÿ

9. **ç›‘æ§å®¡è®¡**: å¦‚ä½•æœ‰æ•ˆç›‘æ§å’Œå®¡è®¡å®¹å™¨çš„å®‰å…¨è¡Œä¸ºï¼Ÿä»€ä¹ˆæ ·çš„è¡Œä¸ºåº”è¯¥è¢«æ ‡è®°ä¸ºå¯ç–‘ï¼Ÿ

## 10. æ‰©å±•é˜…è¯»

### 10.1 Linux å®‰å…¨æœºåˆ¶

- [Linux Capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html)
- [seccomp(2)](https://man7.org/linux/man-pages/man2/seccomp.2.html) 
- [AppArmor Documentation](https://gitlab.com/apparmor/apparmor/-/wikis/Documentation)
- [SELinux User's Guide](https://selinuxproject.org/page/User/UserGuide)

### 10.2 å®¹å™¨å®‰å…¨æœ€ä½³å®è·µ

- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)
- [NIST Container Security Guide](https://csrc.nist.gov/publications/detail/sp/800-190/final)
- [Container Security by Liz Rice](https://info.aquasec.com/container-security-book)

### 10.3 å®‰å…¨ç ”ç©¶å’Œå·¥å…·

- [Container Security Tools](https://github.com/freach/container-security-awesome)
- [Falco Runtime Security](https://falco.org/)
- [OPA Gatekeeper](https://open-policy-agent.github.io/gatekeeper/)

## ğŸ¯ æ¨¡å—æ€»ç»“

é€šè¿‡æœ¬æ¨¡å—çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

âœ… **å¤šå±‚å®‰å…¨æ¶æ„**ï¼šç†è§£å®¹å™¨å®‰å…¨çš„å¨èƒæ¨¡å‹å’Œé˜²æŠ¤ä½“ç³»  
âœ… **Capabilities æƒé™æ§åˆ¶**ï¼šæŒæ¡ç»†ç²’åº¦æƒé™ç®¡ç†å’Œåº”ç”¨ç­–ç•¥  
âœ… **seccomp ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤**ï¼šç†è§£BPFè¿‡æ»¤å™¨å’Œç­–ç•¥é…ç½®  
âœ… **å¼ºåˆ¶è®¿é—®æ§åˆ¶**ï¼šç†Ÿæ‚‰AppArmor/SELinuxçš„é›†æˆå’Œåº”ç”¨  
âœ… **ç”¨æˆ·æƒé™æ˜ å°„**ï¼šæŒæ¡ç”¨æˆ·å‘½åç©ºé—´çš„å®‰å…¨æ¨¡å‹  
âœ… **å®‰å…¨ç­–ç•¥è®¾è®¡**ï¼šå…·å¤‡è®¾è®¡å’Œå®æ–½å®¹å™¨å®‰å…¨ç­–ç•¥çš„èƒ½åŠ›  

**ä¸‹ä¸€æ­¥**: è¿›å…¥é«˜çº§ç‰¹æ€§æ¨¡å—ï¼Œå­¦ä¹  CRIUã€ç›‘æ§ã€æ„å»ºè‡ªå®šä¹‰å®¹å™¨è¿è¡Œæ—¶ç­‰ä¸»é¢˜ã€‚