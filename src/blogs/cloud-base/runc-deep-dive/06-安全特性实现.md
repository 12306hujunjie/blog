# 安全特性实现

> **系列导航：** [runc 容器运行时深度解析系列](./README.md) → 第六篇：安全特性实现  
> **上一篇：** [文件系统与挂载管理](./05-文件系统与挂载管理.md)  
> **最后更新：** 2024

## 概述

本文深入分析 runc 的安全特性实现，包括 Capabilities、Seccomp、AppArmor/SELinux 等多层安全防护机制。这些安全特性保障了容器的隔离性和安全性。

## 🎯 学习目标

完成本模块后，你将能够：
- 深入理解容器安全的多层防护体系和攻击面
- 掌握 Linux Capabilities 的细粒度权限控制机制
- 理解 seccomp 系统调用过滤的实现原理和配置方法
- 熟悉 AppArmor/SELinux 强制访问控制的集成方式
- 掌握用户命名空间权限映射的安全模型
- 具备设计和实施容器安全策略的实践能力

## 1. 容器安全威胁模型

### 1.1 容器安全边界

容器安全需要在多个层面建立防护边界：

```
┌─────────────────────────────────────────────────┐
│                应用层                           │ ← 应用漏洞、恶意代码
├─────────────────────────────────────────────────┤
│              容器运行时层                       │ ← 容器逃逸、权限提升
│  ┌─────────────────────────────────────────┐    │
│  │           runc 安全机制             │    │
│  │ ┌─────────────┬─────────────────────┐ │    │
│  │ │ Capabilities│    seccomp         │ │    │
│  │ └─────────────┴─────────────────────┘ │    │
│  │ ┌─────────────┬─────────────────────┐ │    │
│  │ │ AppArmor/   │  User Namespaces   │ │    │
│  │ │ SELinux     │                    │ │    │
│  │ └─────────────┴─────────────────────┘ │    │
│  └─────────────────────────────────────────┘    │
├─────────────────────────────────────────────────┤
│                Linux 内核层                     │ ← 内核漏洞、驱动问题
├─────────────────────────────────────────────────┤
│                硬件层                           │ ← 硬件漏洞、侧信道攻击
└─────────────────────────────────────────────────┘
```

### 1.2 主要攻击向量

| 攻击类型 | 描述 | runc 防护机制 |
|----------|------|--------------|
| **容器逃逸** | 突破容器边界访问宿主机 | Namespaces + Capabilities + seccomp |
| **权限提升** | 获得超出预期的权限 | User Namespaces + Capabilities |
| **资源耗尽** | DOS攻击耗尽系统资源 | Cgroups + rlimits |
| **信息泄露** | 访问不应访问的信息 | /proc检查 + 文件系统隔离 |
| **系统调用滥用** | 利用危险系统调用 | seccomp 过滤 |
| **横向移动** | 攻击其他容器或服务 | 网络隔离 + SELinux/AppArmor |

### 1.3 安全架构设计原则

```go
// 安全配置的核心结构
type SecurityConfig struct {
    // 权限控制
    Capabilities     *Capabilities    `json:"capabilities,omitempty"`
    NoNewPrivileges  bool            `json:"no_new_privileges,omitempty"`
    
    // 系统调用过滤
    Seccomp          *Seccomp        `json:"seccomp,omitempty"`
    
    // 强制访问控制
    AppArmorProfile  string          `json:"apparmor_profile,omitempty"`
    ProcessLabel     string          `json:"process_label,omitempty"`    // SELinux
    MountLabel       string          `json:"mount_label,omitempty"`      // SELinux
    
    // 用户权限映射
    UIDMappings      []IDMap         `json:"uid_mappings,omitempty"`
    GIDMappings      []IDMap         `json:"gid_mappings,omitempty"`
    
    // 文件系统安全
    MaskPaths        []string        `json:"mask_paths,omitempty"`
    ReadonlyPaths    []string        `json:"readonly_paths,omitempty"`
    Readonlyfs       bool            `json:"readonlyfs,omitempty"`
}
```

**核心原则**：
- 🔒 **最小权限原则**: 只授予必要的最小权限
- 🛡️ **深度防护**: 多层安全机制相互补充
- 🚫 **默认拒绝**: 除非明确允许，否则拒绝访问
- 📝 **审计跟踪**: 记录安全相关的操作和决策

## 2. Linux Capabilities 权限控制

### 2.1 Capabilities 基础概念

传统的 Unix 权限模型只有 **特权用户 (root)** 和 **普通用户** 的区分。Linux Capabilities 将 root 的超级权限分解为细粒度的能力位：

```
传统权限模型:              Capabilities 模型:
┌──────────────┐         ┌─────────────────────────────┐
│     root     │   分解   │ CAP_NET_ADMIN  (网络管理)   │
│  (所有权限)   │  ────→  │ CAP_SYS_ADMIN  (系统管理)   │
└──────────────┘         │ CAP_KILL       (发送信号)   │
       │                 │ CAP_CHOWN      (文件所有权) │
       │                 │ CAP_SETUID     (切换用户)   │
┌──────────────┐         │ CAP_MKNOD      (创建设备)   │
│  普通用户     │         │ ... 38+ 种能力             │
└──────────────┘         └─────────────────────────────┘
```

### 2.2 五种 Capabilities 集合

```go
// libcontainer/configs/config.go:145
type Capabilities struct {
    // 边界集：内核检查的能力上限
    Bounding    []string `json:"bounding,omitempty"`
    
    // 有效集：当前正在使用的能力
    Effective   []string `json:"effective,omitempty"`
    
    // 可继承集：可以传递给子进程的能力
    Inheritable []string `json:"inheritable,omitempty"`
    
    // 许可集：进程被允许拥有的能力上限
    Permitted   []string `json:"permitted,omitempty"`
    
    // 环境集：在 execve 后自动添加到许可和有效集的能力
    Ambient     []string `json:"ambient,omitempty"`
}
```

**集合关系图**：

```
进程执行前:                    execve() 后:
┌─────────────┐               ┌─────────────────┐
│ Bounding    │───────────────→│ 新进程 Bounding │ (不变)
└─────────────┘               └─────────────────┘
┌─────────────┐               ┌─────────────────┐
│ Permitted   │─┐             │ 新进程 Permitted│ (按规则计算)
└─────────────┘ │             └─────────────────┘
┌─────────────┐ │ 计算         ┌─────────────────┐
│ Inheritable │─┼─规则────────→│ 新进程 Effective│ (按规则计算)
└─────────────┘ │             └─────────────────┘
┌─────────────┐ │             ┌─────────────────┐
│ Ambient     │─┘             │ 新进程 Inheritable│ (继承)
└─────────────┘               └─────────────────┘
```

### 2.3 常用 Capabilities 详解

| Capability | 功能 | 容器中的应用 |
|------------|------|-------------|
| **CAP_NET_ADMIN** | 网络管理权限 | 配置网络接口、路由、iptables |
| **CAP_NET_BIND_SERVICE** | 绑定特权端口(<1024) | Web服务器监听80/443端口 |
| **CAP_SYS_ADMIN** | 系统管理权限 | 挂载文件系统、设置主机名 |
| **CAP_SYS_TIME** | 修改系统时间 | NTP服务、时间同步 |
| **CAP_KILL** | 发送信号到任意进程 | 进程监控、信号传递 |
| **CAP_CHOWN** | 修改文件所有权 | 文件权限管理 |
| **CAP_SETUID/SETGID** | 切换用户ID | sudo、认证服务 |
| **CAP_MKNOD** | 创建设备文件 | 设备驱动、特殊设备 |

### 2.4 runc 中的 Capabilities 实现

#### 应用流程

```go
// libcontainer/capabilities/capabilities.go:61
func ApplyCapabilities(c *configs.Capabilities) error {
    // 1. 清除所有 capabilities 集合
    if err := clearCapabilities(); err != nil {
        return err
    }
    
    // 2. 按照特定顺序设置 capabilities
    // 顺序很重要，因为不同集合之间有依赖关系
    if err := setCapabilities(c.Effective, effective); err != nil {
        return fmt.Errorf("failed to set effective capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Permitted, permitted); err != nil {
        return fmt.Errorf("failed to set permitted capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Inheritable, inheritable); err != nil {
        return fmt.Errorf("failed to set inheritable capabilities: %w", err)
    }
    
    if err := setCapabilities(c.Bounding, bounding); err != nil {
        return fmt.Errorf("failed to set bounding capabilities: %w", err)
    }
    
    // 3. Ambient 集合需要特殊处理
    if err := setAmbientCapabilities(c.Ambient); err != nil {
        return fmt.Errorf("failed to set ambient capabilities: %w", err)
    }
    
    return nil
}
```

#### Ambient Capabilities 特殊处理

```go
func setAmbientCapabilities(caps []string) error {
    // Ambient capabilities 是较新的特性，需要特别处理
    for _, cap := range caps {
        capInt, err := getCapabilityNumber(cap)
        if err != nil {
            continue  // 忽略不支持的 capability
        }
        
        // 重置 ambient 集合
        if err := unix.Prctl(unix.PR_CAP_AMBIENT, 
                           unix.PR_CAP_AMBIENT_CLEAR_ALL, 0, 0, 0); err != nil {
            return err
        }
        
        // 逐个添加 capability 到 ambient 集合
        if err := unix.Prctl(unix.PR_CAP_AMBIENT, 
                           unix.PR_CAP_AMBIENT_RAISE, capInt, 0, 0); err != nil {
            // 如果失败，可能是因为该 capability 不在 permitted 或 inheritable 集合中
            return fmt.Errorf("failed to add %s to ambient set: %w", cap, err)
        }
    }
    
    return nil
}
```

#### 兼容性处理

```go
func setCapabilities(caps []string, capType capabilityType) error {
    for _, cap := range caps {
        capInt, err := getCapabilityNumber(cap)
        if err != nil {
            // 对于未知的 capability，记录警告但不报错
            // 这保证了向前兼容性
            logrus.WithError(err).Warnf("Ignoring unknown capability %q", cap)
            continue
        }
        
        if err := applySingleCapability(capInt, capType); err != nil {
            // 某些 capability 在特定内核版本中可能不可用
            if errors.Is(err, unix.EINVAL) {
                logrus.WithError(err).Warnf("Capability %s not supported", cap)
                continue
            }
            return err
        }
    }
    
    return nil
}
```

### 2.5 默认 Capabilities 策略

runc 使用保守的默认 capabilities 策略：

```go
// 默认授予的 capabilities（最小集合）
var defaultCapabilities = []string{
    "CAP_CHOWN",           // 修改文件所有权
    "CAP_DAC_OVERRIDE",    // 绕过文件权限检查
    "CAP_FSETID",          // 设置文件 set-user-ID 位
    "CAP_FOWNER",          // 绕过文件所有权检查
    "CAP_MKNOD",           // 创建设备文件
    "CAP_NET_RAW",         // 使用 RAW 和 PACKET 套接字
    "CAP_SETGID",          // 修改进程 GID
    "CAP_SETUID",          // 修改进程 UID
    "CAP_SETFCAP",         // 设置文件 capabilities
    "CAP_SETPCAP",         // 修改进程 capabilities
    "CAP_NET_BIND_SERVICE", // 绑定特权端口
    "CAP_SYS_CHROOT",      // 使用 chroot
    "CAP_KILL",            // 发送信号
    "CAP_AUDIT_WRITE",     // 写入审计日志
}

// 明确禁用的危险 capabilities
var droppedCapabilities = []string{
    "CAP_SYS_ADMIN",       // 系统管理权限
    "CAP_SYS_TIME",        // 修改系统时间
    "CAP_NET_ADMIN",       // 网络管理权限
    "CAP_SYS_MODULE",      // 加载内核模块
    "CAP_SYS_RAWIO",       // 直接 I/O 访问
    "CAP_SYS_PTRACE",      // 调试其他进程
    "CAP_SYS_NICE",        // 修改进程优先级
    "CAP_IPC_LOCK",        // 锁定内存页
    "CAP_SYS_RESOURCE",    // 修改资源限制
    "CAP_SYS_TTY_CONFIG",  // 修改 TTY 配置
    "CAP_LEASE",           // 文件租约
    "CAP_WAKE_ALARM",      // 设置实时时钟警报
    "CAP_BLOCK_SUSPEND",   // 阻止系统休眠
}
```

## 3. seccomp 系统调用过滤

### 3.1 seccomp 基础原理

**seccomp (secure computing mode)** 是 Linux 内核的安全机制，可以限制进程能够调用的系统调用。

```
用户空间程序                    内核空间
┌─────────────────┐            ┌─────────────────────┐
│  应用程序       │            │                     │
│  ┌───────────┐  │   系统调用  │  ┌─────────────────┐ │
│  │  open()   │  │ ─────────→ │  │   seccomp BPF   │ │
│  │  write()  │  │            │  │     过滤器       │ │
│  │  exec()   │  │            │  └─────┬───────────┘ │
│  └───────────┘  │            │        │             │
└─────────────────┘            │        ▼             │
                               │  ┌─────────────────┐ │
                               │  │ ALLOW/DENY/TRAP │ │
                               │  │ TRACE/LOG/ERRNO │ │
                               │  └─────────────────┘ │
                               └─────────────────────┘
```

### 3.2 seccomp 配置结构

```go
// libcontainer/configs/config.go:207
type Seccomp struct {
    // 默认动作：对未匹配规则的系统调用执行的动作
    DefaultAction    Action                   `json:"default_action"`
    
    // 架构列表：限制在特定CPU架构上
    Architectures    []string                 `json:"architectures"`
    
    // 标志：seccomp的行为控制标志
    Flags            []specs.LinuxSeccompFlag `json:"flags"`
    
    // 系统调用规则列表
    Syscalls         []*Syscall               `json:"syscalls"`
    
    // 默认错误返回值：当动作为ERRNO时返回的错误码
    DefaultErrnoRet  *uint                    `json:"default_errno_ret"`
    
    // 监听路径：用于 seccomp notify 机制
    ListenerPath     string                   `json:"listener_path,omitempty"`
    
    // 监听元数据：传递给监听器的额外信息
    ListenerMetadata string                   `json:"listener_metadata,omitempty"`
}

// 系统调用规则
type Syscall struct {
    Name     string `json:"name"`          // 系统调用名称
    Action   Action `json:"action"`        // 执行的动作
    ErrnoRet *uint  `json:"errnoRet"`      // ERRNO动作的返回值
    Args     []*Arg `json:"args"`          // 参数过滤条件
}

// 参数过滤条件
type Arg struct {
    Index    uint     `json:"index"`    // 参数索引 (0-5)
    Value    uint64   `json:"value"`    // 比较值
    ValueTwo *uint64  `json:"valueTwo"` // 范围比较的第二个值
    Op       Operator `json:"op"`       // 比较操作符
}
```

### 3.3 seccomp 动作类型

| 动作 | 描述 | 应用场景 |
|------|------|----------|
| **KILL/KILL_THREAD** | 终止进程/线程 | 绝对禁止的系统调用 |
| **ERRNO** | 返回错误码 | 优雅处理不允许的调用 |
| **TRAP** | 发送 SIGSYS 信号 | 调试和监控 |
| **ALLOW** | 允许执行 | 白名单模式 |
| **TRACE** | 跟踪执行 | 安全审计 |
| **LOG** | 记录日志 | 监控可疑调用 |
| **NOTIFY** | 通知用户空间 | 动态安全决策 |

### 3.4 runc 中的 seccomp 实现

#### 过滤器初始化

```go
// libcontainer/seccomp/seccomp_linux.go:89
func InitSeccomp(config *configs.Seccomp) error {
    if config == nil {
        return errors.New("cannot initialize Seccomp - nil config passed")
    }
    
    // 创建 seccomp 过滤器上下文
    filter, err := libseccomp.NewFilter(seccompAction(config.DefaultAction))
    if err != nil {
        return fmt.Errorf("failed to create seccomp filter: %w", err)
    }
    defer filter.Release()
    
    // 设置架构限制
    for _, arch := range config.Architectures {
        scmpArch, err := libseccomp.GetArchFromString(arch)
        if err != nil {
            return fmt.Errorf("invalid architecture %s: %w", arch, err)
        }
        
        if err := filter.AddArch(scmpArch); err != nil {
            return fmt.Errorf("failed to add architecture %s: %w", arch, err)
        }
    }
    
    // 添加系统调用规则
    for _, syscall := range config.Syscalls {
        if err := addSyscallRule(filter, syscall); err != nil {
            return fmt.Errorf("failed to add syscall rule for %s: %w", 
                             syscall.Name, err)
        }
    }
    
    // 应用 BPF 补丁优化
    if err := patchbpf.PatchAndLoad(config, filter); err != nil {
        return fmt.Errorf("failed to patch and load seccomp filter: %w", err)
    }
    
    return nil
}
```

#### 系统调用规则添加

```go
func addSyscallRule(filter *libseccomp.ScmpFilter, syscall *Syscall) error {
    // 获取系统调用号
    scmpSyscall, err := libseccomp.GetSyscallFromName(syscall.Name)
    if err != nil {
        // 忽略未知的系统调用，提高兼容性
        logrus.WithError(err).Debugf("Ignoring unknown syscall %s", syscall.Name)
        return nil
    }
    
    // 构建参数条件
    var conditions []libseccomp.ScmpCondition
    for _, arg := range syscall.Args {
        condition := libseccomp.ScmpCondition{
            Argument: arg.Index,
            Op:       libseccomp.ScmpCompareOp(arg.Op),
            Operand1: arg.Value,
        }
        
        // 处理范围比较
        if arg.ValueTwo != nil {
            condition.Operand2 = *arg.ValueTwo
        }
        
        conditions = append(conditions, condition)
    }
    
    // 添加规则到过滤器
    action := seccompAction(syscall.Action)
    if err := filter.AddRuleConditional(scmpSyscall, action, conditions); err != nil {
        return fmt.Errorf("failed to add conditional rule: %w", err)
    }
    
    return nil
}
```

### 3.5 BPF 补丁优化

runc 实现了 BPF 程序补丁机制来优化 seccomp 性能：

```go
// libcontainer/seccomp/patchbpf/enosys_linux.go:45
func PatchAndLoad(config *configs.Seccomp, filter *libseccomp.ScmpFilter) error {
    // 生成 BPF 字节码
    program, err := filter.ExportBPF()
    if err != nil {
        return err
    }
    
    // 应用 ENOSYS 补丁：对未知系统调用返回 ENOSYS 而不是 kill
    if needsEnosysPatch(config) {
        program, err = patchEnosys(program)
        if err != nil {
            return fmt.Errorf("failed to patch BPF program: %w", err)
        }
    }
    
    // 加载补丁后的 BPF 程序
    if err := unix.Prctl(unix.PR_SET_SECCOMP, unix.SECCOMP_MODE_FILTER, 
                        uintptr(unsafe.Pointer(&program[0])), 0, 0); err != nil {
        return fmt.Errorf("failed to load seccomp filter: %w", err)
    }
    
    return nil
}

func needsEnosysPatch(config *configs.Seccomp) bool {
    // 当默认动作不是 ALLOW 且没有使用 notify 机制时需要补丁
    return config.DefaultAction != configs.Kill && 
           config.DefaultAction != configs.KillThread &&
           config.ListenerPath == ""
}
```

### 3.6 高级特性：seccomp notify

seccomp notify 是较新的特性，允许用户空间程序动态处理系统调用：

```go
// 检查 notify 机制的限制
func validateNotifyConfig(config *configs.Seccomp) error {
    if config.ListenerPath == "" {
        return nil
    }
    
    // notify 机制需要 Linux 5.7+ 和 libseccomp 2.5.0+
    if !isNotifySupported() {
        return errors.New("seccomp notify requires Linux 5.7+ and libseccomp 2.5.0+")
    }
    
    // write 系统调用不能使用 notify (避免初始化死锁)
    for _, syscall := range config.Syscalls {
        if syscall.Name == "write" && syscall.Action == configs.Notify {
            return errors.New("write syscall cannot use notify action")
        }
    }
    
    return nil
}
```

### 3.7 默认 seccomp 策略

runc 提供了保守的默认 seccomp 配置：

```go
// 默认被阻止的危险系统调用
var defaultBlockedSyscalls = []string{
    // 内核模块操作
    "init_module", "finit_module", "delete_module",
    
    // 直接内存访问
    "iopl", "ioperm", 
    
    // 时间修改
    "clock_settime", "settimeofday", "stime",
    
    // 挂载操作
    "mount", "umount2", "swapon", "swapoff",
    
    // 系统控制
    "reboot", "sethostname", "setdomainname",
    
    // 进程跟踪
    "ptrace",
    
    // 性能监控
    "perf_event_open",
    
    // 容器逃逸相关
    "unshare", "clone", "setns",
}

// 生成默认 seccomp 配置
func DefaultProfile() *configs.Seccomp {
    return &configs.Seccomp{
        DefaultAction: configs.Allow,  // 默认允许
        Architectures: []string{runtime.GOARCH},
        Syscalls: []*configs.Syscall{
            // 阻止危险系统调用
            {
                Names:  defaultBlockedSyscalls,
                Action: configs.Errno,
                ErrnoRet: uint(unix.EPERM),
            },
            
            // clone 系统调用特殊处理
            {
                Names:  []string{"clone"},
                Action: configs.Allow,
                Args: []*configs.Arg{
                    // 只允许特定的 clone 标志
                    {
                        Index: 0,
                        Value: unix.CLONE_NEWNS,
                        Op:    configs.OpMaskedEqual,
                    },
                },
            },
        },
    }
}
```

## 4. AppArmor/SELinux 强制访问控制

### 4.1 MAC vs DAC

**DAC (Discretionary Access Control)**：传统的 Unix 权限模型
- 文件所有者可以决定访问权限
- 基于用户/组/其他的简单三元模型
- 容易被恶意程序绕过

**MAC (Mandatory Access Control)**：强制访问控制
- 系统管理员设置的策略不能被绕过
- 基于安全标签和策略规则
- 提供更强的安全保护

```
DAC 模型:                      MAC 模型:
┌─────────────────┐           ┌─────────────────────────────┐
│  文件所有者     │   决定     │      系统管理员             │   制定
│  设置权限       │  ────→    │      制定安全策略           │  ────→
└─────────────────┘           └─────────────────────────────┘
       │                                    │
       ▼                                    ▼
┌─────────────────┐           ┌─────────────────────────────┐
│ rwx permissions │           │    AppArmor/SELinux 策略    │
│ user:group:other│           │      不可被进程修改         │
└─────────────────┘           └─────────────────────────────┘
```

### 4.2 AppArmor 集成

#### 基础实现

```go
// libcontainer/apparmor/apparmor_linux.go:32
func ApplyProfile(name string) error {
    if name == "" {
        return nil
    }
    
    // 检查 AppArmor 是否可用
    if !IsEnabled() {
        return errors.New("AppArmor is not enabled on this system")
    }
    
    // 在 exec 时切换到指定的 profile
    return changeOnExec(name)
}

func IsEnabled() bool {
    // 检查 AppArmor 文件系统是否挂载
    if _, err := os.Stat("/sys/kernel/security/apparmor"); err != nil {
        return false
    }
    
    // 检查当前进程是否在 AppArmor 控制下
    data, err := os.ReadFile("/proc/self/attr/current")
    if err != nil {
        return false
    }
    
    // 如果不是 "unconfined"，说明 AppArmor 已启用
    return !strings.Contains(string(data), "unconfined")
}

func changeOnExec(name string) error {
    // 写入 exec 属性文件，在下次 exec 时切换 profile
    attrPath := "/proc/self/attr/exec"
    
    // 尝试新版路径
    if _, err := os.Stat("/proc/self/attr/apparmor/exec"); err == nil {
        attrPath = "/proc/self/attr/apparmor/exec"
    }
    
    file, err := os.OpenFile(attrPath, os.O_WRONLY, 0)
    if err != nil {
        return fmt.Errorf("failed to open AppArmor exec attr: %w", err)
    }
    defer file.Close()
    
    // 写入 profile 名称，格式为 "exec profilename"
    profileSpec := "exec " + name
    if _, err := file.WriteString(profileSpec); err != nil {
        return fmt.Errorf("failed to set AppArmor profile %s: %w", name, err)
    }
    
    return nil
}
```

#### 容器 AppArmor Profile 示例

```bash
# /etc/apparmor.d/docker-default
#include <tunables/global>

profile docker-default flags=(attach_disconnected,mediate_deleted) {
  # 网络访问
  network inet tcp,
  network inet udp,
  network inet icmp,
  
  # 文件系统访问
  file,
  / r,
  /etc/ r,
  /etc/** r,
  /lib/ r,
  /lib/** r,
  /usr/ r,
  /usr/** r,
  
  # 禁止访问敏感路径
  deny /sys/firmware/efi/efivars/ wl,
  deny /sys/kernel/security/ wl,
  deny /proc/sys/kernel/core_pattern wl,
  deny /proc/kcore r,
  deny /proc/kallsyms r,
  
  # 允许的系统调用
  capability chown,
  capability dac_override,
  capability setuid,
  capability setgid,
  capability net_bind_service,
  
  # 禁止的危险操作
  deny capability sys_admin,
  deny capability sys_time,
  deny capability sys_module,
}
```

### 4.3 SELinux 集成

#### 标签设置

```go
// SELinux 标签应用
func ApplySELinuxLabels(config *configs.Config) error {
    if !selinux.GetEnabled() {
        return nil
    }
    
    // 设置进程执行标签
    if config.ProcessLabel != "" {
        if err := selinux.SetExecLabel(config.ProcessLabel); err != nil {
            return fmt.Errorf("failed to set SELinux exec label: %w", err)
        }
    }
    
    // 设置密钥环标签
    if config.ProcessLabel != "" {
        if err := selinux.SetKeyLabel(config.ProcessLabel); err != nil {
            return fmt.Errorf("failed to set SELinux key label: %w", err)
        }
    }
    
    return nil
}
```

#### 挂载标签处理

```go
// 文件系统挂载时应用 SELinux 标签
func formatMountLabel(src, mountLabel string) string {
    if mountLabel == "" {
        return ""
    }
    
    // 格式化挂载标签
    switch {
    case strings.Contains(mountLabel, "context="):
        return mountLabel
    default:
        return fmt.Sprintf("context=%s", mountLabel)
    }
}
```

#### SELinux 策略示例

```bash
# container.te - 容器 SELinux 策略示例
policy_module(container, 1.0.0)

# 容器域定义
type container_t;
type container_exec_t;
domain_type(container_t)
domain_entry_file(container_t, container_exec_t)

# 容器文件类型
type container_file_t;
files_type(container_file_t)

# 允许容器域的基本操作
allow container_t self:process { fork signal_perms };
allow container_t self:fifo_file rw_fifo_file_perms;
allow container_t self:unix_stream_socket create_stream_socket_perms;

# 允许访问容器文件
allow container_t container_file_t:dir list_dir_perms;
allow container_t container_file_t:file read_file_perms;

# 禁止访问敏感资源
neverallow container_t kernel_t:system module_load;
neverallow container_t sysctl_t:file write;
neverallow container_t device_t:chr_file write;
```

## 5. 用户命名空间权限映射

### 5.1 ID 映射机制

用户命名空间允许容器内的 UID/GID 映射到宿主机的不同 UID/GID：

```
容器内视图:        映射关系:           宿主机视图:
UID 0 (root)  ←─→  UID 1000 (user)    UID 1000 (普通用户)
UID 1         ←─→  UID 1001           UID 1001
UID 2         ←─→  UID 1002           UID 1002
...           ←─→  ...                ...
UID 65535     ←─→  UID 66535          UID 66535

映射配置:
容器ID: 0,  宿主ID: 1000, 范围: 65536
```

### 5.2 ID 映射配置

```go
// libcontainer/configs/config.go:85
type IDMap struct {
    ContainerID int64 `json:"container_id"`  // 容器内起始 ID
    HostID      int64 `json:"host_id"`       // 宿主机起始 ID  
    Size        int64 `json:"size"`          // 映射范围大小
}

// 用户映射获取
func GetUserNamespaceMappings(nsPath string) ([]IDMap, []IDMap, error) {
    // 快速路径：直接读取映射文件
    uidMaps, err := readMappingFile(nsPath, "uid_map")
    if err == nil {
        gidMaps, err := readMappingFile(nsPath, "gid_map")
        return uidMaps, gidMaps, err
    }
    
    // 慢速路径：使用 C 代码在用户命名空间内读取
    return readMappingsWithC(nsPath)
}
```

### 5.3 映射文件读取

```go
// libcontainer/internal/userns/userns_maps_linux.go:89
func readMappingFile(nsPath, mapType string) ([]IDMap, error) {
    mapPath := filepath.Join("/proc", extractPid(nsPath), mapType)
    
    data, err := os.ReadFile(mapPath)
    if err != nil {
        return nil, err
    }
    
    var mappings []IDMap
    for _, line := range strings.Split(string(data), "\n") {
        line = strings.TrimSpace(line)
        if line == "" {
            continue
        }
        
        // 解析格式: "容器ID 宿主ID 范围大小"
        parts := strings.Fields(line)
        if len(parts) != 3 {
            continue
        }
        
        containerID, _ := strconv.ParseInt(parts[0], 10, 64)
        hostID, _ := strconv.ParseInt(parts[1], 10, 64)
        size, _ := strconv.ParseInt(parts[2], 10, 64)
        
        mappings = append(mappings, IDMap{
            ContainerID: containerID,
            HostID:      hostID,
            Size:        size,
        })
    }
    
    return mappings, nil
}
```

### 5.4 C 代码映射读取

```c
// libcontainer/internal/userns/userns_maps_linux.c:45
int spawn_userns_cat(const char *file, const char *ns_path, int output_fd) {
    int ns_fd = -1;
    int file_fd = -1;
    
    // 打开用户命名空间文件描述符
    ns_fd = open(ns_path, O_RDONLY | O_CLOEXEC);
    if (ns_fd < 0) {
        goto error;
    }
    
    // fork 子进程
    pid_t child = fork();
    if (child == 0) {
        // 子进程：进入用户命名空间
        if (setns(ns_fd, CLONE_NEWUSER) < 0) {
            goto error;
        }
        
        // 在用户命名空间内打开映射文件
        file_fd = open(file, O_RDONLY | O_CLOEXEC);
        if (file_fd < 0) {
            goto error;
        }
        
        // 复制文件内容到输出管道
        char buffer[4096];
        ssize_t bytes;
        while ((bytes = read(file_fd, buffer, sizeof(buffer))) > 0) {
            if (write(output_fd, buffer, bytes) != bytes) {
                goto error;
            }
        }
        
        close(file_fd);
        close(ns_fd);
        _exit(0);
        
    error:
        if (file_fd >= 0) close(file_fd);
        if (ns_fd >= 0) close(ns_fd);
        _exit(1);
    } else if (child > 0) {
        // 父进程：等待子进程完成
        int status;
        while (waitpid(child, &status, 0) != child) {
            if (errno != EINTR) {
                break;
            }
        }
        return WEXITSTATUS(status);
    }
    
    return 1;  // fork 失败
}
```

### 5.5 Rootless 容器安全模型

Rootless 容器使用用户命名空间实现无特权运行：

```bash
# rootless 容器的典型映射配置
$ cat /proc/self/uid_map
         0       1000          1      # 容器root → 宿主普通用户
         1     100000      65536      # 其他ID → 子ID范围

$ cat /proc/self/gid_map  
         0       1000          1      # 容器root组 → 宿主普通组
         1     100000      65536      # 其他组 → 子组范围

# 检查子ID配置
$ cat /etc/subuid
user:100000:65536

$ cat /etc/subgid  
user:100000:65536
```

**Rootless 安全优势**：
- 🚫 **无需特权**: 不需要 root 权限启动容器
- 🔒 **权限隔离**: 容器内 root 权限被限制在用户命名空间内
- 🛡️ **攻击面缩小**: 减少了特权升级的攻击面

## 6. 安全策略配置和应用

### 6.1 安全配置验证

```go
// libcontainer/configs/validate/security.go:15
func security(config *configs.Config) error {
    // 检查 MaskPaths/ReadonlyPaths 需要私有 mount namespace
    if (len(config.MaskPaths) > 0 || len(config.ReadonlyPaths) > 0) &&
        !config.Namespaces.Contains(configs.NEWNS) {
        return errors.New("cannot restrict paths without private mount namespace")
    }
    
    // 检查 SELinux 配置
    if config.ProcessLabel != "" && !selinux.GetEnabled() {
        return errors.New("SELinux label specified but SELinux disabled")
    }
    
    // 检查 AppArmor 配置
    if config.AppArmorProfile != "" && !apparmor.IsEnabled() {
        return errors.New("AppArmor profile specified but AppArmor disabled")
    }
    
    // 检查 seccomp 配置
    if config.Seccomp != nil {
        if err := validateSeccompConfig(config.Seccomp); err != nil {
            return fmt.Errorf("invalid seccomp config: %w", err)
        }
    }
    
    return nil
}
```

### 6.2 安全策略应用流程

```go
// libcontainer/standard_init_linux.go:200
func finalizeNamespace(config *initConfig) error {
    // 1. 应用 AppArmor profile
    if err := apparmor.ApplyProfile(config.AppArmorProfile); err != nil {
        return fmt.Errorf("failed to apply AppArmor profile: %w", err)
    }
    
    // 2. 设置 SELinux 标签
    if err := selinux.SetExecLabel(config.ProcessLabel); err != nil {
        return fmt.Errorf("failed to set SELinux label: %w", err)
    }
    
    // 3. 应用文件系统限制
    if err := applyPathRestrictions(config); err != nil {
        return fmt.Errorf("failed to apply path restrictions: %w", err)
    }
    
    // 4. 设置 no_new_privs 位
    if config.NoNewPrivileges {
        if err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {
            return fmt.Errorf("failed to set no_new_privs: %w", err)
        }
    }
    
    // 5. 应用 Linux capabilities
    if err := capabilities.ApplyCapabilities(config.Capabilities); err != nil {
        return fmt.Errorf("failed to apply capabilities: %w", err)
    }
    
    // 6. 初始化 seccomp 过滤器
    if config.Seccomp != nil {
        if err := seccomp.InitSeccomp(config.Seccomp); err != nil {
            return fmt.Errorf("failed to initialize seccomp: %w", err)
        }
    }
    
    return nil
}
```

### 6.3 路径限制实现

```go
// 应用敏感路径的访问限制
func applyPathRestrictions(config *initConfig) error {
    // 屏蔽敏感路径 (用 tmpfs 覆盖)
    for _, path := range config.Config.MaskPaths {
        if err := maskPath(path, config.Config.Readonlyfs); err != nil {
            return err
        }
    }
    
    // 设置只读路径
    for _, path := range config.Config.ReadonlyPaths {
        if err := readonlyPath(path); err != nil {
            return err
        }
    }
    
    return nil
}

func maskPath(path string, readonly bool) error {
    // 使用 tmpfs 挂载来屏蔽敏感路径
    flags := unix.MS_RDONLY
    if !readonly {
        flags = 0
    }
    
    if err := mount("tmpfs", path, "tmpfs", 
                   uintptr(flags), ""); err != nil {
        // 如果挂载失败，尝试创建空文件覆盖
        if os.IsNotExist(err) {
            return createEmptyFile(path)
        }
        return err
    }
    
    return nil
}

func readonlyPath(path string) error {
    // 绑定挂载后重新挂载为只读
    if err := mount(path, path, "", unix.MS_BIND, ""); err != nil {
        if os.IsNotExist(err) {
            return nil  // 路径不存在，忽略
        }
        return err
    }
    
    return mount(path, path, "", 
                unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, "")
}
```

## 7. 实践练习

### 7.1 Capabilities 实验

```bash
#!/bin/bash
# 实验 1: 理解 capabilities 的作用

# 检查当前进程的 capabilities
echo "=== Current Process Capabilities ==="
cat /proc/self/status | grep Cap

# 使用 capsh 分析 capabilities
capsh --decode=0x00000000a80425fb
capsh --print

# 测试网络权限
echo "=== Testing Network Capabilities ==="

# 创建一个没有 CAP_NET_ADMIN 的进程
capsh --drop=cap_net_admin --print &
PID=$!
sleep 1

# 尝试修改网络配置 (应该失败)
nsenter -t $PID -n ip link set lo down 2>&1 || echo "Permission denied (expected)"

# 创建有 CAP_NET_BIND_SERVICE 的进程测试特权端口
python3 -c "
import socket
try:
    s = socket.socket()
    s.bind(('', 80))  # 特权端口
    print('Successfully bound to port 80')
    s.close()
except PermissionError:
    print('Cannot bind to privileged port (expected without CAP_NET_BIND_SERVICE)')
"
```

### 7.2 seccomp 过滤实验

```go
// 实验 2: seccomp 系统调用过滤
package main

import (
    "fmt"
    "os"
    "syscall"
    "unsafe"
    
    "golang.org/x/sys/unix"
    "github.com/seccomp/libseccomp-golang"
)

func main() {
    // 创建 seccomp 过滤器
    filter, err := seccomp.NewFilter(seccomp.ActAllow)
    if err != nil {
        panic(err)
    }
    defer filter.Release()
    
    // 禁止 mkdir 系统调用
    if err := filter.AddRule(seccomp.ScmpSyscall(unix.SYS_MKDIR), 
                            seccomp.ActErrno.SetReturnCode(int16(syscall.EPERM))); err != nil {
        panic(err)
    }
    
    // 加载过滤器
    if err := filter.Load(); err != nil {
        panic(err)
    }
    
    fmt.Println("seccomp filter loaded")
    
    // 测试被禁止的系统调用
    if err := os.Mkdir("/tmp/test-mkdir", 0755); err != nil {
        fmt.Printf("mkdir failed as expected: %v\n", err)
    } else {
        fmt.Println("ERROR: mkdir should have been blocked!")
    }
    
    // 测试允许的系统调用
    if file, err := os.Create("/tmp/test-create"); err == nil {
        fmt.Println("file creation allowed")
        file.Close()
        os.Remove("/tmp/test-create")
    }
}
```

### 7.3 AppArmor Profile 测试

```bash
#!/bin/bash
# 实验 3: AppArmor profile 约束测试

# 检查 AppArmor 状态
sudo aa-status

# 创建测试 profile
sudo tee /etc/apparmor.d/test-container > /dev/null << 'EOF'
#include <tunables/global>

profile test-container flags=(attach_disconnected) {
  #include <abstractions/base>
  
  # 允许基本文件访问
  / r,
  /bin/** ix,
  /lib/** ix,
  /usr/bin/** ix,
  /tmp/** rw,
  
  # 禁止访问敏感文件
  deny /etc/shadow r,
  deny /proc/*/mem r,
  deny /sys/kernel/security/** rw,
  
  # 允许网络
  network inet tcp,
  network inet udp,
  
  # 禁止某些 capabilities
  deny capability sys_admin,
  deny capability sys_time,
}
EOF

# 加载 profile
sudo apparmor_parser -r /etc/apparmor.d/test-container

# 测试 profile 约束
echo "=== Testing AppArmor Profile Constraints ==="

# 在 profile 约束下运行命令
sudo aa-exec -p test-container /bin/bash -c '
echo "Running under AppArmor profile: $(cat /proc/self/attr/current)"

# 允许的操作
echo "test" > /tmp/allowed.txt
cat /tmp/allowed.txt

# 被禁止的操作
echo "Trying to read /etc/shadow:"
cat /etc/shadow 2>&1 || echo "Access denied (expected)"

echo "Trying to read /proc/1/mem:"
head -c 10 /proc/1/mem 2>&1 || echo "Access denied (expected)"
'

# 清理
sudo rm /tmp/allowed.txt
sudo apparmor_parser -R /etc/apparmor.d/test-container
sudo rm /etc/apparmor.d/test-container
```

### 7.4 用户命名空间映射实验

```bash
#!/bin/bash
# 实验 4: 用户命名空间权限映射

echo "=== User Namespace ID Mapping Test ==="

# 检查当前 UID/GID
echo "Current UID/GID outside namespace: $(id)"

# 创建用户命名空间并设置映射
unshare --user --map-root-user /bin/bash -c '
echo "=== Inside User Namespace ==="
echo "UID/GID inside namespace: $(id)"
echo

# 检查映射文件
echo "UID mapping:"
cat /proc/self/uid_map

echo "GID mapping:"  
cat /proc/self/gid_map

# 测试文件权限
echo "=== File Permission Test ==="
echo "Creating file as root inside namespace..."
touch /tmp/userns-test-file
ls -la /tmp/userns-test-file

echo "File ownership as seen from namespace:"
stat -c "UID: %u, GID: %g" /tmp/userns-test-file
'

echo
echo "=== Outside Namespace View ==="
echo "File ownership as seen from host:"
stat -c "UID: %u, GID: %g" /tmp/userns-test-file 2>/dev/null || echo "File not accessible"

# 清理
rm -f /tmp/userns-test-file
```

## 8. 安全最佳实践

### 8.1 安全配置检查清单

```bash
#!/bin/bash
# 容器安全配置检查脚本

check_security_config() {
    local config_file="$1"
    
    echo "=== Container Security Configuration Audit ==="
    
    # 检查 capabilities
    echo "1. Checking Capabilities:"
    if grep -q '"bounding".*"CAP_SYS_ADMIN"' "$config_file"; then
        echo "  ⚠️  WARNING: CAP_SYS_ADMIN granted (high risk)"
    else
        echo "  ✅ CAP_SYS_ADMIN not granted"
    fi
    
    if grep -q '"bounding".*"CAP_SYS_MODULE"' "$config_file"; then
        echo "  ❌ CRITICAL: CAP_SYS_MODULE granted (kernel module loading)"
    else
        echo "  ✅ CAP_SYS_MODULE not granted"
    fi
    
    # 检查 seccomp
    echo "2. Checking seccomp:"
    if grep -q '"defaultAction":"SCMP_ACT_ALLOW"' "$config_file"; then
        echo "  ⚠️  WARNING: Default seccomp action is ALLOW"
    else
        echo "  ✅ Restrictive seccomp policy"
    fi
    
    # 检查只读根文件系统
    echo "3. Checking root filesystem:"
    if grep -q '"readonly":true' "$config_file"; then
        echo "  ✅ Root filesystem is read-only"
    else
        echo "  ⚠️  WARNING: Root filesystem is writable"
    fi
    
    # 检查特权模式
    echo "4. Checking privileged mode:"
    if grep -q '"privileged":true' "$config_file"; then
        echo "  ❌ CRITICAL: Container running in privileged mode"
    else
        echo "  ✅ Container not privileged"
    fi
    
    # 检查用户命名空间
    echo "5. Checking user namespace:"
    if grep -q '"type":"user"' "$config_file"; then
        echo "  ✅ User namespace enabled"
    else
        echo "  ⚠️  WARNING: User namespace not enabled"
    fi
}

# 使用示例
# check_security_config config.json
```

### 8.2 安全策略模板

```json
{
  "ociVersion": "1.0.2",
  "process": {
    "user": {
      "uid": 1000,
      "gid": 1000
    },
    "args": ["/app/server"],
    "capabilities": {
      "bounding": [
        "CAP_CHOWN",
        "CAP_SETGID", 
        "CAP_SETUID",
        "CAP_NET_BIND_SERVICE"
      ],
      "effective": [
        "CAP_CHOWN",
        "CAP_SETGID",
        "CAP_SETUID", 
        "CAP_NET_BIND_SERVICE"
      ],
      "permitted": [
        "CAP_CHOWN",
        "CAP_SETGID",
        "CAP_SETUID",
        "CAP_NET_BIND_SERVICE"
      ]
    },
    "noNewPrivileges": true
  },
  "root": {
    "path": "rootfs",
    "readonly": true
  },
  "linux": {
    "namespaces": [
      {"type": "pid"},
      {"type": "network"},
      {"type": "mount"},
      {"type": "user"},
      {"type": "uts"},
      {"type": "ipc"}
    ],
    "uidMappings": [
      {
        "containerID": 0,
        "hostID": 1000,
        "size": 1
      }
    ],
    "gidMappings": [
      {
        "containerID": 0,
        "hostID": 1000, 
        "size": 1
      }
    ],
    "seccomp": {
      "defaultAction": "SCMP_ACT_ERRNO",
      "architectures": ["SCMP_ARCH_X86_64"],
      "syscalls": [
        {
          "names": [
            "read", "write", "open", "close",
            "stat", "fstat", "lstat", "poll",
            "lseek", "mmap", "mprotect", "munmap",
            "brk", "rt_sigaction", "rt_sigprocmask",
            "access", "pipe", "select", "sched_yield",
            "mremap", "msync", "mincore", "madvise",
            "dup", "dup2", "pause", "nanosleep",
            "getitimer", "alarm", "setitimer", "getpid",
            "sendfile", "socket", "connect", "accept",
            "sendto", "recvfrom", "sendmsg", "recvmsg",
            "shutdown", "bind", "listen", "getsockname",
            "getpeername", "socketpair", "setsockopt", "getsockopt",
            "clone", "fork", "vfork", "execve",
            "exit", "wait4", "kill", "uname",
            "fcntl", "flock", "fsync", "fdatasync",
            "truncate", "ftruncate", "getdents", "getcwd",
            "chdir", "fchdir", "rename", "mkdir",
            "rmdir", "creat", "link", "unlink",
            "symlink", "readlink", "chmod", "fchmod",
            "chown", "fchown", "lchown", "umask"
          ],
          "action": "SCMP_ACT_ALLOW"
        }
      ]
    },
    "maskedPaths": [
      "/proc/acpi",
      "/proc/asound", 
      "/proc/kcore",
      "/proc/keys",
      "/proc/latency_stats",
      "/proc/timer_list",
      "/proc/timer_stats",
      "/proc/sched_debug",
      "/sys/firmware",
      "/sys/fs/cgroup"
    ],
    "readonlyPaths": [
      "/proc/bus",
      "/proc/fs", 
      "/proc/irq",
      "/proc/sys",
      "/proc/sysrq-trigger"
    ]
  }
}
```

### 8.3 安全监控和审计

```go
// 安全事件监控示例
package main

import (
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"
)

type SecurityMonitor struct {
    events chan SecurityEvent
}

type SecurityEvent struct {
    Type      string
    Message   string
    Timestamp time.Time
    Severity  string
}

func (sm *SecurityMonitor) Start() {
    go sm.monitorCapabilities()
    go sm.monitorSeccomp()
    go sm.monitorAppArmor()
    go sm.logEvents()
}

func (sm *SecurityMonitor) monitorCapabilities() {
    // 监控 capabilities 变化
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        // 检查当前进程的 capabilities
        caps, err := getCurrentCapabilities()
        if err != nil {
            continue
        }
        
        if containsDangerousCapabilities(caps) {
            sm.events <- SecurityEvent{
                Type:      "capability",
                Message:   "Dangerous capabilities detected",
                Timestamp: time.Now(),
                Severity:  "HIGH",
            }
        }
    }
}

func (sm *SecurityMonitor) monitorSeccomp() {
    // 监控 seccomp 违规
    // 通过解析 /proc/self/status 检查 seccomp 状态
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if !isSeccompActive() {
            sm.events <- SecurityEvent{
                Type:      "seccomp", 
                Message:   "seccomp filter not active",
                Timestamp: time.Now(),
                Severity:  "MEDIUM",
            }
        }
    }
}

func (sm *SecurityMonitor) logEvents() {
    for event := range sm.events {
        log.Printf("[%s] %s: %s (%s)", 
                  event.Severity, event.Type, event.Message, 
                  event.Timestamp.Format(time.RFC3339))
    }
}

func main() {
    monitor := &SecurityMonitor{
        events: make(chan SecurityEvent, 100),
    }
    
    monitor.Start()
    
    // 等待退出信号
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    <-sigChan
    
    log.Println("Security monitor shutting down")
}
```

## 9. 思考题

### 9.1 安全模型思考

1. **多层防护**: 为什么需要 capabilities + seccomp + MAC 的多层安全机制？单一机制的局限性是什么？

2. **权限最小化**: 如何平衡安全性和功能性？过度限制权限可能导致什么问题？

3. **安全策略**: 如何为不同类型的应用（Web服务、数据库、批处理任务）设计合适的安全策略？

### 9.2 实现细节思考

4. **Capabilities继承**: ambient capabilities 解决了什么问题？为什么需要这种复杂的继承模型？

5. **seccomp性能**: BPF过滤器对系统调用性能的影响如何？有什么优化策略？

6. **用户映射**: 在大规模容器环境中，如何有效管理用户ID映射？subuid/subgid 的分配策略？

### 9.3 安全挑战思考

7. **容器逃逸**: 当前的安全机制能防护哪些类型的容器逃逸？还有什么潜在漏洞？

8. **兼容性问题**: 严格的安全策略可能影响应用兼容性，如何处理这种冲突？

9. **监控审计**: 如何有效监控和审计容器的安全行为？什么样的行为应该被标记为可疑？

## 10. 扩展阅读

### 10.1 Linux 安全机制

- [Linux Capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html)
- [seccomp(2)](https://man7.org/linux/man-pages/man2/seccomp.2.html) 
- [AppArmor Documentation](https://gitlab.com/apparmor/apparmor/-/wikis/Documentation)
- [SELinux User's Guide](https://selinuxproject.org/page/User/UserGuide)

### 10.2 容器安全最佳实践

- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)
- [NIST Container Security Guide](https://csrc.nist.gov/publications/detail/sp/800-190/final)
- [Container Security by Liz Rice](https://info.aquasec.com/container-security-book)

### 10.3 安全研究和工具

- [Container Security Tools](https://github.com/freach/container-security-awesome)
- [Falco Runtime Security](https://falco.org/)
- [OPA Gatekeeper](https://open-policy-agent.github.io/gatekeeper/)

## 🎯 模块总结

通过本模块的学习，你应该已经掌握了：

✅ **多层安全架构**：理解容器安全的威胁模型和防护体系  
✅ **Capabilities 权限控制**：掌握细粒度权限管理和应用策略  
✅ **seccomp 系统调用过滤**：理解BPF过滤器和策略配置  
✅ **强制访问控制**：熟悉AppArmor/SELinux的集成和应用  
✅ **用户权限映射**：掌握用户命名空间的安全模型  
✅ **安全策略设计**：具备设计和实施容器安全策略的能力  

**下一步**: 进入高级特性模块，学习 CRIU、监控、构建自定义容器运行时等主题。