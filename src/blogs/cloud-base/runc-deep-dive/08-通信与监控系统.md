# 通信与监控系统

> **系列导航：** [runc 容器运行时深度解析系列](./README.md) → 第八篇：通信与监控系统  
> **上一篇：** [CRIU检查点与恢复](./07-CRIU检查点与恢复.md)  
> **最后更新：** 2024

## 概述

本文深入分析 runc 的通信机制和监控系统，包括进程间通信、事件通知、状态监控等功能。这些机制保障了容器的稳定运行和可管理性。

## 概述

runc的通信与监控系统是容器运行时的核心基础设施，负责进程间通信、事件处理、资源监控和日志管理。这个系统确保了容器生命周期中各个组件之间的协调配合，并提供了完整的可观测性支持。

## 1. 通信架构总览

### 1.1 多层通信模型

```
┌─────────────────────────────────────────────────────────────┐
│                     runc通信架构                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  主机进程                     容器进程                        │
│  ┌──────────┐               ┌──────────┐                   │
│  │   runc   │←─────────────→│   init   │                   │
│  │  parent  │  Unix Socket  │  process │                   │
│  └──────────┘               └──────────┘                   │
│       ↓                           ↓                         │
│  ┌──────────┐               ┌──────────┐                   │
│  │  Signal  │←─────────────→│ Container│                   │
│  │ Handler  │    Signals    │ Process  │                   │
│  └──────────┘               └──────────┘                   │
│       ↓                           ↓                         │
│  ┌──────────┐               ┌──────────┐                   │
│  │  Event   │←─────────────→│  Cgroups │                   │
│  │ Monitor  │    Events     │  Events  │                   │
│  └──────────┘               └──────────┘                   │
│                                                              │
│  通信通道:                                                   │
│  • Unix Domain Socket: 进程间控制消息                        │
│  • Sync Socket: 同步协调消息                                │
│  • Log Pipe: 日志转发管道                                   │
│  • Event FD: 事件通知机制                                   │
│  • Notify Socket: systemd集成                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心通信组件

```go
// libcontainer/process_linux.go
// 进程通信基础设施

type initProcess struct {
    cmd             *exec.Cmd
    messageSockPair filePair    // 消息通信套接字对
    logFilePair     filePair    // 日志管道对
    syncSocket      *syncSocket // 同步套接字
    container       *Container
    fds             []string    // 传递的文件描述符
    process         *Process
    bootstrapData   io.Reader   // 引导配置数据
}

// 文件对结构 - 用于进程间通信
type filePair struct {
    parent *os.File  // 父进程端
    child  *os.File  // 子进程端
}

// 创建通信通道
func (p *initProcess) createChannels() error {
    // 1. 创建消息套接字对
    sockPair, err := newFilePair("init-msg")
    if err != nil {
        return err
    }
    p.messageSockPair = sockPair
    
    // 2. 创建日志管道
    logPair, err := newFilePair("log-pipe")
    if err != nil {
        return err
    }
    p.logFilePair = logPair
    
    // 3. 创建同步套接字
    syncPair, err := newSyncSocketPair("sync")
    if err != nil {
        return err
    }
    p.syncSocket = syncPair.parent
    
    return nil
}
```

## 2. Socket通信机制

### 2.1 Unix Domain Socket实现

```go
// notify_socket.go
// systemd通知套接字实现

type notifySocket struct {
    socket     *net.UnixConn
    host       string       // 主机端地址
    socketPath string       // 套接字文件路径
}

// 创建通知套接字
func newNotifySocket(context *cli.Context, notifySocketHost string, id string) *notifySocket {
    // 生成唯一的套接字路径
    notifySocketPath := filepath.Join(context.String("root"), id, "notify.sock")
    
    // 创建Unix域套接字
    addr := net.UnixAddr{
        Name: notifySocketPath,
        Net:  "unixgram",  // 使用SOCK_DGRAM类型
    }
    
    socket, err := net.ListenUnixgram("unixgram", &addr)
    if err != nil {
        return nil
    }
    
    return &notifySocket{
        socket:     socket,
        host:       notifySocketHost,
        socketPath: notifySocketPath,
    }
}

// 处理systemd通知
func (n *notifySocket) run(pid1 int) error {
    // 设置环境变量供容器使用
    os.Setenv("NOTIFY_SOCKET", n.socketPath)
    
    go func() {
        buffer := make([]byte, 4096)
        for {
            // 接收通知消息
            num, _, err := n.socket.ReadFrom(buffer)
            if err != nil {
                break
            }
            
            // 解析sd_notify协议
            messages := bytes.Split(buffer[:num], []byte{'\n'})
            for _, msg := range messages {
                parts := bytes.SplitN(msg, []byte{'='}, 2)
                if len(parts) != 2 {
                    continue
                }
                
                switch string(parts[0]) {
                case "READY":
                    // 容器就绪通知
                    n.notifyHost("READY=1")
                    
                case "RELOADING":
                    // 容器重载中
                    n.notifyHost("RELOADING=1")
                    
                case "STOPPING":
                    // 容器停止中
                    n.notifyHost("STOPPING=1")
                    
                case "STATUS":
                    // 状态更新
                    n.notifyHost(fmt.Sprintf("STATUS=%s", parts[1]))
                    
                case "ERRNO":
                    // 错误码
                    n.notifyHost(fmt.Sprintf("ERRNO=%s", parts[1]))
                    
                case "MAINPID":
                    // 主进程PID更新
                    n.notifyHost(fmt.Sprintf("MAINPID=%d", pid1))
                    
                case "BARRIER":
                    // 同步屏障
                    n.handleBarrier()
                }
            }
        }
    }()
    
    return nil
}

// 处理BARRIER同步
func (n *notifySocket) handleBarrier() error {
    // BARRIER=1实现systemd同步
    // 等待systemd daemon准备就绪
    conn, err := net.Dial("unixgram", n.host)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    // 发送BARRIER=1
    _, err = conn.Write([]byte("BARRIER=1"))
    
    // 等待响应确认同步完成
    response := make([]byte, 1)
    conn.Read(response)
    
    return err
}
```

### 2.2 同步套接字实现

```go
// libcontainer/sync_unix.go
// 可靠的同步通信机制

type syncSocket struct {
    f      *os.File
    closed atomic.Bool
}

// 创建同步套接字对
func newSyncSocketPair(name string) (*syncSocket, *syncSocket, error) {
    // 使用SOCK_SEQPACKET确保消息边界和顺序
    fds, err := unix.Socketpair(unix.AF_UNIX, unix.SOCK_SEQPACKET|unix.SOCK_CLOEXEC, 0)
    if err != nil {
        return nil, nil, err
    }
    
    parent := &syncSocket{
        f: os.NewFile(uintptr(fds[0]), name+"-parent"),
    }
    child := &syncSocket{
        f: os.NewFile(uintptr(fds[1]), name+"-child"),
    }
    
    return parent, child, nil
}

// 发送同步消息
func (s *syncSocket) SendMessage(msg syncMessage) error {
    data, err := json.Marshal(msg)
    if err != nil {
        return err
    }
    
    // 原子性发送整个消息
    _, err = s.f.Write(data)
    return err
}

// 接收同步消息
func (s *syncSocket) ReceiveMessage() (*syncMessage, error) {
    // SOCK_SEQPACKET保证读取完整消息
    buf := make([]byte, 4096)
    n, err := s.f.Read(buf)
    if err != nil {
        return nil, err
    }
    
    var msg syncMessage
    err = json.Unmarshal(buf[:n], &msg)
    return &msg, err
}

// 传递文件描述符
func (s *syncSocket) SendFd(name string, fd uintptr) error {
    // 使用SCM_RIGHTS通过套接字传递文件描述符
    oob := unix.UnixRights(int(fd))
    data := []byte(name)
    
    _, _, err := unix.SendmsgN(
        int(s.f.Fd()),
        data,
        oob,
        nil,
        0,
    )
    return err
}

// 接收文件描述符
func (s *syncSocket) RecvFd() (*os.File, error) {
    buf := make([]byte, 256)
    oob := make([]byte, 256)
    
    n, oobn, _, _, err := unix.RecvmsgN(
        int(s.f.Fd()),
        buf,
        oob,
        0,
    )
    if err != nil {
        return nil, err
    }
    
    // 解析SCM_RIGHTS消息
    scms, err := unix.ParseSocketControlMessage(oob[:oobn])
    if err != nil {
        return nil, err
    }
    
    fds, err := unix.ParseUnixRights(&scms[0])
    if err != nil {
        return nil, err
    }
    
    name := string(buf[:n])
    return os.NewFile(uintptr(fds[0]), name), nil
}
```

## 3. 事件系统实现

### 3.1 事件类型定义

```go
// types/events.go
// 容器事件结构

type Event struct {
    Type string `json:"type"`
    ID   string `json:"id"`
    Data any    `json:"data,omitempty"`
}

// 统计事件数据
type Stats struct {
    CPU        CPU                `json:"cpu"`
    CPUs       map[string]CPU     `json:"cpus,omitempty"`
    Memory     Memory             `json:"memory"`
    Pids       Pids               `json:"pids"`
    Blkio      Blkio              `json:"blkio"`
    Hugetlb    map[string]Hugetlb `json:"hugetlb,omitempty"`
    IntelRdt   IntelRdt           `json:"intel_rdt,omitempty"`
    NetworkInterfaces []*NetworkInterface `json:"network_interfaces,omitempty"`
}

// OOM事件
type OOMEvent struct {
    ContainerID string    `json:"container_id"`
    Timestamp   time.Time `json:"timestamp"`
    Process     string    `json:"process"`
    PID         int       `json:"pid"`
}
```

### 3.2 OOM监控实现

```go
// libcontainer/notify_linux.go (cgroups v1)
// 内存压力和OOM事件监控

func registerMemoryEvent(dir string, eventName string, arg string) (<-chan struct{}, error) {
    // 创建eventfd用于事件通知
    eventfd, err := unix.Eventfd(0, unix.EFD_CLOEXEC)
    if err != nil {
        return nil, err
    }
    
    // 打开cgroup事件控制文件
    evtFile, err := os.Open(filepath.Join(dir, eventName))
    if err != nil {
        unix.Close(eventfd)
        return nil, err
    }
    defer evtFile.Close()
    
    // 注册事件监控
    eventControl, err := os.OpenFile(
        filepath.Join(dir, "cgroup.event_control"),
        os.O_WRONLY,
        0,
    )
    if err != nil {
        unix.Close(eventfd)
        return nil, err
    }
    defer eventControl.Close()
    
    // 写入格式: <eventfd> <target_fd> <args>
    data := fmt.Sprintf("%d %d %s", eventfd, evtFile.Fd(), arg)
    if _, err := eventControl.WriteString(data); err != nil {
        unix.Close(eventfd)
        return nil, err
    }
    
    // 创建通知通道
    ch := make(chan struct{})
    
    // 启动事件监听goroutine
    go func() {
        defer unix.Close(eventfd)
        defer close(ch)
        
        buf := make([]byte, 8)
        for {
            // 阻塞等待事件
            if _, err := unix.Read(eventfd, buf); err != nil {
                return
            }
            
            // 发送事件通知
            select {
            case ch <- struct{}{}:
            default:
                // 防止阻塞
            }
        }
    }()
    
    return ch, nil
}

// libcontainer/notify_v2_linux.go (cgroups v2)
// 使用inotify监控memory.events

func notifyOnOOMV2(path string) (<-chan struct{}, error) {
    // 创建inotify实例
    inotifyFd, err := unix.InotifyInit1(unix.IN_CLOEXEC)
    if err != nil {
        return nil, err
    }
    
    // 监控memory.events文件
    eventsFile := filepath.Join(path, "memory.events")
    wd, err := unix.InotifyAddWatch(inotifyFd, eventsFile, unix.IN_MODIFY)
    if err != nil {
        unix.Close(inotifyFd)
        return nil, err
    }
    
    ch := make(chan struct{})
    
    go func() {
        defer unix.Close(inotifyFd)
        defer close(ch)
        
        buf := make([]byte, 256)
        lastOOMKill := uint64(0)
        
        for {
            // 等待inotify事件
            n, err := unix.Read(inotifyFd, buf)
            if err != nil {
                return
            }
            
            // 解析inotify事件
            if n < unix.SizeofInotifyEvent {
                continue
            }
            
            // 读取memory.events内容
            data, err := os.ReadFile(eventsFile)
            if err != nil {
                continue
            }
            
            // 解析oom_kill计数
            lines := strings.Split(string(data), "\n")
            for _, line := range lines {
                fields := strings.Fields(line)
                if len(fields) == 2 && fields[0] == "oom_kill" {
                    count, _ := strconv.ParseUint(fields[1], 10, 64)
                    if count > lastOOMKill {
                        lastOOMKill = count
                        ch <- struct{}{}
                    }
                }
            }
        }
    }()
    
    return ch, nil
}
```

## 4. 日志系统

### 4.1 日志转发机制

```go
// libcontainer/logs/logs.go
// 容器日志转发系统

// 日志消息格式
type LogEntry struct {
    Level   string    `json:"level"`
    Msg     string    `json:"msg"`
    Time    time.Time `json:"time"`
    Source  string    `json:"source,omitempty"`
    Process string    `json:"process,omitempty"`
}

// 转发容器日志
func ForwardLogs(logPipe io.ReadCloser) chan error {
    done := make(chan error, 1)
    
    go func() {
        defer close(done)
        defer logPipe.Close()
        
        scanner := bufio.NewScanner(logPipe)
        scanner.Buffer(make([]byte, 65536), bufio.MaxScanTokenSize)
        
        for scanner.Scan() {
            line := scanner.Bytes()
            
            // 解析JSON格式的日志
            var entry LogEntry
            if err := json.Unmarshal(line, &entry); err != nil {
                // 非JSON格式，直接输出
                fmt.Fprintf(os.Stderr, "%s\n", line)
                continue
            }
            
            // 转换为logrus日志
            logger := logrus.WithFields(logrus.Fields{
                "source":  entry.Source,
                "process": entry.Process,
            })
            
            switch entry.Level {
            case "error":
                logger.Error(entry.Msg)
            case "warning":
                logger.Warning(entry.Msg)
            case "info":
                logger.Info(entry.Msg)
            case "debug":
                logger.Debug(entry.Msg)
            default:
                logger.Info(entry.Msg)
            }
        }
        
        if err := scanner.Err(); err != nil {
            done <- err
            return
        }
    }()
    
    return done
}

// 配置日志管道
func ConfigureLogging(config LogConfig) (*os.File, error) {
    // 创建日志管道
    logR, logW, err := os.Pipe()
    if err != nil {
        return nil, err
    }
    
    // 设置日志格式
    formatter := &logrus.JSONFormatter{
        TimestampFormat: time.RFC3339Nano,
    }
    
    // 配置日志级别
    level, err := logrus.ParseLevel(config.LogLevel)
    if err != nil {
        level = logrus.InfoLevel
    }
    
    logrus.SetLevel(level)
    logrus.SetFormatter(formatter)
    
    // 启动日志转发
    ForwardLogs(logR)
    
    return logW, nil
}
```

### 4.2 调试日志系统

```go
// 调试日志实现
type DebugLogger struct {
    enabled bool
    file    *os.File
    mu      sync.Mutex
}

func (d *DebugLogger) Debugf(format string, args ...interface{}) {
    if !d.enabled {
        return
    }
    
    d.mu.Lock()
    defer d.mu.Unlock()
    
    timestamp := time.Now().Format(time.RFC3339Nano)
    msg := fmt.Sprintf(format, args...)
    fmt.Fprintf(d.file, "[%s] DEBUG: %s\n", timestamp, msg)
}

// 跟踪关键操作
func traceOperation(op string, fn func() error) error {
    start := time.Now()
    debug.Debugf("Starting operation: %s", op)
    
    err := fn()
    
    duration := time.Since(start)
    if err != nil {
        debug.Debugf("Operation %s failed after %v: %v", op, duration, err)
    } else {
        debug.Debugf("Operation %s completed in %v", op, duration)
    }
    
    return err
}
```

## 5. 监控指标收集

### 5.1 CPU指标

```go
// CPU使用统计
func collectCPUStats(cg cgroups.Cgroup) (*CPU, error) {
    stats, err := cg.Stat()
    if err != nil {
        return nil, err
    }
    
    cpu := &CPU{
        Usage: CPUUsage{
            Total:  stats.CPU.Usage.Total,
            Kernel: stats.CPU.Usage.Kernel,
            User:   stats.CPU.Usage.User,
        },
        Throttling: Throttling{
            Periods:          stats.CPU.Throttling.Periods,
            ThrottledPeriods: stats.CPU.Throttling.ThrottledPeriods,
            ThrottledTime:    stats.CPU.Throttling.ThrottledTime,
        },
    }
    
    // 收集per-CPU统计
    if stats.CPU.Usage.PerCPU != nil {
        cpu.Usage.PerCPU = make([]uint64, len(stats.CPU.Usage.PerCPU))
        copy(cpu.Usage.PerCPU, stats.CPU.Usage.PerCPU)
    }
    
    return cpu, nil
}
```

### 5.2 内存指标

```go
// 内存使用统计
func collectMemoryStats(cg cgroups.Cgroup) (*Memory, error) {
    stats, err := cg.Stat()
    if err != nil {
        return nil, err
    }
    
    memory := &Memory{
        Cache:        stats.Memory.Cache,
        Usage:        MemoryEntry{
            Limit:   stats.Memory.Usage.Limit,
            Usage:   stats.Memory.Usage.Usage,
            MaxUsage: stats.Memory.Usage.Max,
            Failcnt: stats.Memory.Usage.Failcnt,
        },
        Swap:         MemoryEntry{
            Limit:   stats.Memory.Swap.Limit,
            Usage:   stats.Memory.Swap.Usage,
            MaxUsage: stats.Memory.Swap.Max,
            Failcnt: stats.Memory.Swap.Failcnt,
        },
        Kernel:       MemoryEntry{
            Limit:   stats.Memory.Kernel.Limit,
            Usage:   stats.Memory.Kernel.Usage,
            MaxUsage: stats.Memory.Kernel.Max,
            Failcnt: stats.Memory.Kernel.Failcnt,
        },
        KernelTCP:    MemoryEntry{
            Limit:   stats.Memory.KernelTCP.Limit,
            Usage:   stats.Memory.KernelTCP.Usage,
            MaxUsage: stats.Memory.KernelTCP.Max,
            Failcnt: stats.Memory.KernelTCP.Failcnt,
        },
        Raw:          stats.Memory.Raw,
    }
    
    return memory, nil
}
```

### 5.3 I/O指标

```go
// 块设备I/O统计
func collectBlkioStats(cg cgroups.Cgroup) (*Blkio, error) {
    stats, err := cg.Stat()
    if err != nil {
        return nil, err
    }
    
    blkio := &Blkio{}
    
    // 转换I/O服务字节数
    for _, entry := range stats.Blkio.IoServiceBytesRecursive {
        blkio.IoServiceBytesRecursive = append(
            blkio.IoServiceBytesRecursive,
            BlkioEntry{
                Major: entry.Major,
                Minor: entry.Minor,
                Op:    entry.Op,
                Value: entry.Value,
            },
        )
    }
    
    // 转换I/O服务操作数
    for _, entry := range stats.Blkio.IoServicedRecursive {
        blkio.IoServicedRecursive = append(
            blkio.IoServicedRecursive,
            BlkioEntry{
                Major: entry.Major,
                Minor: entry.Minor,
                Op:    entry.Op,
                Value: entry.Value,
            },
        )
    }
    
    return blkio, nil
}
```

## 6. 终端处理

### 6.1 TTY管理

```go
// tty.go
// 终端多路复用实现

type tty struct {
    epoller     *console.Epoller
    console     *console.EpollConsole  // 容器端控制台
    hostConsole console.Console         // 主机端控制台
    closers     []io.Closer
    postStart   []io.Closer
    wg          sync.WaitGroup
    consoleC    chan error
}

// 设置TTY
func setupTty(process *libcontainer.Process) (*tty, error) {
    // 创建控制台
    cons, err := console.New()
    if err != nil {
        return nil, err
    }
    
    // 设置为原始模式
    state, err := console.MakeRaw(cons)
    if err != nil {
        return nil, err
    }
    
    // 创建epoll实例用于I/O多路复用
    epoller, err := console.NewEpoller()
    if err != nil {
        return nil, err
    }
    
    // 创建容器端控制台
    epollConsole, err := epoller.Add(cons)
    if err != nil {
        return nil, err
    }
    
    t := &tty{
        epoller:     epoller,
        console:     epollConsole,
        hostConsole: cons,
        consoleC:    make(chan error, 1),
    }
    
    // 启动I/O复制
    go t.copyIO()
    
    // 处理窗口大小变化
    go t.handleResize()
    
    return t, nil
}

// I/O复制
func (t *tty) copyIO() {
    t.wg.Add(1)
    defer t.wg.Done()
    
    // 从容器控制台读取并写入主机
    go func() {
        io.Copy(os.Stdout, t.console)
    }()
    
    // 从主机读取并写入容器控制台
    go func() {
        io.Copy(t.console, os.Stdin)
    }()
    
    // 等待epoll事件
    for {
        events, err := t.epoller.Wait()
        if err != nil {
            t.consoleC <- err
            return
        }
        
        for _, event := range events {
            if event.Fd == t.console.Fd() {
                // 处理容器控制台事件
                if event.Events&unix.EPOLLIN != 0 {
                    // 有数据可读
                }
                if event.Events&unix.EPOLLHUP != 0 {
                    // 连接关闭
                    return
                }
            }
        }
    }
}

// 处理终端大小调整
func (t *tty) handleResize() {
    sigc := make(chan os.Signal, 1)
    signal.Notify(sigc, unix.SIGWINCH)
    
    for range sigc {
        // 获取新的终端大小
        size, err := console.GetWinsize(t.hostConsole.Fd())
        if err != nil {
            continue
        }
        
        // 设置容器控制台大小
        if err := console.SetWinsize(t.console.Fd(), size); err != nil {
            logrus.WithError(err).Error("failed to resize console")
        }
    }
}
```

## 7. 信号处理

### 7.1 信号转发

```go
// signals.go
// 信号处理和转发

type signalHandler struct {
    signals      chan os.Signal
    notifySocket *notifySocket
    container    libcontainer.Container
}

// 创建信号处理器
func newSignalHandler(notifySocket *notifySocket, container libcontainer.Container) *signalHandler {
    signals := make(chan os.Signal, 128) // 缓冲防止信号丢失
    
    // 注册所有信号
    signal.Notify(signals)
    
    return &signalHandler{
        signals:      signals,
        notifySocket: notifySocket,
        container:    container,
    }
}

// 信号转发循环
func (h *signalHandler) forward(process *libcontainer.Process) error {
    for sig := range h.signals {
        switch sig {
        case unix.SIGWINCH:
            // 终端大小变化，单独处理
            // 已在TTY处理器中处理
            
        case unix.SIGCHLD:
            // 子进程退出，收割僵尸进程
            for {
                var status unix.WaitStatus
                pid, err := unix.Wait4(-1, &status, unix.WNOHANG, nil)
                if err != nil || pid <= 0 {
                    break
                }
                
                // 记录子进程退出状态
                logrus.WithFields(logrus.Fields{
                    "pid":    pid,
                    "status": status.ExitStatus(),
                }).Debug("child process exited")
            }
            
        case unix.SIGTERM, unix.SIGINT:
            // 优雅终止信号
            logrus.Info("received termination signal")
            
            // 通知systemd
            if h.notifySocket != nil {
                h.notifySocket.notify("STOPPING=1")
            }
            
            // 转发给容器
            if err := process.Signal(sig); err != nil {
                logrus.WithError(err).Error("failed to forward signal")
            }
            
        case unix.SIGKILL:
            // 强制终止，不能被捕获，直接退出
            os.Exit(137) // 128 + 9
            
        case unix.SIGPIPE:
            // 忽略管道破裂信号
            
        default:
            // 转发其他信号给容器进程
            if err := process.Signal(sig); err != nil {
                logrus.WithError(err).WithField("signal", sig).
                    Error("failed to forward signal")
            }
        }
    }
    
    return nil
}

// 设置子进程收割器
func setupSubreaper() error {
    // 设置为子进程收割器，收养孤儿进程
    if err := unix.Prctl(unix.PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0); err != nil {
        return err
    }
    
    // 注册SIGCHLD处理
    sigc := make(chan os.Signal, 1)
    signal.Notify(sigc, unix.SIGCHLD)
    
    go func() {
        for range sigc {
            reapChildren()
        }
    }()
    
    return nil
}

// 收割僵尸进程
func reapChildren() {
    for {
        var status unix.WaitStatus
        pid, err := unix.Wait4(-1, &status, unix.WNOHANG, nil)
        if err != nil {
            if err != unix.EINTR {
                break
            }
            continue
        }
        if pid <= 0 {
            break
        }
        
        // 记录进程退出信息
        logrus.WithFields(logrus.Fields{
            "pid": pid,
            "exit_code": status.ExitStatus(),
            "signal": status.Signal(),
        }).Debug("reaped child process")
    }
}
```

## 8. 进程间同步

### 8.1 同步消息协议

```go
// libcontainer/sync.go
// 进程同步消息定义

type syncType string

const (
    procReady       syncType = "procReady"       // 进程准备就绪
    procRun         syncType = "procRun"         // 开始运行
    procHooks       syncType = "procHooks"       // 执行钩子
    procResume      syncType = "procResume"      // 恢复执行
    procSeccomp     syncType = "procSeccomp"     // 设置seccomp
    procMountPlease syncType = "procMountPlease" // 请求挂载
)

type syncMessage struct {
    Type syncType     `json:"type"`
    Fd   *int        `json:"fd,omitempty"`
    Data interface{} `json:"data,omitempty"`
}

// 父子进程同步流程
func parentChildSync(parent *syncSocket, child *syncSocket) error {
    // 1. 等待子进程准备就绪
    msg, err := parent.ReceiveMessage()
    if err != nil {
        return err
    }
    
    if msg.Type != procReady {
        return fmt.Errorf("unexpected message: %v", msg.Type)
    }
    
    // 2. 发送配置数据
    config := syncMessage{
        Type: procRun,
        Data: containerConfig,
    }
    
    if err := parent.SendMessage(config); err != nil {
        return err
    }
    
    // 3. 等待初始化完成
    msg, err = parent.ReceiveMessage()
    if err != nil {
        return err
    }
    
    if msg.Type == procMountPlease {
        // 子进程请求特权挂载操作
        performPrivilegedMount(msg.Data)
        
        // 发送完成确认
        reply := syncMessage{Type: procResume}
        parent.SendMessage(reply)
    }
    
    // 4. 等待seccomp设置
    msg, err = parent.ReceiveMessage()
    if err != nil {
        return err
    }
    
    if msg.Type == procSeccomp {
        // 传递seccomp配置文件描述符
        if msg.Fd != nil {
            parent.SendFd("seccomp", uintptr(*msg.Fd))
        }
    }
    
    // 5. 通知执行用户进程
    final := syncMessage{Type: procRun}
    return parent.SendMessage(final)
}
```

## 9. 实践练习

### 9.1 实现自定义事件监控

```go
// 自定义事件监控器
package main

import (
    "encoding/json"
    "fmt"
    "github.com/opencontainers/runc/libcontainer"
    "time"
)

type EventMonitor struct {
    container libcontainer.Container
    interval  time.Duration
    stopCh    chan struct{}
}

func NewEventMonitor(container libcontainer.Container) *EventMonitor {
    return &EventMonitor{
        container: container,
        interval:  time.Second,
        stopCh:    make(chan struct{}),
    }
}

func (m *EventMonitor) Start() {
    // 监控统计信息
    go m.monitorStats()
    
    // 监控OOM事件
    go m.monitorOOM()
    
    // 监控进程事件
    go m.monitorProcess()
}

func (m *EventMonitor) monitorStats() {
    ticker := time.NewTicker(m.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            stats, err := m.container.Stats()
            if err != nil {
                continue
            }
            
            event := Event{
                Type: "stats",
                ID:   m.container.ID(),
                Data: stats,
            }
            
            m.emitEvent(event)
            
        case <-m.stopCh:
            return
        }
    }
}

func (m *EventMonitor) monitorOOM() {
    oomCh, err := m.container.NotifyOOM()
    if err != nil {
        return
    }
    
    for {
        select {
        case <-oomCh:
            event := Event{
                Type: "oom",
                ID:   m.container.ID(),
                Data: map[string]interface{}{
                    "timestamp": time.Now(),
                    "message":   "Out of memory killed",
                },
            }
            
            m.emitEvent(event)
            
        case <-m.stopCh:
            return
        }
    }
}

func (m *EventMonitor) emitEvent(event Event) {
    data, _ := json.Marshal(event)
    fmt.Println(string(data))
}
```

### 9.2 实现日志聚合器

```go
// 日志聚合器实现
type LogAggregator struct {
    sources map[string]io.ReadCloser
    output  io.Writer
    mu      sync.Mutex
}

func NewLogAggregator(output io.Writer) *LogAggregator {
    return &LogAggregator{
        sources: make(map[string]io.ReadCloser),
        output:  output,
    }
}

func (la *LogAggregator) AddSource(name string, source io.ReadCloser) {
    la.mu.Lock()
    defer la.mu.Unlock()
    
    la.sources[name] = source
    
    // 启动日志收集
    go la.collectLogs(name, source)
}

func (la *LogAggregator) collectLogs(name string, source io.ReadCloser) {
    defer source.Close()
    
    scanner := bufio.NewScanner(source)
    for scanner.Scan() {
        line := scanner.Text()
        
        // 添加来源标识
        entry := LogEntry{
            Time:   time.Now(),
            Source: name,
            Msg:    line,
        }
        
        la.mu.Lock()
        json.NewEncoder(la.output).Encode(entry)
        la.mu.Unlock()
    }
}
```

### 9.3 实现通信调试工具

```go
// Socket通信调试工具
type SocketDebugger struct {
    socketPath string
    messages   []Message
    mu         sync.Mutex
}

func (sd *SocketDebugger) Intercept(original *syncSocket) *syncSocket {
    // 创建代理套接字
    parentSock, childSock, _ := newSyncSocketPair("debug")
    
    // 拦截并记录消息
    go func() {
        for {
            msg, err := childSock.ReceiveMessage()
            if err != nil {
                break
            }
            
            // 记录消息
            sd.recordMessage("recv", msg)
            
            // 转发给原始套接字
            original.SendMessage(*msg)
            
            // 接收响应
            reply, _ := original.ReceiveMessage()
            
            // 记录响应
            sd.recordMessage("send", reply)
            
            // 转发响应
            childSock.SendMessage(*reply)
        }
    }()
    
    return parentSock
}

func (sd *SocketDebugger) recordMessage(direction string, msg *syncMessage) {
    sd.mu.Lock()
    defer sd.mu.Unlock()
    
    record := Message{
        Timestamp: time.Now(),
        Direction: direction,
        Type:      string(msg.Type),
        Data:      msg.Data,
    }
    
    sd.messages = append(sd.messages, record)
    
    // 实时输出调试信息
    fmt.Printf("[%s] %s: %s %+v\n", 
        record.Timestamp.Format(time.RFC3339),
        direction,
        msg.Type,
        msg.Data,
    )
}

func (sd *SocketDebugger) DumpMessages() {
    sd.mu.Lock()
    defer sd.mu.Unlock()
    
    for _, msg := range sd.messages {
        data, _ := json.MarshalIndent(msg, "", "  ")
        fmt.Println(string(data))
    }
}
```

## 10. 故障排查

### 10.1 通信问题诊断

```bash
# 1. 检查Unix套接字
ls -la /run/runc/*/
# 查看notify.sock等套接字文件

# 2. 使用strace跟踪系统调用
strace -f -e trace=socket,connect,bind,sendmsg,recvmsg runc run container

# 3. 监控文件描述符
lsof -p $(pidof runc)

# 4. 查看进程间通信
# 使用ss查看Unix域套接字
ss -xp | grep runc

# 5. 调试日志级别
runc --debug --log-format json run container
```

### 10.2 事件监控调试

```go
// 事件监控调试工具
func debugEventSystem(container libcontainer.Container) {
    // 启用详细日志
    logrus.SetLevel(logrus.DebugLevel)
    
    // 监控所有文件描述符
    go func() {
        for {
            fds, _ := os.ReadDir(fmt.Sprintf("/proc/%d/fd", os.Getpid()))
            logrus.Debugf("Open FDs: %d", len(fds))
            time.Sleep(time.Second)
        }
    }()
    
    // 跟踪事件通道
    oomCh, _ := container.NotifyOOM()
    memCh, _ := container.NotifyMemoryPressure(MemoryPressureLevelLow)
    
    for {
        select {
        case <-oomCh:
            logrus.Debug("OOM event received")
        case <-memCh:
            logrus.Debug("Memory pressure event received")
        case <-time.After(5 * time.Second):
            logrus.Debug("No events in 5 seconds")
        }
    }
}
```

## 总结

runc的通信与监控系统展现了容器运行时的核心基础设施设计:

1. **多层通信架构**: Unix域套接字、同步套接字、管道等多种通信机制协同工作
2. **完整事件系统**: 从底层cgroups事件到高层应用事件的完整处理链
3. **强大监控能力**: CPU、内存、I/O、网络等全方位资源监控
4. **可靠日志系统**: 结构化日志转发和聚合机制
5. **精确进程同步**: 父子进程间的精确同步和协调
6. **灵活信号处理**: 完善的信号转发和处理机制

通过掌握这些通信和监控机制，我们能够构建可观测、可调试、高可靠的容器运行时系统。