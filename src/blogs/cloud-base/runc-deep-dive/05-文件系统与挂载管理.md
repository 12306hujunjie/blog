# æ–‡ä»¶ç³»ç»Ÿä¸æŒ‚è½½ç®¡ç†

> **ç³»åˆ—å¯¼èˆªï¼š** [runc å®¹å™¨è¿è¡Œæ—¶æ·±åº¦è§£æç³»åˆ—](./README.md) â†’ ç¬¬äº”ç¯‡ï¼šæ–‡ä»¶ç³»ç»Ÿä¸æŒ‚è½½ç®¡ç†  
> **ä¸Šä¸€ç¯‡ï¼š** [Cgroupsèµ„æºç®¡ç†](./04-Cgroupsèµ„æºç®¡ç†.md)  
> **æœ€åæ›´æ–°ï¼š** 2024

## æ¦‚è¿°

æœ¬æ–‡æ·±å…¥åˆ†æ runc å¦‚ä½•ç®¡ç†å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿå’ŒæŒ‚è½½ç‚¹ã€‚åŒ…æ‹¬ rootfs çš„å‡†å¤‡å’Œåˆ‡æ¢ã€æŒ‚è½½ç‚¹çš„åˆ›å»ºå’Œç®¡ç†ï¼Œä»¥åŠæŒ‚è½½ä¼ æ’­ç­‰é«˜çº§ç‰¹æ€§ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ¨¡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- æ·±å…¥ç†è§£å®¹å™¨ rootfs å‡†å¤‡å’Œåˆ‡æ¢çš„å®Œæ•´æœºåˆ¶
- æŒæ¡ runc ä¸­å„ç§æŒ‚è½½ç±»å‹çš„å¤„ç†é€»è¾‘å’Œå®‰å…¨ç­–ç•¥
- ç†è§£ Mount Namespace ä¸æ–‡ä»¶ç³»ç»Ÿéš”ç¦»çš„å®ç°åŸç†
- ç†Ÿæ‚‰ bind mountã€overlayã€ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿçš„åº”ç”¨åœºæ™¯
- å…·å¤‡æ’æŸ¥å®¹å™¨æ–‡ä»¶ç³»ç»Ÿé—®é¢˜å’Œä¼˜åŒ–æŒ‚è½½é…ç½®çš„èƒ½åŠ›

## 1. å®¹å™¨æ–‡ä»¶ç³»ç»ŸåŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å®¹å™¨æ–‡ä»¶ç³»ç»Ÿï¼Ÿ

å®¹å™¨æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸ºå®¹å™¨è¿›ç¨‹æä¾›éš”ç¦»æ–‡ä»¶è§†å›¾çš„æ ¸å¿ƒæœºåˆ¶ã€‚å®ƒé€šè¿‡ **rootfs åˆ‡æ¢** + **æŒ‚è½½ç®¡ç†** + **æ–‡ä»¶ç³»ç»Ÿéš”ç¦»** å®ç°å®Œæ•´çš„æ–‡ä»¶ç³»ç»Ÿè™šæ‹ŸåŒ–ã€‚

```
å®¿ä¸»æœºæ–‡ä»¶ç³»ç»Ÿ                   å®¹å™¨æ–‡ä»¶ç³»ç»Ÿè§†å›¾
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ /                   â”‚   å˜æ¢   â”‚ /                   â”‚
â”‚ â”œâ”€â”€ bin/            â”‚  â”€â”€â”€â”€â†’  â”‚ â”œâ”€â”€ bin/            â”‚ (æ¥è‡ªé•œåƒ)
â”‚ â”œâ”€â”€ etc/            â”‚         â”‚ â”œâ”€â”€ etc/            â”‚ (æ¥è‡ªé•œåƒ)
â”‚ â”œâ”€â”€ home/           â”‚         â”‚ â”œâ”€â”€ home/           â”‚ (æ¥è‡ªæŒ‚è½½)
â”‚ â”œâ”€â”€ proc/           â”‚         â”‚ â”œâ”€â”€ proc/           â”‚ (å®¹å™¨proc)
â”‚ â””â”€â”€ var/containers/ â”‚         â”‚ â”œâ”€â”€ tmp/            â”‚ (tmpfs)
â”‚     â””â”€â”€ rootfs/     â”‚         â”‚ â””â”€â”€ dev/            â”‚ (è®¾å¤‡èŠ‚ç‚¹)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      å®¿ä¸»æœºè§†å›¾                      å®¹å™¨å†…è§†å›¾
```

**æ ¸å¿ƒç»„ä»¶**ï¼š
- ğŸ  **Rootfs**: å®¹å™¨çš„æ ¹æ–‡ä»¶ç³»ç»Ÿï¼Œé€šå¸¸æ¥è‡ªé•œåƒ
- ğŸ”— **Bind Mounts**: å°†å®¿ä¸»æœºç›®å½•æ˜ å°„åˆ°å®¹å™¨å†…
- ğŸ’¾ **Tmpfs**: ä¸´æ—¶å†…å­˜æ–‡ä»¶ç³»ç»Ÿ
- âš™ï¸ **Special FS**: procã€sysã€dev ç­‰ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿ

### 1.2 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              åº”ç”¨è¿›ç¨‹è§†å›¾                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           å®¹å™¨æŒ‚è½½å‘½åç©ºé—´                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚          /                              â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ bin/ (æ¥è‡ªé•œåƒå±‚)                  â”‚    â”‚ 
â”‚  â”‚  â”œâ”€â”€ etc/ (æ¥è‡ªé•œåƒå±‚)                  â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ proc/ (å®¹å™¨ä¸“å±procfs)             â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ tmp/ (tmpfså†…å­˜æ–‡ä»¶ç³»ç»Ÿ)           â”‚    â”‚
â”‚  â”‚  â””â”€â”€ app/ (bind mountå®¿ä¸»æœºç›®å½•)        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                å®¿ä¸»æœºå†…æ ¸                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  çœŸå®æ–‡ä»¶ç³»ç»Ÿ   â”‚   è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ (VFS)   â”‚   â”‚
â”‚  â”‚   (ext4/xfs)    â”‚   (proc/sys/tmpfs)     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. Rootfs å‡†å¤‡å’Œåˆ‡æ¢æœºåˆ¶

### 2.1 æ•´ä½“æµç¨‹æ¶æ„

runc çš„æ–‡ä»¶ç³»ç»Ÿåˆå§‹åŒ–éµå¾ª **å‡†å¤‡** â†’ **æŒ‚è½½** â†’ **åˆ‡æ¢** â†’ **åŠ å›º** çš„å››é˜¶æ®µæµç¨‹ï¼š

```
ç”¨æˆ·æ‰§è¡Œ: runc create mycontainer
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ1: prepareRoot - æ ¹æŒ‚è½½ç‚¹é¢„å¤„ç†            â”‚
â”‚  - è®¾ç½®æŒ‚è½½ä¼ æ’­å±æ€§                             â”‚
â”‚  - ç¡®ä¿çˆ¶æŒ‚è½½ç‚¹ç§æœ‰åŒ–                           â”‚
â”‚  - è‡ªç»‘å®šrootfså‡†å¤‡pivot_root                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ2: prepareRootfs - æŒ‚è½½å¤„ç†                â”‚
â”‚  - å¤„ç†æ‰€æœ‰OCIé…ç½®çš„æŒ‚è½½ç‚¹                      â”‚
â”‚  - åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹å’Œç¬¦å·é“¾æ¥                       â”‚
â”‚  - å¤„ç†ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿ(proc/sys/cgroup)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ3: pivotRoot/msMoveRoot - æ ¹æ–‡ä»¶ç³»ç»Ÿåˆ‡æ¢   â”‚
â”‚  - pivot_root(): æ ‡å‡†åˆ‡æ¢æ–¹å¼                   â”‚
â”‚  - MS_MOVE: --no-pivot-root é€‰é¡¹               â”‚
â”‚  - chroot(): ä¼ ç»Ÿæ–¹å¼(æ— mount namespace)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ4: finalizeRootfs - å®‰å…¨åŠ å›º               â”‚
â”‚  - é‡æ–°æŒ‚è½½tmpfs/devä¸ºåªè¯»                      â”‚
â”‚  - è®¾ç½®æ ¹æ–‡ä»¶ç³»ç»Ÿåªè¯»                           â”‚
â”‚  - åº”ç”¨umaskæƒé™è®¾ç½®                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 prepareRoot - æ ¹æŒ‚è½½ç‚¹é¢„å¤„ç†

```go
// libcontainer/rootfs_linux.go:97
func prepareRoot(config *configs.Config) error {
    // 1. è®¾ç½®æ ¹æŒ‚è½½ä¼ æ’­å±æ€§
    flag := unix.MS_SLAVE | unix.MS_REC  // é»˜è®¤ä¸ºslaveé€’å½’
    if config.RootPropagation != 0 {
        flag = config.RootPropagation    // ç”¨æˆ·è‡ªå®šä¹‰ä¼ æ’­å±æ€§
    }
    
    // åœ¨æ ¹ç›®å½•ä¸Šåº”ç”¨ä¼ æ’­å±æ€§
    if err := mount("", "/", "", uintptr(flag), ""); err != nil {
        return fmt.Errorf("failed to set root mount propagation: %w", err)
    }
    
    // 2. ç¡®ä¿rootfsçˆ¶æŒ‚è½½ç‚¹æ˜¯ç§æœ‰çš„
    if err := rootfsParentMountPrivate(config.Rootfs); err != nil {
        return err
    }
    
    // 3. é€’å½’ç»‘å®šæŒ‚è½½rootfsåˆ°è‡ªèº«ï¼Œä¸ºpivot_rootåšå‡†å¤‡
    // è¿™ä¸€æ­¥æ˜¯å…³é”®ï¼šä½¿rootfsæˆä¸ºç‹¬ç«‹çš„æŒ‚è½½ç‚¹
    return mount(config.Rootfs, config.Rootfs, "bind", 
                unix.MS_BIND|unix.MS_REC, "")
}
```

**æŒ‚è½½ä¼ æ’­å±æ€§è§£é‡Š**ï¼š

| ä¼ æ’­ç±»å‹ | å«ä¹‰ | åº”ç”¨åœºæ™¯ |
|----------|------|----------|
| **MS_PRIVATE** | ç§æœ‰ï¼ŒæŒ‚è½½ä¸ä¼ æ’­ | å®Œå…¨éš”ç¦»å®¹å™¨æŒ‚è½½ |
| **MS_SLAVE** | ä»å±ï¼Œåªæ¥æ”¶ä¸å‘é€ | æ¥æ”¶å®¿ä¸»æœºæŒ‚è½½ï¼Œä½†ä¸å½±å“å®¿ä¸»æœº |
| **MS_SHARED** | å…±äº«ï¼ŒåŒå‘ä¼ æ’­ | å®¹å™¨ä¸å®¿ä¸»æœºå…±äº«æŒ‚è½½å˜æ›´ |
| **MS_UNBINDABLE** | ä¸å¯ç»‘å®š | é˜²æ­¢æŒ‚è½½ç‚¹è¢«bind |

### 2.3 ä¸‰ç§æ ¹æ–‡ä»¶ç³»ç»Ÿåˆ‡æ¢æ–¹å¼

#### A. pivot_root æ–¹å¼ (æ ‡å‡†æ–¹å¼)

```go
// libcontainer/rootfs_linux.go:128
func pivotRoot(rootfs string) error {
    // æ‰“å¼€æ—§æ ¹å’Œæ–°æ ¹çš„æ–‡ä»¶æè¿°ç¬¦
    oldroot, err := linux.Open("/", unix.O_DIRECTORY|unix.O_RDONLY, 0)
    if err != nil {
        return err
    }
    defer oldroot.Close()
    
    newroot, err := linux.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)
    if err != nil {
        return err
    }
    defer newroot.Close()
    
    // åˆ‡æ¢åˆ°æ–°æ ¹ç›®å½•
    if err := unix.Fchdir(int(newroot.Fd())); err != nil {
        return err
    }
    
    // æ‰§è¡Œpivot_rootç³»ç»Ÿè°ƒç”¨
    // æŠ€å·§ï¼špivot_root(".", ".") - æ¥è‡ªLXCå¼€å‘è€…çš„æ™ºæ…§
    if err := unix.PivotRoot(".", "."); err != nil {
        return fmt.Errorf("pivot_root failed: %w", err)
    }
    
    // è®¾ç½®æ—§æ ¹ä¸ºslaveï¼Œé˜²æ­¢æŒ‚è½½ä¼ æ’­åˆ°å®¿ä¸»æœº
    if err := mount("", ".", "", unix.MS_SLAVE|unix.MS_REC, ""); err != nil {
        return err
    }
    
    // åˆ†ç¦»å¸è½½æ—§æ ¹
    if err := unmount(".", unix.MNT_DETACH); err != nil {
        return err
    }
    
    // åˆ‡æ¢å·¥ä½œç›®å½•åˆ°æ–°æ ¹
    return unix.Chdir("/")
}
```

**pivot_root å·¥ä½œåŸç†**ï¼š

```
æ‰§è¡Œå‰:                        æ‰§è¡Œå:
å®¿ä¸»æœºæ ¹ (/)                   å®¹å™¨æ ¹ (/)
â”œâ”€â”€ bin/                      â”œâ”€â”€ bin/         (æ¥è‡ªé•œåƒ)
â”œâ”€â”€ etc/                      â”œâ”€â”€ etc/         (æ¥è‡ªé•œåƒ)
â””â”€â”€ containers/               â”œâ”€â”€ tmp/         (tmpfs)
    â””â”€â”€ rootfs/               â””â”€â”€ proc/        (å®¹å™¨procfs)
        â”œâ”€â”€ bin/
        â”œâ”€â”€ etc/
        â””â”€â”€ tmp/
        
pivot_root(rootfs, oldroot) å°†:
- rootfs å˜æˆæ–°çš„æ ¹ç›®å½• /
- åŸæ¥çš„æ ¹ç›®å½•è¢«ç§»åˆ° oldroot ä½ç½®
- ç„¶åå¸è½½ oldrootï¼Œå®Œæˆåˆ‡æ¢
```

#### B. MS_MOVE æ–¹å¼ (--no-pivot-root)

```go
// libcontainer/rootfs_linux.go:185
func msMoveRoot(rootfs string) error {
    // å…ˆå¤„ç†æ½œåœ¨çš„å®‰å…¨é£é™©ï¼šå±è”½å±é™©çš„procfså’ŒsysfsæŒ‚è½½
    mountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {
        // è¿‡æ»¤æ¡ä»¶ï¼šæ ¹ç›®å½•ã€proc/sysæ–‡ä»¶ç³»ç»Ÿã€ä¸åœ¨rootfså†…éƒ¨çš„æŒ‚è½½
        if info.Root != "/" || 
           (info.FSType != "proc" && info.FSType != "sysfs") ||
           strings.HasPrefix(info.Mountpoint, rootfs) {
            skip = true
        }
        return
    })
    
    // å¸è½½æˆ–è¦†ç›–å±é™©æŒ‚è½½ç‚¹
    for _, info := range mountinfos {
        // è®¾ç½®ä¸ºslaveé˜²æ­¢ä¼ æ’­
        mount("", info.Mountpoint, "", unix.MS_SLAVE|unix.MS_REC, "")
        
        if err := unmount(info.Mountpoint, unix.MNT_DETACH); err != nil {
            // å¦‚æœæ— æ³•å¸è½½ï¼Œç”¨tmpfsè¦†ç›–
            if err := mount("tmpfs", info.Mountpoint, "tmpfs", 0, ""); err != nil {
                return fmt.Errorf("failed to mask %s: %w", info.Mountpoint, err)
            }
        }
    }
    
    // å°†rootfsç§»åŠ¨åˆ°æ ¹ä½ç½®
    if err := mount(rootfs, "/", "", unix.MS_MOVE, ""); err != nil {
        return fmt.Errorf("failed to move %s to /: %w", rootfs, err)
    }
    
    // æ‰§è¡Œchrootå®Œæˆåˆ‡æ¢
    return chroot()
}
```

#### C. chroot æ–¹å¼ (ä¼ ç»Ÿæ–¹å¼)

```go
func chroot() error {
    // ç®€å•çš„chrootç³»ç»Ÿè°ƒç”¨
    if err := unix.Chroot("."); err != nil {
        return err
    }
    return unix.Chdir("/")
}
```

**ä¸‰ç§æ–¹å¼å¯¹æ¯”**ï¼š

| æ–¹å¼ | ä½¿ç”¨åœºæ™¯ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|----------|------|------|
| **pivot_root** | æœ‰mount namespace | å®‰å…¨æ€§æœ€é«˜ï¼Œå®Œå…¨éš”ç¦» | éœ€è¦mount namespace |
| **MS_MOVE** | --no-pivot-rootæ ‡å¿— | å…¼å®¹æ€§å¥½ | éœ€è¦é¢å¤–å®‰å…¨å¤„ç† |
| **chroot** | æ— mount namespace | ç®€å•å…¼å®¹ | å®‰å…¨æ€§è¾ƒä½ï¼Œå¯èƒ½é€ƒé€¸ |

## 3. æŒ‚è½½ç±»å‹å’Œå¤„ç†æœºåˆ¶

### 3.1 æŒ‚è½½åˆ†å‘å™¨ - mountToRootfs

runc æ ¹æ®ä¸åŒçš„è®¾å¤‡ç±»å‹é‡‡ç”¨ä¸“é—¨çš„å¤„ç†é€»è¾‘ï¼š

```go
// libcontainer/rootfs_linux.go:566
func mountToRootfs(c *mountConfig, m mountEntry) error {
    switch m.Device {
    case "proc", "sysfs":
        // ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿéœ€è¦å®‰å…¨æ£€æŸ¥
        if err := checkProcMount(rootfs, dest, m); err != nil {
            return err
        }
        return mountPropagate(m, rootfs, "")
        
    case "mqueue":
        // æ¶ˆæ¯é˜Ÿåˆ—æ–‡ä»¶ç³»ç»Ÿ
        if err := mountPropagate(m, rootfs, ""); err != nil {
            return err
        }
        return label.SetFileLabel(dest, mountLabel)  // SELinuxæ ‡ç­¾
        
    case "tmpfs":
        // tmpfsæ”¯æŒcopyupæ‰©å±•
        if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {
            return doTmpfsCopyUp(m, rootfs, mountLabel)
        }
        return mountPropagate(m, rootfs, mountLabel)
        
    case "bind":
        // bindæŒ‚è½½éœ€è¦ç‰¹æ®Šçš„æ ‡å¿—å¤„ç†
        return handleBindMount(m, rootfs, mountLabel)
        
    case "cgroup":
        // cgroupæ–‡ä»¶ç³»ç»Ÿåˆ†ç‰ˆæœ¬å¤„ç†
        if cgroups.IsCgroup2UnifiedMode() {
            return mountCgroupV2(m.Mount, c)
        }
        return mountCgroupV1(m.Mount, c)
        
    default:
        // å…¶ä»–æ ‡å‡†æ–‡ä»¶ç³»ç»Ÿ
        return mountPropagate(m, rootfs, mountLabel)
    }
}
```

### 3.2 bind æŒ‚è½½çš„å¤æ‚å¤„ç†

bind æŒ‚è½½æ˜¯æœ€å¤æ‚çš„æŒ‚è½½ç±»å‹ï¼Œå› ä¸ºéœ€è¦å¤„ç† **locked flags** é—®é¢˜ï¼š

```go
func handleBindMount(m mountEntry, rootfs, mountLabel string) error {
    // 1. æ‰§è¡ŒåŸºç¡€bindæŒ‚è½½
    flags := m.Flags | unix.MS_BIND
    if err := mountViaFds(m.Source, m.srcFile, m.Destination, dstFd, 
                         "", uintptr(flags&^unix.MS_REC), m.Data); err != nil {
        return err
    }
    
    // 2. å¤„ç†é€’å½’ç»‘å®š
    if m.Flags&unix.MS_REC == unix.MS_REC {
        if err := mountViaFds(m.Source, m.srcFile, m.Destination, dstFd, 
                             "", uintptr(flags), m.Data); err != nil {
            return err
        }
    }
    
    // 3. é‡æ–°åº”ç”¨æŒ‚è½½æ ‡å¿— (è¿™æ˜¯å…³é”®æ­¥éª¤!)
    // bindæŒ‚è½½åéœ€è¦å•ç‹¬çš„remountæ¥åº”ç”¨ro/nosuidç­‰æ ‡å¿—
    if m.Flags&^(unix.MS_BIND|unix.MS_REC|unix.MS_REMOUNT) != 0 || m.ClearedFlags != 0 {
        flags := m.Flags | unix.MS_BIND | unix.MS_REMOUNT
        
        // å°è¯•ç›´æ¥è®¾ç½®æ ‡å¿—
        if err := mountViaFds("", nil, m.Destination, dstFd, 
                             "", uintptr(flags), ""); err == nil {
            return nil
        }
        
        // å¦‚æœå¤±è´¥ï¼Œå¯èƒ½å­˜åœ¨locked flags
        // éœ€è¦è·å–æºæ–‡ä»¶ç³»ç»Ÿçš„å½“å‰æ ‡å¿—
        st, err := m.srcStatfs()
        if err != nil {
            return err
        }
        
        srcFlags := statfsToMountFlags(*st)  // ä»statfsè½¬æ¢ä¸ºmountæ ‡å¿—
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æ— æ³•æ¸…é™¤çš„locked flags
        lockedFlags := srcFlags & m.ClearedFlags & mntLockFlags
        if lockedFlags != 0 {
            return fmt.Errorf("cannot clear locked mount flags: %s", 
                             stringifyMountFlags(lockedFlags))
        }
        
        // é‡æ–°åº”ç”¨ï¼ŒåŒ…å«locked flags
        flags |= srcFlags & mntLockFlags
        return mountViaFds("", nil, m.Destination, dstFd, 
                          "", uintptr(flags), "")
    }
    
    return nil
}
```

**locked flags é—®é¢˜è§£é‡Š**ï¼š

æŸäº›æŒ‚è½½æ ‡å¿—åœ¨æºæ–‡ä»¶ç³»ç»Ÿä¸Šå¯èƒ½æ˜¯"é”å®š"çš„ï¼Œæ— æ³•é€šè¿‡remountæ¸…é™¤ï¼š

```bash
# ä¾‹å¦‚ï¼šæºæ–‡ä»¶ç³»ç»Ÿæ˜¯åªè¯»çš„ (MS_RDONLY)
$ mount | grep /source
/dev/sda1 on /source type ext4 (ro,noatime)

# bindæŒ‚è½½åï¼Œæ— æ³•å°†å…¶æ”¹ä¸ºå¯å†™
$ mount --bind /source /target
$ mount -o remount,rw /target  # è¿™ä¼šå¤±è´¥ï¼

# runcçš„è§£å†³æ–¹æ¡ˆï¼šæ£€æµ‹locked flagså¹¶ä¿æŒå®ƒä»¬
```

### 3.3 æ–°ç‰ˆæŒ‚è½½APIæ”¯æŒ

runc æ”¯æŒ Linux 5.2+ çš„æ–°ç‰ˆæŒ‚è½½APIï¼Œä¸»è¦ç”¨äº **idmapped mounts**ï¼š

```go
// libcontainer/mount_linux.go:242
func mountFd(nsHandles *userns.Handles, m *configs.Mount) (*mountSource, error) {
    if m.IsIDMapped() {
        // ä½¿ç”¨open_tree()åˆ›å»ºæŒ‚è½½æ–‡ä»¶æè¿°ç¬¦
        flags := uint(unix.OPEN_TREE_CLONE | unix.OPEN_TREE_CLOEXEC)
        if m.Flags&unix.MS_REC == unix.MS_REC {
            flags |= unix.AT_RECURSIVE
        }
        
        fd, err := unix.OpenTree(unix.AT_FDCWD, m.Source, flags)
        if err != nil {
            return nil, fmt.Errorf("open_tree(%s): %w", m.Source, err)
        }
        
        mountFile := os.NewFile(uintptr(fd), m.Source)
        
        // è·å–ç”¨æˆ·å‘½åç©ºé—´æ–‡ä»¶æè¿°ç¬¦
        usernsFile, err := nsHandles.Get(userns.Mapping{
            UIDMappings: m.IDMapping.UIDMappings,
            GIDMappings: m.IDMapping.GIDMappings,
        })
        if err != nil {
            return nil, err
        }
        
        // åº”ç”¨idmapå±æ€§
        attr := &unix.MountAttr{
            Attr_set:  unix.MOUNT_ATTR_IDMAP,
            Userns_fd: uint64(usernsFile.Fd()),
        }
        
        if err := unix.MountSetattr(int(mountFile.Fd()), "", 
                                   unix.AT_EMPTY_PATH, attr); err != nil {
            return nil, fmt.Errorf("mount_setattr(idmap): %w", err)
        }
        
        return &mountSource{Type: mountSourceOpenTree, file: mountFile}, nil
    }
    
    // æ™®é€šbindæŒ‚è½½ä½¿ç”¨O_PATH
    mountFile, err := os.OpenFile(m.Source, unix.O_PATH|unix.O_CLOEXEC, 0)
    if err != nil {
        return nil, err
    }
    
    return &mountSource{Type: mountSourcePlain, file: mountFile}, nil
}
```

**idmapped mounts çš„ä¼˜åŠ¿**ï¼š
- ğŸ” **æƒé™æ˜ å°„**: æ–‡ä»¶ç³»ç»Ÿå†…çš„ UID/GID å¯ä»¥æ˜ å°„åˆ°ä¸åŒçš„ç”¨æˆ·å‘½åç©ºé—´
- ğŸ”’ **å®‰å…¨æ€§**: æ— éœ€ chown å°±èƒ½æ”¹å˜æ–‡ä»¶æ‰€æœ‰æƒè§†å›¾
- âš¡ **æ€§èƒ½**: é¿å…å¤åˆ¶æ–‡ä»¶ï¼Œç›´æ¥æ˜ å°„æƒé™

## 4. ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿå¤„ç†

### 4.1 /proc æ–‡ä»¶ç³»ç»Ÿå®‰å…¨æ£€æŸ¥

proc æ–‡ä»¶ç³»ç»ŸåŒ…å«æ•æ„Ÿçš„ç³»ç»Ÿä¿¡æ¯ï¼Œrunc å®ç°äº†ä¸¥æ ¼çš„å®‰å…¨æ£€æŸ¥ï¼š

```go
// libcontainer/rootfs_linux.go:790
func checkProcMount(rootfs, dest string, m mountEntry) error {
    // è®¡ç®—ç›¸å¯¹äº/procçš„è·¯å¾„
    path, err := filepath.Rel(filepath.Join(rootfs, "/proc"), dest)
    if err != nil {
        return err
    }
    
    if path == "." {
        // åœ¨/procæ ¹ç›®å½•ä¸Šçš„æŒ‚è½½
        if m.IsBind() {
            // bindæŒ‚è½½å¿…é¡»æ˜¯çœŸæ­£çš„procfs
            fsStat, err := m.srcStatfs()
            if err != nil {
                return err
            }
            
            if fsStat.Type != unix.PROC_SUPER_MAGIC {
                return fmt.Errorf("bind mount %s is not procfs", dest)
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºprocfsæ ¹èŠ‚ç‚¹ (inode == 1)
            if _, uStat, err := m.srcStat(); err == nil {
                const procRootIno = 1
                if uStat.Ino != procRootIno {
                    logrus.Warnf("bind-mount %s is not procfs root (inode %d)", 
                               dest, uStat.Ino)
                }
            }
            return nil
        } else if m.Device == "proc" {
            return nil  // æ–°çš„procfsæŒ‚è½½æ€»æ˜¯å®‰å…¨çš„
        }
        
        return fmt.Errorf("%s cannot be mounted: not procfs", dest)
    }
    
    // /procå­è·¯å¾„ï¼šåªå…è®¸ç‰¹å®šçš„ç™½åå•è·¯å¾„
    validProcMounts := []string{
        "/proc/cpuinfo", "/proc/diskstats", "/proc/meminfo",
        "/proc/stat", "/proc/swaps", "/proc/uptime", "/proc/loadavg",
        "/proc/sys/kernel/ns_last_pid",
        "/proc/sys/crypto/fips_enabled",
        // æ›´å¤šå®‰å…¨çš„procè·¯å¾„...
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå…è®¸çš„è·¯å¾„
    for _, validPath := range validProcMounts {
        if filepath.Clean(dest) == validPath {
            return nil
        }
    }
    
    return fmt.Errorf("%s cannot be mounted inside /proc: not in whitelist", dest)
}
```

### 4.2 cgroup æ–‡ä»¶ç³»ç»Ÿå¤„ç†

#### Cgroups v1 å¤„ç†

```go
func mountCgroupV1(m *configs.Mount, c *mountConfig) error {
    // è·å–ç³»ç»Ÿä¸­çš„cgroupæŒ‚è½½ç‚¹
    binds, err := getCgroupMounts(m)
    if err != nil {
        return err
    }
    
    // åˆ›å»ºtmpfsä½œä¸ºcgroupæ ¹æŒ‚è½½ç‚¹
    tmpfs := &configs.Mount{
        Source:      "tmpfs",
        Device:      "tmpfs",
        Destination: m.Destination,
        Flags:       defaultMountFlags,
        Data:        "mode=755,size=65536k",
    }
    
    if err := mountToRootfs(c, mountEntry{Mount: tmpfs}); err != nil {
        return err
    }
    
    // ä¸ºæ¯ä¸ªcgroupå­ç³»ç»Ÿåˆ›å»ºæŒ‚è½½ç‚¹
    for _, b := range binds {
        if c.cgroupns {
            // cgroupå‘½åç©ºé—´æ¨¡å¼ï¼šç›´æ¥æŒ‚è½½cgroupæ–‡ä»¶ç³»ç»Ÿ
            subsystemName := strings.Join(b.Subsystems, ",")
            if err := mountViaFds("cgroup", nil, b.Destination, dstFd, 
                                 "cgroup", uintptr(b.Flags), subsystemName); err != nil {
                return fmt.Errorf("failed to mount cgroup %s: %w", 
                                 subsystemName, err)
            }
        } else {
            // éå‘½åç©ºé—´æ¨¡å¼ï¼šbindæŒ‚è½½å®¿ä¸»æœºcgroupè·¯å¾„
            if err := mountToRootfs(c, mountEntry{Mount: b}); err != nil {
                return err
            }
        }
    }
    
    return nil
}
```

#### Cgroups v2 å¤„ç†

```go
func mountCgroupV2(m *configs.Mount, c *mountConfig) error {
    // å°è¯•ç›´æ¥æŒ‚è½½cgroup2æ–‡ä»¶ç³»ç»Ÿ
    err := mountViaFds(m.Source, nil, m.Destination, dstFd, 
                      "cgroup2", uintptr(m.Flags), m.Data)
    
    if err == nil || (!errors.Is(err, unix.EPERM) && !errors.Is(err, unix.EBUSY)) {
        return err
    }
    
    // æƒé™ä¸è¶³æ—¶é™çº§ä¸ºbindæŒ‚è½½
    bindMount := &configs.Mount{
        Device:      "bind",
        Source:      fs2.UnifiedMountpoint,  // /sys/fs/cgroup
        Destination: m.Destination,
        Flags:       unix.MS_BIND | m.Flags,
    }
    
    if c.cgroupns && c.cgroup2Path != "" {
        // cgroupå‘½åç©ºé—´æ¨¡å¼ï¼šæŒ‚è½½å®¹å™¨ç‰¹å®šè·¯å¾„
        bindMount.Source = c.cgroup2Path
    }
    
    return mountToRootfs(c, mountEntry{Mount: bindMount})
}
```

### 4.3 /dev æ–‡ä»¶ç³»ç»Ÿå’Œè®¾å¤‡èŠ‚ç‚¹

```go
// libcontainer/rootfs_linux.go:473
func createDevices(config *configs.Config) error {
    useBindMount := userns.RunningInUserNS() || 
                   config.Namespaces.Contains(configs.NEWUSER)
    
    // åˆ›å»ºé…ç½®ä¸­æŒ‡å®šçš„è®¾å¤‡èŠ‚ç‚¹
    for _, node := range config.Devices {
        // ptmxç”±setupPtmx()å•ç‹¬å¤„ç†
        if utils.CleanPath(node.Path) == "/dev/ptmx" {
            continue
        }
        
        if err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {
            return fmt.Errorf("failed to create device %s: %w", node.Path, err)
        }
    }
    return nil
}

func createDeviceNode(rootfs string, node *devices.Device, bind bool) error {
    dest, err := securejoin.SecureJoin(rootfs, node.Path)
    if err != nil {
        return err
    }
    
    if bind {
        // ç”¨æˆ·å‘½åç©ºé—´ä¸­ä½¿ç”¨bindæŒ‚è½½
        return bindMountDeviceNode(rootfs, dest, node)
    } else {
        // ç›´æ¥ä½¿ç”¨mknodåˆ›å»ºè®¾å¤‡èŠ‚ç‚¹
        return mknodDevice(dest, node)
    }
}

// è®¾å¤‡èŠ‚ç‚¹bindæŒ‚è½½
func bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {
    // åˆ›å»ºç›®æ ‡æ–‡ä»¶
    if err := createBlankFile(dest, node); err != nil {
        return err
    }
    
    // bindæŒ‚è½½è®¾å¤‡èŠ‚ç‚¹
    return mount(node.Path, dest, "bind", unix.MS_BIND, "")
}

// åˆ›å»ºæ ‡å‡†è®¾å¤‡ç¬¦å·é“¾æ¥
func setupDevSymlinks(rootfs string) error {
    links := [][2]string{
        {"/proc/self/fd", "/dev/fd"},
        {"/proc/self/fd/0", "/dev/stdin"},
        {"/proc/self/fd/1", "/dev/stdout"},
        {"/proc/self/fd/2", "/dev/stderr"},
    }
    
    // æ¡ä»¶æ€§ç¬¦å·é“¾æ¥
    if _, err := os.Stat("/proc/kcore"); err == nil {
        links = append(links, [2]string{"/proc/kcore", "/dev/core"})
    }
    
    for _, link := range links {
        newPath := filepath.Join(rootfs, link[1])
        if err := os.Symlink(link[0], newPath); err != nil && !os.IsExist(err) {
            return err
        }
    }
    
    return nil
}
```

## 5. æŒ‚è½½é…ç½®å’Œé€‰é¡¹è§£æ

### 5.1 Mount ç»“æ„å®šä¹‰

```go
// libcontainer/configs/mount_linux.go:23
type Mount struct {
    Source           string              // æºè·¯å¾„æˆ–è®¾å¤‡
    Destination      string              // å®¹å™¨å†…ç›®æ ‡è·¯å¾„
    Device           string              // æ–‡ä»¶ç³»ç»Ÿç±»å‹æˆ–è®¾å¤‡ç±»å‹
    Flags            int                 // æŒ‚è½½æ ‡å¿—ä½
    ClearedFlags     int                 // æ˜ç¡®æ¸…é™¤çš„æ ‡å¿—
    PropagationFlags []int               // æŒ‚è½½ä¼ æ’­æ ‡å¿—æ•°ç»„
    Data             string              // æ–‡ä»¶ç³»ç»Ÿç‰¹å®šé€‰é¡¹
    Relabel          string              // SELinuxé‡æ ‡è®°é€‰é¡¹
    RecAttr          *unix.MountAttr     // mount_setattré€’å½’å±æ€§
    Extensions       int                 // runcæ‰©å±•æ ‡å¿—
    IDMapping        *MountIDMapping     // idmappedæŒ‚è½½é…ç½®
}

// å¸¸ç”¨æ–¹æ³•
func (m *Mount) IsBind() bool {
    return m.Flags&unix.MS_BIND != 0
}

func (m *Mount) IsIDMapped() bool {
    return m.IDMapping != nil
}
```

### 5.2 æŒ‚è½½é€‰é¡¹è§£ææœºåˆ¶

runc ä½¿ç”¨å¤šå±‚æ˜ å°„è¡¨è§£æ OCI è§„èŒƒä¸­çš„æŒ‚è½½é€‰é¡¹ï¼š

```go
// libcontainer/specconv/spec_linux.go:1079
var (
    // åŸºç¡€æŒ‚è½½æ ‡å¿—æ˜ å°„  
    mountFlags = map[string]struct{clear bool; flag int}{
        "defaults":   {false, 0},                    // é»˜è®¤é€‰é¡¹
        "ro":         {false, unix.MS_RDONLY},       // åªè¯»
        "rw":         {true, unix.MS_RDONLY},        // å¯å†™(æ¸…é™¤åªè¯»)
        "nosuid":     {false, unix.MS_NOSUID},       // ç¦ç”¨suid
        "suid":       {true, unix.MS_NOSUID},        // å…è®¸suid(æ¸…é™¤nosuid)
        "nodev":      {false, unix.MS_NODEV},        // ç¦ç”¨è®¾å¤‡èŠ‚ç‚¹
        "dev":        {true, unix.MS_NODEV},         // å…è®¸è®¾å¤‡èŠ‚ç‚¹
        "noexec":     {false, unix.MS_NOEXEC},       // ç¦ç”¨å¯æ‰§è¡Œæ–‡ä»¶
        "exec":       {true, unix.MS_NOEXEC},        // å…è®¸å¯æ‰§è¡Œæ–‡ä»¶
        "sync":       {false, unix.MS_SYNCHRONOUS},   // åŒæ­¥IO
        "async":      {true, unix.MS_SYNCHRONOUS},    // å¼‚æ­¥IO
        "dirsync":    {false, unix.MS_DIRSYNC},      // ç›®å½•åŒæ­¥
        "remount":    {false, unix.MS_REMOUNT},      // é‡æ–°æŒ‚è½½
        "mand":       {false, unix.MS_MANDLOCK},     // å¼ºåˆ¶é”
        "nomand":     {true, unix.MS_MANDLOCK},      // ç¦ç”¨å¼ºåˆ¶é”
        "atime":      {true, unix.MS_NOATIME},       // æ›´æ–°è®¿é—®æ—¶é—´
        "noatime":    {false, unix.MS_NOATIME},      // ä¸æ›´æ–°è®¿é—®æ—¶é—´
        "diratime":   {true, unix.MS_NODIRATIME},    // ç›®å½•è®¿é—®æ—¶é—´
        "nodiratime": {false, unix.MS_NODIRATIME},   // ç¦ç”¨ç›®å½•è®¿é—®æ—¶é—´
        "bind":       {false, unix.MS_BIND},         // bindæŒ‚è½½
        "rbind":      {false, unix.MS_BIND | unix.MS_REC}, // é€’å½’bindæŒ‚è½½
        "relatime":   {false, unix.MS_RELATIME},     // ç›¸å¯¹è®¿é—®æ—¶é—´
        "norelatime": {true, unix.MS_RELATIME},      // ç¦ç”¨ç›¸å¯¹è®¿é—®æ—¶é—´
        "strictatime": {false, unix.MS_STRICTATIME}, // ä¸¥æ ¼è®¿é—®æ—¶é—´
        "nostrictatime": {true, unix.MS_STRICTATIME}, // éä¸¥æ ¼è®¿é—®æ—¶é—´
    }
    
    // æŒ‚è½½ä¼ æ’­å±æ€§æ˜ å°„
    mountPropagationMapping = map[string]int{
        "private":     unix.MS_PRIVATE,
        "rprivate":    unix.MS_PRIVATE | unix.MS_REC,
        "shared":      unix.MS_SHARED,
        "rshared":     unix.MS_SHARED | unix.MS_REC,
        "slave":       unix.MS_SLAVE,
        "rslave":      unix.MS_SLAVE | unix.MS_REC,
        "unbindable":  unix.MS_UNBINDABLE,
        "runbindable": unix.MS_UNBINDABLE | unix.MS_REC,
    }
    
    // mount_setattré€’å½’å±æ€§æ˜ å°„ (Linux 5.12+)
    recAttrFlags = map[string]struct{clear bool; flag uint64}{
        "rro":        {false, unix.MOUNT_ATTR_RDONLY},
        "rrw":        {true, unix.MOUNT_ATTR_RDONLY},
        "rnosuid":    {false, unix.MOUNT_ATTR_NOSUID},
        "rsuid":      {true, unix.MOUNT_ATTR_NOSUID},
        "rnodev":     {false, unix.MOUNT_ATTR_NODEV},
        "rdev":       {true, unix.MOUNT_ATTR_NODEV},
        "rnoexec":    {false, unix.MOUNT_ATTR_NOEXEC},
        "rexec":      {true, unix.MOUNT_ATTR_NOEXEC},
        "rnodiratime": {false, unix.MOUNT_ATTR_NODIRATIME},
        "rdiratime":   {true, unix.MOUNT_ATTR_NODIRATIME},
        "rnoatime":    {false, unix.MOUNT_ATTR_NOATIME},
        "ratime":      {true, unix.MOUNT_ATTR_NOATIME},
        "rrelatime":   {false, unix.MOUNT_ATTR_RELATIME},
        "rnorelatime": {true, unix.MOUNT_ATTR_RELATIME},
        "rstrictatime": {false, unix.MOUNT_ATTR_STRICTATIME},
        "rnostrictatime": {true, unix.MOUNT_ATTR_STRICTATIME},
    }
)
```

### 5.3 é€‰é¡¹è§£æç®—æ³•

```go
func parseMountOptions(options []string) (*configs.Mount, error) {
    var (
        data     []string
        mount    configs.Mount
        recAttrSet, recAttrClr uint64
    )
    
    for _, option := range options {
        if f, exists := mountFlags[option]; exists && f.flag != 0 {
            if f.clear {
                // æ¸…é™¤æ ‡å¿—
                mount.Flags &= ^f.flag
                mount.ClearedFlags |= f.flag
            } else {
                // è®¾ç½®æ ‡å¿—
                mount.Flags |= f.flag
                mount.ClearedFlags &= ^f.flag
            }
        } else if f, exists := mountPropagationMapping[option]; exists {
            // ä¼ æ’­å±æ€§
            mount.PropagationFlags = append(mount.PropagationFlags, f)
        } else if f, exists := recAttrFlags[option]; exists {
            // é€’å½’å±æ€§ (mount_setattr)
            if f.clear {
                recAttrClr |= f.flag
            } else {
                recAttrSet |= f.flag
                // atimeæ ‡å¿—éœ€è¦ç‰¹æ®Šå¤„ç†
                if f.flag&unix.MOUNT_ATTR__ATIME == f.flag {
                    recAttrClr |= unix.MOUNT_ATTR__ATIME
                }
            }
        } else {
            // æ–‡ä»¶ç³»ç»Ÿç‰¹å®šé€‰é¡¹
            data = append(data, option)
        }
    }
    
    mount.Data = strings.Join(data, ",")
    
    // è®¾ç½®mount_setattrå±æ€§
    if recAttrSet != 0 || recAttrClr != 0 {
        mount.RecAttr = &unix.MountAttr{
            Attr_set: recAttrSet,
            Attr_clr: recAttrClr,
        }
    }
    
    return &mount, nil
}
```

## 6. å®‰å…¨æœºåˆ¶å’Œé”™è¯¯å¤„ç†

### 6.1 è·¯å¾„å®‰å…¨å¤„ç†

runc ä½¿ç”¨å¤šç§æœºåˆ¶é˜²æ­¢è·¯å¾„éå†æ”»å‡»ï¼š

```go
// ä½¿ç”¨procfdç¡®ä¿è·¯å¾„å®‰å…¨
func WithProcfd(root, path string, fn func(procfd string) error) error {
    // ä½¿ç”¨ /proc/self/fd/<fd> ç¡®ä¿æ“ä½œåœ¨æ­£ç¡®çš„è·¯å¾„ä¸Š
    file, err := securejoin.OpenInRoot(root, path, unix.O_PATH|unix.O_CLOEXEC)
    if err != nil {
        return err
    }
    defer file.Close()
    
    procfd := "/proc/self/fd/" + strconv.Itoa(int(file.Fd()))
    return fn(procfd)
}

// securejoin ç¡®ä¿å®‰å…¨è·¯å¾„è¿æ¥
func secureJoin(root, path string) (string, error) {
    // é˜²æ­¢ ../ è·¯å¾„éå†
    // é˜²æ­¢ç¬¦å·é“¾æ¥é€ƒé€¸  
    // ç¡®ä¿ç»“æœè·¯å¾„åœ¨rootå†…éƒ¨
    return securejoin.SecureJoin(root, path)
}
```

### 6.2 é”™è¯¯å¤„ç†å’Œè¯Šæ–­

```go
// ç»“æ„åŒ–çš„æŒ‚è½½é”™è¯¯ä¿¡æ¯
type mountError struct {
    op      string        // æ“ä½œç±»å‹ (mount/unmount)
    source  string        // æºè·¯å¾„
    srcFile *mountSource  // æºæ–‡ä»¶æè¿°ç¬¦ä¿¡æ¯
    target  string        // ç›®æ ‡è·¯å¾„
    dstFd   string        // ç›®æ ‡procfdè·¯å¾„
    flags   uintptr       // æŒ‚è½½æ ‡å¿—
    data    string        // æŒ‚è½½é€‰é¡¹
    err     error         // åº•å±‚é”™è¯¯
}

func (e *mountError) Error() string {
    var srcType string
    if e.srcFile != nil {
        srcType = string(e.srcFile.Type)
    }
    return fmt.Sprintf("%s failed: src=%s, srcType=%s, dst=%s, flags=%s, data=%s: %v",
                       e.op, e.source, srcType, e.target,
                       stringifyMountFlags(e.flags), e.data, e.err)
}

// æŒ‚è½½æ ‡å¿—çš„å¯è¯»åŒ–
func stringifyMountFlags(flags uintptr) string {
    var opts []string
    if flags&unix.MS_RDONLY != 0 {
        opts = append(opts, "ro")
    }
    if flags&unix.MS_NOSUID != 0 {
        opts = append(opts, "nosuid")
    }
    if flags&unix.MS_NODEV != 0 {
        opts = append(opts, "nodev")
    }
    if flags&unix.MS_NOEXEC != 0 {
        opts = append(opts, "noexec")
    }
    if flags&unix.MS_BIND != 0 {
        opts = append(opts, "bind")
    }
    // ... æ›´å¤šæ ‡å¿—
    
    if len(opts) == 0 {
        return "0"
    }
    return strings.Join(opts, ",")
}
```

### 6.3 åªè¯»æ–‡ä»¶ç³»ç»ŸåŠ å›º

```go
// libcontainer/rootfs_linux.go:388
func finalizeRootfs(config *configs.Config) error {
    // 1. é‡æ–°æŒ‚è½½å»¶è¿Ÿåªè¯»çš„æ–‡ä»¶ç³»ç»Ÿ
    for _, mount := range config.Mounts {
        if mount.Flags&unix.MS_RDONLY != unix.MS_RDONLY {
            continue
        }
        
        // tmpfs å’Œ /dev å»¶è¿Ÿåªè¯»å¤„ç†
        if mount.Device == "tmpfs" || utils.CleanPath(mount.Destination) == "/dev" {
            if err := remountReadonly(mount); err != nil {
                return fmt.Errorf("failed to remount %s as readonly: %w", 
                                 mount.Destination, err)
            }
        }
    }
    
    // 2. è®¾ç½®æ ¹æ–‡ä»¶ç³»ç»Ÿåªè¯»
    if config.Readonlyfs {
        if err := setReadonly(); err != nil {
            return fmt.Errorf("failed to set rootfs readonly: %w", err)
        }
    }
    
    // 3. åº”ç”¨ umask
    if config.Umask != nil {
        unix.Umask(int(*config.Umask))
    } else {
        unix.Umask(0o022)  // é»˜è®¤ umask
    }
    
    return nil
}

func setReadonly() error {
    // é‡æ–°æŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿä¸ºåªè¯»
    return mount("/", "/", "", unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, "")
}
```

## 7. å®è·µç»ƒä¹ 

### 7.1 åŸºç¡€æŒ‚è½½å®éªŒ

```bash
#!/bin/bash
# å®éªŒ 1: ç†è§£ä¸åŒæŒ‚è½½ç±»å‹

# åˆ›å»ºå®éªŒç¯å¢ƒ
mkdir -p /tmp/rootfs/{bin,etc,proc,sys,dev,tmp}
mkdir -p /tmp/host-data

# 1. bind æŒ‚è½½å®éªŒ
echo "host content" > /tmp/host-data/file.txt
mount --bind /tmp/host-data /tmp/rootfs/tmp
ls /tmp/rootfs/tmp/  # åº”è¯¥çœ‹åˆ° file.txt

# 2. tmpfs æŒ‚è½½å®éªŒ
mount -t tmpfs tmpfs /tmp/rootfs/dev -o size=10M,mode=755
echo "tmpfs content" > /tmp/rootfs/dev/tmpfile
ls /tmp/rootfs/dev/

# 3. proc æŒ‚è½½å®éªŒ
mount -t proc proc /tmp/rootfs/proc
ls /tmp/rootfs/proc/  # çœ‹åˆ°procå†…å®¹

# 4. æµ‹è¯•æŒ‚è½½ä¼ æ’­
mkdir -p /tmp/test-propagation/{source,target}
mount --bind /tmp/test-propagation/source /tmp/test-propagation/target

# å…±äº«ä¼ æ’­
mount --make-shared /tmp/test-propagation/target
mount --bind /tmp/host-data /tmp/test-propagation/target/shared

# æ£€æŸ¥ä¼ æ’­æ•ˆæœ
ls /tmp/test-propagation/source/  # åº”è¯¥çœ‹åˆ°sharedç›®å½•

# æ¸…ç†
umount -R /tmp/rootfs
umount -R /tmp/test-propagation
```

### 7.2 å®¹å™¨æ–‡ä»¶ç³»ç»Ÿæ„å»º

```bash
#!/bin/bash
# å®éªŒ 2: æ‰‹åŠ¨æ„å»ºå®¹å™¨æ–‡ä»¶ç³»ç»Ÿ

create_container_rootfs() {
    local rootfs="/tmp/container-rootfs"
    local old_root="/tmp/old-root"
    
    # 1. å‡†å¤‡åŸºç¡€rootfs
    mkdir -p "$rootfs"/{bin,etc,lib,proc,sys,dev,tmp}
    
    # å¤åˆ¶å¿…è¦çš„å¯æ‰§è¡Œæ–‡ä»¶
    cp /bin/sh "$rootfs/bin/"
    cp /bin/ls "$rootfs/bin/"
    cp /bin/cat "$rootfs/bin/"
    
    # å¤åˆ¶åº“æ–‡ä»¶
    ldd /bin/sh | grep -o '/lib[^ ]*' | while read lib; do
        mkdir -p "$rootfs$(dirname "$lib")"
        cp "$lib" "$rootfs$lib"
    done
    
    # 2. è®¾ç½®æŒ‚è½½ä¼ æ’­
    mount --make-private /
    
    # 3. bindæŒ‚è½½rootfsåˆ°è‡ªèº«
    mount --bind "$rootfs" "$rootfs"
    
    # 4. åˆ‡æ¢åˆ°æ–°namespaceä¸­æ‰§è¡Œ
    unshare --mount --pid --fork /bin/bash -c "
        # åœ¨æ–°çš„mount namespaceä¸­
        cd '$rootfs'
        
        # æŒ‚è½½ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿ
        mount -t proc proc proc/
        mount -t sysfs sysfs sys/
        mount -t tmpfs tmpfs tmp/ -o size=100M
        
        # åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹
        mkdir -p dev
        mknod dev/null c 1 3
        mknod dev/zero c 1 5
        mknod dev/random c 1 8
        
        # åˆ›å»ºç¬¦å·é“¾æ¥
        ln -sf /proc/self/fd dev/fd
        ln -sf /proc/self/fd/0 dev/stdin
        ln -sf /proc/self/fd/1 dev/stdout
        ln -sf /proc/self/fd/2 dev/stderr
        
        # æ‰§è¡Œpivot_root
        mkdir -p '$old_root'
        pivot_root . '$old_root'
        
        # å¸è½½æ—§æ ¹
        umount /$old_root 2>/dev/null || true
        rmdir /$old_root 2>/dev/null || true
        
        # è¿›å…¥å®¹å™¨ç¯å¢ƒ
        cd /
        exec /bin/sh
    "
}

# æ‰§è¡Œå®éªŒ
create_container_rootfs
```

### 7.3 æŒ‚è½½é€‰é¡¹è§£ææµ‹è¯•

```go
// å®éªŒ 3: ç†è§£æŒ‚è½½é€‰é¡¹è§£æ
package main

import (
    "fmt"
    "strings"
    "golang.org/x/sys/unix"
)

func parseMountOptions(options []string) {
    var flags int
    var data []string
    
    mountFlags := map[string]struct{clear bool; flag int}{
        "ro":     {false, unix.MS_RDONLY},
        "rw":     {true, unix.MS_RDONLY},
        "nosuid": {false, unix.MS_NOSUID},
        "suid":   {true, unix.MS_NOSUID},
        "bind":   {false, unix.MS_BIND},
        "rbind":  {false, unix.MS_BIND | unix.MS_REC},
    }
    
    for _, opt := range options {
        if f, exists := mountFlags[opt]; exists {
            if f.clear {
                flags &= ^f.flag
                fmt.Printf("Cleared flag: %s\n", opt)
            } else {
                flags |= f.flag
                fmt.Printf("Set flag: %s\n", opt)
            }
        } else {
            data = append(data, opt)
        }
    }
    
    fmt.Printf("Final flags: %d\n", flags)
    fmt.Printf("Data: %s\n", strings.Join(data, ","))
}

func main() {
    // æµ‹è¯•ä¸åŒé€‰é¡¹ç»„åˆ
    fmt.Println("=== Test 1: ro,nosuid,bind ===")
    parseMountOptions([]string{"ro", "nosuid", "bind"})
    
    fmt.Println("\n=== Test 2: rw,suid,rbind,size=100M ===")
    parseMountOptions([]string{"rw", "suid", "rbind", "size=100M"})
    
    fmt.Println("\n=== Test 3: ro then rw ===")
    parseMountOptions([]string{"ro", "rw"})
}
```

### 7.4 æ–‡ä»¶ç³»ç»Ÿå®‰å…¨æµ‹è¯•

```bash
#!/bin/bash
# å®éªŒ 4: æµ‹è¯•æ–‡ä»¶ç³»ç»Ÿå®‰å…¨æœºåˆ¶

test_path_traversal() {
    echo "=== Path Traversal Test ==="
    
    # åˆ›å»ºå®¹å™¨rootfs
    mkdir -p /tmp/container/{rootfs,host-secret}
    echo "secret content" > /tmp/container/host-secret/secret.txt
    
    # æµ‹è¯•è·¯å¾„éå†é˜²æŠ¤
    ln -sf ../host-secret /tmp/container/rootfs/escape
    
    # runcä¼šé˜²æ­¢è¿™ç§ç¬¦å·é“¾æ¥é€ƒé€¸
    echo "Attempting to access: /tmp/container/rootfs/escape/secret.txt"
    
    # æ¨¡æ‹Ÿsecurejoinæ£€æŸ¥
    if readlink /tmp/container/rootfs/escape | grep -q "\.\."; then
        echo "Path traversal detected and blocked!"
    fi
}

test_proc_mount_security() {
    echo "=== /proc Mount Security Test ==="
    
    mkdir -p /tmp/test-proc/rootfs/proc
    
    # å…è®¸çš„/procæŒ‚è½½
    echo "Testing allowed /proc paths:"
    for path in "/proc/cpuinfo" "/proc/meminfo" "/proc/uptime"; do
        echo "  $path - ALLOWED"
    done
    
    # ç¦æ­¢çš„/procæŒ‚è½½
    echo "Testing forbidden /proc paths:"
    for path in "/proc/1/maps" "/proc/sys/kernel/core_pattern" "/proc/kcore"; do
        echo "  $path - BLOCKED"
    done
}

test_bind_mount_flags() {
    echo "=== Bind Mount Flags Test ==="
    
    # åˆ›å»ºæºç›®å½•å’Œæ–‡ä»¶
    mkdir -p /tmp/bind-test/source
    echo "test" > /tmp/bind-test/source/file.txt
    chmod 777 /tmp/bind-test/source/file.txt
    
    # æµ‹è¯•åªè¯»bindæŒ‚è½½
    mkdir -p /tmp/bind-test/target
    mount --bind /tmp/bind-test/source /tmp/bind-test/target
    
    # å°è¯•é‡æ–°æŒ‚è½½ä¸ºåªè¯»
    mount -o remount,ro /tmp/bind-test/target
    
    # æµ‹è¯•å†™å…¥ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    if echo "write test" > /tmp/bind-test/target/file.txt 2>/dev/null; then
        echo "ERROR: Read-only bind mount failed!"
    else
        echo "SUCCESS: Read-only bind mount working"
    fi
    
    umount /tmp/bind-test/target
}

# è¿è¡Œæµ‹è¯•
test_path_traversal
test_proc_mount_security  
test_bind_mount_flags

# æ¸…ç†
rm -rf /tmp/container /tmp/test-proc /tmp/bind-test
```

## 8. æ•…éšœæ’é™¤å’Œè°ƒè¯•

### 8.1 å¸¸è§æŒ‚è½½é—®é¢˜è¯Šæ–­

#### æƒé™é—®é¢˜

```bash
# æ£€æŸ¥å½“å‰æŒ‚è½½æƒ…å†µ
mount | grep "container\|runc"

# æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæƒé™
ls -la /proc/self/ns/mnt  # mount namespace
ls -la /sys/fs/cgroup     # cgroupæ–‡ä»¶ç³»ç»Ÿ

# æ£€æŸ¥ç”¨æˆ·æƒé™
id
groups
cat /proc/self/uid_map
cat /proc/self/gid_map
```

#### æŒ‚è½½ä¼ æ’­é—®é¢˜

```bash
# æ£€æŸ¥æŒ‚è½½ä¼ æ’­å±æ€§
grep -E "shared|slave|private" /proc/self/mountinfo

# æŸ¥çœ‹ç‰¹å®šæŒ‚è½½ç‚¹çš„ä¼ æ’­å±æ€§
findmnt -o TARGET,PROPAGATION /

# ä¿®å¤ä¼ æ’­å±æ€§
mount --make-private /
mount --make-slave /
```

### 8.2 è°ƒè¯•å·¥å…·å’Œæ–¹æ³•

```bash
# strace è·Ÿè¸ªæŒ‚è½½ç³»ç»Ÿè°ƒç”¨
strace -f -e trace=mount,umount,pivot_root runc create container

# ä½¿ç”¨ nsenter è¿›å…¥å®¹å™¨çš„ mount namespace
nsenter -m -p -t $(docker inspect -f '{{.State.Pid}}' container) /bin/sh

# æ£€æŸ¥å®¹å™¨å†…çš„æŒ‚è½½æƒ…å†µ
nsenter -m -t PID cat /proc/mounts
nsenter -m -t PID findmnt

# è°ƒè¯• runc æŒ‚è½½è¿‡ç¨‹
RUNC_DEBUG=1 runc create container 2>&1 | grep -i mount
```

### 8.3 æ€§èƒ½åˆ†æ

```bash
# æµ‹é‡æŒ‚è½½æ“ä½œæ—¶é—´
time runc create container

# åˆ†æI/Oæ€§èƒ½
iostat -x 1 10 &
runc run container
kill %1

# å†…å­˜ä½¿ç”¨åˆ†æ
/usr/bin/time -v runc run container
```

## 9. æ€è€ƒé¢˜

### 9.1 æ¶æ„è®¾è®¡æ€è€ƒ

1. **rootfsåˆ‡æ¢æ–¹å¼**: pivot_root vs MS_MOVE vs chroot çš„ä¼˜ç¼ºç‚¹å¯¹æ¯”ï¼Œä»€ä¹ˆåœºæ™¯ä¸‹é€‰æ‹©å“ªç§æ–¹å¼ï¼Ÿ

2. **æŒ‚è½½ä¼ æ’­**: ä¸ºä»€ä¹ˆå®¹å™¨éœ€è¦ MS_SLAVE ä¼ æ’­å±æ€§ï¼Ÿå¦‚æœä½¿ç”¨ MS_SHARED ä¼šæœ‰ä»€ä¹ˆé£é™©ï¼Ÿ

3. **bindæŒ‚è½½å¤æ‚æ€§**: ä¸ºä»€ä¹ˆ bind æŒ‚è½½éœ€è¦ remount æ¥åº”ç”¨æ ‡å¿—ï¼Ÿlocked flags é—®é¢˜å¦‚ä½•æ›´ä¼˜é›…åœ°è§£å†³ï¼Ÿ

### 9.2 å®‰å…¨æ€§æ€è€ƒ

4. **/procå®‰å…¨**: é™¤äº†ç™½åå•æœºåˆ¶ï¼Œè¿˜æœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥å¢å¼º /proc æŒ‚è½½çš„å®‰å…¨æ€§ï¼Ÿ

5. **è·¯å¾„éå†**: securejoin æœºåˆ¶èƒ½å¦é˜²å¾¡æ‰€æœ‰çš„è·¯å¾„éå†æ”»å‡»ï¼Ÿè¿˜æœ‰ä»€ä¹ˆæ½œåœ¨æ¼æ´ï¼Ÿ

6. **idmapped mounts**: idmapped mounts åœ¨ä»€ä¹ˆåœºæ™¯ä¸‹æœ€æœ‰ä»·å€¼ï¼Ÿæœ‰ä»€ä¹ˆå®‰å…¨é£é™©ï¼Ÿ

### 9.3 æ€§èƒ½ä¼˜åŒ–æ€è€ƒ

7. **æŒ‚è½½å¼€é”€**: å¤§é‡æŒ‚è½½ç‚¹å¯¹å®¹å™¨å¯åŠ¨æ€§èƒ½çš„å½±å“ï¼Ÿå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

8. **æ–‡ä»¶ç³»ç»Ÿé€‰æ‹©**: ä¸åŒ rootfs æ–‡ä»¶ç³»ç»Ÿ (ext4/xfs/overlay) å¯¹æ€§èƒ½çš„å½±å“ï¼Ÿ

9. **å†…å­˜ä½¿ç”¨**: tmpfs çš„å†…å­˜ä½¿ç”¨å¦‚ä½•æ§åˆ¶ï¼Ÿä½•æ—¶é€‰æ‹© tmpfs vs bind mountï¼Ÿ

## 10. æ‰©å±•é˜…è¯»

### 10.1 Linux å†…æ ¸æ–‡æ¡£

- [Mount namespaces](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)
- [pivot_root(2)](https://man7.org/linux/man-pages/man2/pivot_root.2.html)
- [mount(2)](https://man7.org/linux/man-pages/man2/mount.2.html)
- [mount_setattr(2)](https://man7.org/linux/man-pages/man2/mount_setattr.2.html)

### 10.2 æ–‡ä»¶ç³»ç»ŸæŠ€æœ¯

- [VFS (Virtual File System)](https://www.kernel.org/doc/Documentation/filesystems/vfs.txt)
- [Bind Mounts](https://lwn.net/Articles/281157/)
- [Mount propagation](https://lwn.net/Articles/159077/)
- [Idmapped mounts](https://lwn.net/Articles/837566/)

### 10.3 å®¹å™¨æŠ€æœ¯æ·±å…¥

- [Container filesystems](https://medium.com/containers-world/filesystem-technology-container-6cfbeac6c0dc)
- [OverlayFS and containers](https://arkfox.com/archive/overlayfs/)
- [Container security with mount namespaces](https://blog.quarkslab.com/mount-namespace-linux-kernel.html)

## ğŸ¯ æ¨¡å—æ€»ç»“

é€šè¿‡æœ¬æ¨¡å—çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

âœ… **Rootfs åˆ‡æ¢æœºåˆ¶**ï¼šç†è§£ä¸‰ç§åˆ‡æ¢æ–¹å¼å’Œé€‚ç”¨åœºæ™¯  
âœ… **æŒ‚è½½ç±»å‹å¤„ç†**ï¼šæŒæ¡å„ç§æ–‡ä»¶ç³»ç»Ÿçš„ä¸“é—¨å¤„ç†é€»è¾‘  
âœ… **å®‰å…¨é˜²æŠ¤æœºåˆ¶**ï¼šç†è§£è·¯å¾„å®‰å…¨ã€procæ£€æŸ¥ç­‰é˜²æŠ¤æªæ–½  
âœ… **é…ç½®è§£æç³»ç»Ÿ**ï¼šç†Ÿæ‚‰æŒ‚è½½é€‰é¡¹çš„å¤šå±‚æ˜ å°„å’Œè§£ææµç¨‹  
âœ… **æ•…éšœæ’é™¤èƒ½åŠ›**ï¼šå…·å¤‡æŒ‚è½½é—®é¢˜è¯Šæ–­å’Œæ€§èƒ½ä¼˜åŒ–æŠ€èƒ½  

**ä¸‹ä¸€æ­¥**: è¿›å…¥ [æ¨¡å— 6: å®‰å…¨ç‰¹æ€§å®ç°](./06-å®‰å…¨ç‰¹æ€§å®ç°.md)ï¼Œå­¦ä¹ å®¹å™¨å®‰å…¨æœºåˆ¶çš„å…·ä½“å®ç°ã€‚