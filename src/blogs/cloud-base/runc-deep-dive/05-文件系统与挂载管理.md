# 文件系统与挂载管理

> **系列导航：** [runc 容器运行时深度解析系列](./README.md) → 第五篇：文件系统与挂载管理  
> **上一篇：** [Cgroups资源管理](./04-Cgroups资源管理.md)  
> **最后更新：** 2024

## 概述

本文深入分析 runc 如何管理容器的文件系统和挂载点。包括 rootfs 的准备和切换、挂载点的创建和管理，以及挂载传播等高级特性。

## 🎯 学习目标

完成本模块后，你将能够：
- 深入理解容器 rootfs 准备和切换的完整机制
- 掌握 runc 中各种挂载类型的处理逻辑和安全策略
- 理解 Mount Namespace 与文件系统隔离的实现原理
- 熟悉 bind mount、overlay、特殊文件系统的应用场景
- 具备排查容器文件系统问题和优化挂载配置的能力

## 1. 容器文件系统基础

### 1.1 什么是容器文件系统？

容器文件系统是为容器进程提供隔离文件视图的核心机制。它通过 **rootfs 切换** + **挂载管理** + **文件系统隔离** 实现完整的文件系统虚拟化。

```
宿主机文件系统                   容器文件系统视图
┌─────────────────────┐         ┌─────────────────────┐
│ /                   │   变换   │ /                   │
│ ├── bin/            │  ────→  │ ├── bin/            │ (来自镜像)
│ ├── etc/            │         │ ├── etc/            │ (来自镜像)
│ ├── home/           │         │ ├── home/           │ (来自挂载)
│ ├── proc/           │         │ ├── proc/           │ (容器proc)
│ └── var/containers/ │         │ ├── tmp/            │ (tmpfs)
│     └── rootfs/     │         │ └── dev/            │ (设备节点)
└─────────────────────┘         └─────────────────────┘
      宿主机视图                      容器内视图
```

**核心组件**：
- 🏠 **Rootfs**: 容器的根文件系统，通常来自镜像
- 🔗 **Bind Mounts**: 将宿主机目录映射到容器内
- 💾 **Tmpfs**: 临时内存文件系统
- ⚙️ **Special FS**: proc、sys、dev 等特殊文件系统

### 1.2 文件系统隔离层次

```
┌─────────────────────────────────────────────────┐
│              应用进程视图                       │
├─────────────────────────────────────────────────┤
│           容器挂载命名空间                      │
│  ┌─────────────────────────────────────────┐    │
│  │          /                              │    │
│  │  ├── bin/ (来自镜像层)                  │    │ 
│  │  ├── etc/ (来自镜像层)                  │    │
│  │  ├── proc/ (容器专属procfs)             │    │
│  │  ├── tmp/ (tmpfs内存文件系统)           │    │
│  │  └── app/ (bind mount宿主机目录)        │    │
│  └─────────────────────────────────────────┘    │
├─────────────────────────────────────────────────┤
│                宿主机内核                       │
│  ┌─────────────────┬─────────────────────────┐   │
│  │  真实文件系统   │   虚拟文件系统 (VFS)   │   │
│  │   (ext4/xfs)    │   (proc/sys/tmpfs)     │   │
│  └─────────────────┴─────────────────────────┘   │
└─────────────────────────────────────────────────┘
```

## 2. Rootfs 准备和切换机制

### 2.1 整体流程架构

runc 的文件系统初始化遵循 **准备** → **挂载** → **切换** → **加固** 的四阶段流程：

```
用户执行: runc create mycontainer
           │
           ▼
┌─────────────────────────────────────────────────┐
│  阶段1: prepareRoot - 根挂载点预处理            │
│  - 设置挂载传播属性                             │
│  - 确保父挂载点私有化                           │
│  - 自绑定rootfs准备pivot_root                   │
└─────────────┬───────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────┐
│  阶段2: prepareRootfs - 挂载处理                │
│  - 处理所有OCI配置的挂载点                      │
│  - 创建设备节点和符号链接                       │
│  - 处理特殊文件系统(proc/sys/cgroup)            │
└─────────────┬───────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────┐
│  阶段3: pivotRoot/msMoveRoot - 根文件系统切换   │
│  - pivot_root(): 标准切换方式                   │
│  - MS_MOVE: --no-pivot-root 选项               │
│  - chroot(): 传统方式(无mount namespace)        │
└─────────────┬───────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────┐
│  阶段4: finalizeRootfs - 安全加固               │
│  - 重新挂载tmpfs/dev为只读                      │
│  - 设置根文件系统只读                           │
│  - 应用umask权限设置                            │
└─────────────────────────────────────────────────┘
```

### 2.2 prepareRoot - 根挂载点预处理

```go
// libcontainer/rootfs_linux.go:97
func prepareRoot(config *configs.Config) error {
    // 1. 设置根挂载传播属性
    flag := unix.MS_SLAVE | unix.MS_REC  // 默认为slave递归
    if config.RootPropagation != 0 {
        flag = config.RootPropagation    // 用户自定义传播属性
    }
    
    // 在根目录上应用传播属性
    if err := mount("", "/", "", uintptr(flag), ""); err != nil {
        return fmt.Errorf("failed to set root mount propagation: %w", err)
    }
    
    // 2. 确保rootfs父挂载点是私有的
    if err := rootfsParentMountPrivate(config.Rootfs); err != nil {
        return err
    }
    
    // 3. 递归绑定挂载rootfs到自身，为pivot_root做准备
    // 这一步是关键：使rootfs成为独立的挂载点
    return mount(config.Rootfs, config.Rootfs, "bind", 
                unix.MS_BIND|unix.MS_REC, "")
}
```

**挂载传播属性解释**：

| 传播类型 | 含义 | 应用场景 |
|----------|------|----------|
| **MS_PRIVATE** | 私有，挂载不传播 | 完全隔离容器挂载 |
| **MS_SLAVE** | 从属，只接收不发送 | 接收宿主机挂载，但不影响宿主机 |
| **MS_SHARED** | 共享，双向传播 | 容器与宿主机共享挂载变更 |
| **MS_UNBINDABLE** | 不可绑定 | 防止挂载点被bind |

### 2.3 三种根文件系统切换方式

#### A. pivot_root 方式 (标准方式)

```go
// libcontainer/rootfs_linux.go:128
func pivotRoot(rootfs string) error {
    // 打开旧根和新根的文件描述符
    oldroot, err := linux.Open("/", unix.O_DIRECTORY|unix.O_RDONLY, 0)
    if err != nil {
        return err
    }
    defer oldroot.Close()
    
    newroot, err := linux.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)
    if err != nil {
        return err
    }
    defer newroot.Close()
    
    // 切换到新根目录
    if err := unix.Fchdir(int(newroot.Fd())); err != nil {
        return err
    }
    
    // 执行pivot_root系统调用
    // 技巧：pivot_root(".", ".") - 来自LXC开发者的智慧
    if err := unix.PivotRoot(".", "."); err != nil {
        return fmt.Errorf("pivot_root failed: %w", err)
    }
    
    // 设置旧根为slave，防止挂载传播到宿主机
    if err := mount("", ".", "", unix.MS_SLAVE|unix.MS_REC, ""); err != nil {
        return err
    }
    
    // 分离卸载旧根
    if err := unmount(".", unix.MNT_DETACH); err != nil {
        return err
    }
    
    // 切换工作目录到新根
    return unix.Chdir("/")
}
```

**pivot_root 工作原理**：

```
执行前:                        执行后:
宿主机根 (/)                   容器根 (/)
├── bin/                      ├── bin/         (来自镜像)
├── etc/                      ├── etc/         (来自镜像)
└── containers/               ├── tmp/         (tmpfs)
    └── rootfs/               └── proc/        (容器procfs)
        ├── bin/
        ├── etc/
        └── tmp/
        
pivot_root(rootfs, oldroot) 将:
- rootfs 变成新的根目录 /
- 原来的根目录被移到 oldroot 位置
- 然后卸载 oldroot，完成切换
```

#### B. MS_MOVE 方式 (--no-pivot-root)

```go
// libcontainer/rootfs_linux.go:185
func msMoveRoot(rootfs string) error {
    // 先处理潜在的安全风险：屏蔽危险的procfs和sysfs挂载
    mountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {
        // 过滤条件：根目录、proc/sys文件系统、不在rootfs内部的挂载
        if info.Root != "/" || 
           (info.FSType != "proc" && info.FSType != "sysfs") ||
           strings.HasPrefix(info.Mountpoint, rootfs) {
            skip = true
        }
        return
    })
    
    // 卸载或覆盖危险挂载点
    for _, info := range mountinfos {
        // 设置为slave防止传播
        mount("", info.Mountpoint, "", unix.MS_SLAVE|unix.MS_REC, "")
        
        if err := unmount(info.Mountpoint, unix.MNT_DETACH); err != nil {
            // 如果无法卸载，用tmpfs覆盖
            if err := mount("tmpfs", info.Mountpoint, "tmpfs", 0, ""); err != nil {
                return fmt.Errorf("failed to mask %s: %w", info.Mountpoint, err)
            }
        }
    }
    
    // 将rootfs移动到根位置
    if err := mount(rootfs, "/", "", unix.MS_MOVE, ""); err != nil {
        return fmt.Errorf("failed to move %s to /: %w", rootfs, err)
    }
    
    // 执行chroot完成切换
    return chroot()
}
```

#### C. chroot 方式 (传统方式)

```go
func chroot() error {
    // 简单的chroot系统调用
    if err := unix.Chroot("."); err != nil {
        return err
    }
    return unix.Chdir("/")
}
```

**三种方式对比**：

| 方式 | 使用场景 | 优势 | 劣势 |
|------|----------|------|------|
| **pivot_root** | 有mount namespace | 安全性最高，完全隔离 | 需要mount namespace |
| **MS_MOVE** | --no-pivot-root标志 | 兼容性好 | 需要额外安全处理 |
| **chroot** | 无mount namespace | 简单兼容 | 安全性较低，可能逃逸 |

## 3. 挂载类型和处理机制

### 3.1 挂载分发器 - mountToRootfs

runc 根据不同的设备类型采用专门的处理逻辑：

```go
// libcontainer/rootfs_linux.go:566
func mountToRootfs(c *mountConfig, m mountEntry) error {
    switch m.Device {
    case "proc", "sysfs":
        // 特殊文件系统需要安全检查
        if err := checkProcMount(rootfs, dest, m); err != nil {
            return err
        }
        return mountPropagate(m, rootfs, "")
        
    case "mqueue":
        // 消息队列文件系统
        if err := mountPropagate(m, rootfs, ""); err != nil {
            return err
        }
        return label.SetFileLabel(dest, mountLabel)  // SELinux标签
        
    case "tmpfs":
        // tmpfs支持copyup扩展
        if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {
            return doTmpfsCopyUp(m, rootfs, mountLabel)
        }
        return mountPropagate(m, rootfs, mountLabel)
        
    case "bind":
        // bind挂载需要特殊的标志处理
        return handleBindMount(m, rootfs, mountLabel)
        
    case "cgroup":
        // cgroup文件系统分版本处理
        if cgroups.IsCgroup2UnifiedMode() {
            return mountCgroupV2(m.Mount, c)
        }
        return mountCgroupV1(m.Mount, c)
        
    default:
        // 其他标准文件系统
        return mountPropagate(m, rootfs, mountLabel)
    }
}
```

### 3.2 bind 挂载的复杂处理

bind 挂载是最复杂的挂载类型，因为需要处理 **locked flags** 问题：

```go
func handleBindMount(m mountEntry, rootfs, mountLabel string) error {
    // 1. 执行基础bind挂载
    flags := m.Flags | unix.MS_BIND
    if err := mountViaFds(m.Source, m.srcFile, m.Destination, dstFd, 
                         "", uintptr(flags&^unix.MS_REC), m.Data); err != nil {
        return err
    }
    
    // 2. 处理递归绑定
    if m.Flags&unix.MS_REC == unix.MS_REC {
        if err := mountViaFds(m.Source, m.srcFile, m.Destination, dstFd, 
                             "", uintptr(flags), m.Data); err != nil {
            return err
        }
    }
    
    // 3. 重新应用挂载标志 (这是关键步骤!)
    // bind挂载后需要单独的remount来应用ro/nosuid等标志
    if m.Flags&^(unix.MS_BIND|unix.MS_REC|unix.MS_REMOUNT) != 0 || m.ClearedFlags != 0 {
        flags := m.Flags | unix.MS_BIND | unix.MS_REMOUNT
        
        // 尝试直接设置标志
        if err := mountViaFds("", nil, m.Destination, dstFd, 
                             "", uintptr(flags), ""); err == nil {
            return nil
        }
        
        // 如果失败，可能存在locked flags
        // 需要获取源文件系统的当前标志
        st, err := m.srcStatfs()
        if err != nil {
            return err
        }
        
        srcFlags := statfsToMountFlags(*st)  // 从statfs转换为mount标志
        
        // 检查是否有无法清除的locked flags
        lockedFlags := srcFlags & m.ClearedFlags & mntLockFlags
        if lockedFlags != 0 {
            return fmt.Errorf("cannot clear locked mount flags: %s", 
                             stringifyMountFlags(lockedFlags))
        }
        
        // 重新应用，包含locked flags
        flags |= srcFlags & mntLockFlags
        return mountViaFds("", nil, m.Destination, dstFd, 
                          "", uintptr(flags), "")
    }
    
    return nil
}
```

**locked flags 问题解释**：

某些挂载标志在源文件系统上可能是"锁定"的，无法通过remount清除：

```bash
# 例如：源文件系统是只读的 (MS_RDONLY)
$ mount | grep /source
/dev/sda1 on /source type ext4 (ro,noatime)

# bind挂载后，无法将其改为可写
$ mount --bind /source /target
$ mount -o remount,rw /target  # 这会失败！

# runc的解决方案：检测locked flags并保持它们
```

### 3.3 新版挂载API支持

runc 支持 Linux 5.2+ 的新版挂载API，主要用于 **idmapped mounts**：

```go
// libcontainer/mount_linux.go:242
func mountFd(nsHandles *userns.Handles, m *configs.Mount) (*mountSource, error) {
    if m.IsIDMapped() {
        // 使用open_tree()创建挂载文件描述符
        flags := uint(unix.OPEN_TREE_CLONE | unix.OPEN_TREE_CLOEXEC)
        if m.Flags&unix.MS_REC == unix.MS_REC {
            flags |= unix.AT_RECURSIVE
        }
        
        fd, err := unix.OpenTree(unix.AT_FDCWD, m.Source, flags)
        if err != nil {
            return nil, fmt.Errorf("open_tree(%s): %w", m.Source, err)
        }
        
        mountFile := os.NewFile(uintptr(fd), m.Source)
        
        // 获取用户命名空间文件描述符
        usernsFile, err := nsHandles.Get(userns.Mapping{
            UIDMappings: m.IDMapping.UIDMappings,
            GIDMappings: m.IDMapping.GIDMappings,
        })
        if err != nil {
            return nil, err
        }
        
        // 应用idmap属性
        attr := &unix.MountAttr{
            Attr_set:  unix.MOUNT_ATTR_IDMAP,
            Userns_fd: uint64(usernsFile.Fd()),
        }
        
        if err := unix.MountSetattr(int(mountFile.Fd()), "", 
                                   unix.AT_EMPTY_PATH, attr); err != nil {
            return nil, fmt.Errorf("mount_setattr(idmap): %w", err)
        }
        
        return &mountSource{Type: mountSourceOpenTree, file: mountFile}, nil
    }
    
    // 普通bind挂载使用O_PATH
    mountFile, err := os.OpenFile(m.Source, unix.O_PATH|unix.O_CLOEXEC, 0)
    if err != nil {
        return nil, err
    }
    
    return &mountSource{Type: mountSourcePlain, file: mountFile}, nil
}
```

**idmapped mounts 的优势**：
- 🔐 **权限映射**: 文件系统内的 UID/GID 可以映射到不同的用户命名空间
- 🔒 **安全性**: 无需 chown 就能改变文件所有权视图
- ⚡ **性能**: 避免复制文件，直接映射权限

## 4. 特殊文件系统处理

### 4.1 /proc 文件系统安全检查

proc 文件系统包含敏感的系统信息，runc 实现了严格的安全检查：

```go
// libcontainer/rootfs_linux.go:790
func checkProcMount(rootfs, dest string, m mountEntry) error {
    // 计算相对于/proc的路径
    path, err := filepath.Rel(filepath.Join(rootfs, "/proc"), dest)
    if err != nil {
        return err
    }
    
    if path == "." {
        // 在/proc根目录上的挂载
        if m.IsBind() {
            // bind挂载必须是真正的procfs
            fsStat, err := m.srcStatfs()
            if err != nil {
                return err
            }
            
            if fsStat.Type != unix.PROC_SUPER_MAGIC {
                return fmt.Errorf("bind mount %s is not procfs", dest)
            }
            
            // 检查是否为procfs根节点 (inode == 1)
            if _, uStat, err := m.srcStat(); err == nil {
                const procRootIno = 1
                if uStat.Ino != procRootIno {
                    logrus.Warnf("bind-mount %s is not procfs root (inode %d)", 
                               dest, uStat.Ino)
                }
            }
            return nil
        } else if m.Device == "proc" {
            return nil  // 新的procfs挂载总是安全的
        }
        
        return fmt.Errorf("%s cannot be mounted: not procfs", dest)
    }
    
    // /proc子路径：只允许特定的白名单路径
    validProcMounts := []string{
        "/proc/cpuinfo", "/proc/diskstats", "/proc/meminfo",
        "/proc/stat", "/proc/swaps", "/proc/uptime", "/proc/loadavg",
        "/proc/sys/kernel/ns_last_pid",
        "/proc/sys/crypto/fips_enabled",
        // 更多安全的proc路径...
    }
    
    // 检查是否为允许的路径
    for _, validPath := range validProcMounts {
        if filepath.Clean(dest) == validPath {
            return nil
        }
    }
    
    return fmt.Errorf("%s cannot be mounted inside /proc: not in whitelist", dest)
}
```

### 4.2 cgroup 文件系统处理

#### Cgroups v1 处理

```go
func mountCgroupV1(m *configs.Mount, c *mountConfig) error {
    // 获取系统中的cgroup挂载点
    binds, err := getCgroupMounts(m)
    if err != nil {
        return err
    }
    
    // 创建tmpfs作为cgroup根挂载点
    tmpfs := &configs.Mount{
        Source:      "tmpfs",
        Device:      "tmpfs",
        Destination: m.Destination,
        Flags:       defaultMountFlags,
        Data:        "mode=755,size=65536k",
    }
    
    if err := mountToRootfs(c, mountEntry{Mount: tmpfs}); err != nil {
        return err
    }
    
    // 为每个cgroup子系统创建挂载点
    for _, b := range binds {
        if c.cgroupns {
            // cgroup命名空间模式：直接挂载cgroup文件系统
            subsystemName := strings.Join(b.Subsystems, ",")
            if err := mountViaFds("cgroup", nil, b.Destination, dstFd, 
                                 "cgroup", uintptr(b.Flags), subsystemName); err != nil {
                return fmt.Errorf("failed to mount cgroup %s: %w", 
                                 subsystemName, err)
            }
        } else {
            // 非命名空间模式：bind挂载宿主机cgroup路径
            if err := mountToRootfs(c, mountEntry{Mount: b}); err != nil {
                return err
            }
        }
    }
    
    return nil
}
```

#### Cgroups v2 处理

```go
func mountCgroupV2(m *configs.Mount, c *mountConfig) error {
    // 尝试直接挂载cgroup2文件系统
    err := mountViaFds(m.Source, nil, m.Destination, dstFd, 
                      "cgroup2", uintptr(m.Flags), m.Data)
    
    if err == nil || (!errors.Is(err, unix.EPERM) && !errors.Is(err, unix.EBUSY)) {
        return err
    }
    
    // 权限不足时降级为bind挂载
    bindMount := &configs.Mount{
        Device:      "bind",
        Source:      fs2.UnifiedMountpoint,  // /sys/fs/cgroup
        Destination: m.Destination,
        Flags:       unix.MS_BIND | m.Flags,
    }
    
    if c.cgroupns && c.cgroup2Path != "" {
        // cgroup命名空间模式：挂载容器特定路径
        bindMount.Source = c.cgroup2Path
    }
    
    return mountToRootfs(c, mountEntry{Mount: bindMount})
}
```

### 4.3 /dev 文件系统和设备节点

```go
// libcontainer/rootfs_linux.go:473
func createDevices(config *configs.Config) error {
    useBindMount := userns.RunningInUserNS() || 
                   config.Namespaces.Contains(configs.NEWUSER)
    
    // 创建配置中指定的设备节点
    for _, node := range config.Devices {
        // ptmx由setupPtmx()单独处理
        if utils.CleanPath(node.Path) == "/dev/ptmx" {
            continue
        }
        
        if err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {
            return fmt.Errorf("failed to create device %s: %w", node.Path, err)
        }
    }
    return nil
}

func createDeviceNode(rootfs string, node *devices.Device, bind bool) error {
    dest, err := securejoin.SecureJoin(rootfs, node.Path)
    if err != nil {
        return err
    }
    
    if bind {
        // 用户命名空间中使用bind挂载
        return bindMountDeviceNode(rootfs, dest, node)
    } else {
        // 直接使用mknod创建设备节点
        return mknodDevice(dest, node)
    }
}

// 设备节点bind挂载
func bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {
    // 创建目标文件
    if err := createBlankFile(dest, node); err != nil {
        return err
    }
    
    // bind挂载设备节点
    return mount(node.Path, dest, "bind", unix.MS_BIND, "")
}

// 创建标准设备符号链接
func setupDevSymlinks(rootfs string) error {
    links := [][2]string{
        {"/proc/self/fd", "/dev/fd"},
        {"/proc/self/fd/0", "/dev/stdin"},
        {"/proc/self/fd/1", "/dev/stdout"},
        {"/proc/self/fd/2", "/dev/stderr"},
    }
    
    // 条件性符号链接
    if _, err := os.Stat("/proc/kcore"); err == nil {
        links = append(links, [2]string{"/proc/kcore", "/dev/core"})
    }
    
    for _, link := range links {
        newPath := filepath.Join(rootfs, link[1])
        if err := os.Symlink(link[0], newPath); err != nil && !os.IsExist(err) {
            return err
        }
    }
    
    return nil
}
```

## 5. 挂载配置和选项解析

### 5.1 Mount 结构定义

```go
// libcontainer/configs/mount_linux.go:23
type Mount struct {
    Source           string              // 源路径或设备
    Destination      string              // 容器内目标路径
    Device           string              // 文件系统类型或设备类型
    Flags            int                 // 挂载标志位
    ClearedFlags     int                 // 明确清除的标志
    PropagationFlags []int               // 挂载传播标志数组
    Data             string              // 文件系统特定选项
    Relabel          string              // SELinux重标记选项
    RecAttr          *unix.MountAttr     // mount_setattr递归属性
    Extensions       int                 // runc扩展标志
    IDMapping        *MountIDMapping     // idmapped挂载配置
}

// 常用方法
func (m *Mount) IsBind() bool {
    return m.Flags&unix.MS_BIND != 0
}

func (m *Mount) IsIDMapped() bool {
    return m.IDMapping != nil
}
```

### 5.2 挂载选项解析机制

runc 使用多层映射表解析 OCI 规范中的挂载选项：

```go
// libcontainer/specconv/spec_linux.go:1079
var (
    // 基础挂载标志映射  
    mountFlags = map[string]struct{clear bool; flag int}{
        "defaults":   {false, 0},                    // 默认选项
        "ro":         {false, unix.MS_RDONLY},       // 只读
        "rw":         {true, unix.MS_RDONLY},        // 可写(清除只读)
        "nosuid":     {false, unix.MS_NOSUID},       // 禁用suid
        "suid":       {true, unix.MS_NOSUID},        // 允许suid(清除nosuid)
        "nodev":      {false, unix.MS_NODEV},        // 禁用设备节点
        "dev":        {true, unix.MS_NODEV},         // 允许设备节点
        "noexec":     {false, unix.MS_NOEXEC},       // 禁用可执行文件
        "exec":       {true, unix.MS_NOEXEC},        // 允许可执行文件
        "sync":       {false, unix.MS_SYNCHRONOUS},   // 同步IO
        "async":      {true, unix.MS_SYNCHRONOUS},    // 异步IO
        "dirsync":    {false, unix.MS_DIRSYNC},      // 目录同步
        "remount":    {false, unix.MS_REMOUNT},      // 重新挂载
        "mand":       {false, unix.MS_MANDLOCK},     // 强制锁
        "nomand":     {true, unix.MS_MANDLOCK},      // 禁用强制锁
        "atime":      {true, unix.MS_NOATIME},       // 更新访问时间
        "noatime":    {false, unix.MS_NOATIME},      // 不更新访问时间
        "diratime":   {true, unix.MS_NODIRATIME},    // 目录访问时间
        "nodiratime": {false, unix.MS_NODIRATIME},   // 禁用目录访问时间
        "bind":       {false, unix.MS_BIND},         // bind挂载
        "rbind":      {false, unix.MS_BIND | unix.MS_REC}, // 递归bind挂载
        "relatime":   {false, unix.MS_RELATIME},     // 相对访问时间
        "norelatime": {true, unix.MS_RELATIME},      // 禁用相对访问时间
        "strictatime": {false, unix.MS_STRICTATIME}, // 严格访问时间
        "nostrictatime": {true, unix.MS_STRICTATIME}, // 非严格访问时间
    }
    
    // 挂载传播属性映射
    mountPropagationMapping = map[string]int{
        "private":     unix.MS_PRIVATE,
        "rprivate":    unix.MS_PRIVATE | unix.MS_REC,
        "shared":      unix.MS_SHARED,
        "rshared":     unix.MS_SHARED | unix.MS_REC,
        "slave":       unix.MS_SLAVE,
        "rslave":      unix.MS_SLAVE | unix.MS_REC,
        "unbindable":  unix.MS_UNBINDABLE,
        "runbindable": unix.MS_UNBINDABLE | unix.MS_REC,
    }
    
    // mount_setattr递归属性映射 (Linux 5.12+)
    recAttrFlags = map[string]struct{clear bool; flag uint64}{
        "rro":        {false, unix.MOUNT_ATTR_RDONLY},
        "rrw":        {true, unix.MOUNT_ATTR_RDONLY},
        "rnosuid":    {false, unix.MOUNT_ATTR_NOSUID},
        "rsuid":      {true, unix.MOUNT_ATTR_NOSUID},
        "rnodev":     {false, unix.MOUNT_ATTR_NODEV},
        "rdev":       {true, unix.MOUNT_ATTR_NODEV},
        "rnoexec":    {false, unix.MOUNT_ATTR_NOEXEC},
        "rexec":      {true, unix.MOUNT_ATTR_NOEXEC},
        "rnodiratime": {false, unix.MOUNT_ATTR_NODIRATIME},
        "rdiratime":   {true, unix.MOUNT_ATTR_NODIRATIME},
        "rnoatime":    {false, unix.MOUNT_ATTR_NOATIME},
        "ratime":      {true, unix.MOUNT_ATTR_NOATIME},
        "rrelatime":   {false, unix.MOUNT_ATTR_RELATIME},
        "rnorelatime": {true, unix.MOUNT_ATTR_RELATIME},
        "rstrictatime": {false, unix.MOUNT_ATTR_STRICTATIME},
        "rnostrictatime": {true, unix.MOUNT_ATTR_STRICTATIME},
    }
)
```

### 5.3 选项解析算法

```go
func parseMountOptions(options []string) (*configs.Mount, error) {
    var (
        data     []string
        mount    configs.Mount
        recAttrSet, recAttrClr uint64
    )
    
    for _, option := range options {
        if f, exists := mountFlags[option]; exists && f.flag != 0 {
            if f.clear {
                // 清除标志
                mount.Flags &= ^f.flag
                mount.ClearedFlags |= f.flag
            } else {
                // 设置标志
                mount.Flags |= f.flag
                mount.ClearedFlags &= ^f.flag
            }
        } else if f, exists := mountPropagationMapping[option]; exists {
            // 传播属性
            mount.PropagationFlags = append(mount.PropagationFlags, f)
        } else if f, exists := recAttrFlags[option]; exists {
            // 递归属性 (mount_setattr)
            if f.clear {
                recAttrClr |= f.flag
            } else {
                recAttrSet |= f.flag
                // atime标志需要特殊处理
                if f.flag&unix.MOUNT_ATTR__ATIME == f.flag {
                    recAttrClr |= unix.MOUNT_ATTR__ATIME
                }
            }
        } else {
            // 文件系统特定选项
            data = append(data, option)
        }
    }
    
    mount.Data = strings.Join(data, ",")
    
    // 设置mount_setattr属性
    if recAttrSet != 0 || recAttrClr != 0 {
        mount.RecAttr = &unix.MountAttr{
            Attr_set: recAttrSet,
            Attr_clr: recAttrClr,
        }
    }
    
    return &mount, nil
}
```

## 6. 安全机制和错误处理

### 6.1 路径安全处理

runc 使用多种机制防止路径遍历攻击：

```go
// 使用procfd确保路径安全
func WithProcfd(root, path string, fn func(procfd string) error) error {
    // 使用 /proc/self/fd/<fd> 确保操作在正确的路径上
    file, err := securejoin.OpenInRoot(root, path, unix.O_PATH|unix.O_CLOEXEC)
    if err != nil {
        return err
    }
    defer file.Close()
    
    procfd := "/proc/self/fd/" + strconv.Itoa(int(file.Fd()))
    return fn(procfd)
}

// securejoin 确保安全路径连接
func secureJoin(root, path string) (string, error) {
    // 防止 ../ 路径遍历
    // 防止符号链接逃逸  
    // 确保结果路径在root内部
    return securejoin.SecureJoin(root, path)
}
```

### 6.2 错误处理和诊断

```go
// 结构化的挂载错误信息
type mountError struct {
    op      string        // 操作类型 (mount/unmount)
    source  string        // 源路径
    srcFile *mountSource  // 源文件描述符信息
    target  string        // 目标路径
    dstFd   string        // 目标procfd路径
    flags   uintptr       // 挂载标志
    data    string        // 挂载选项
    err     error         // 底层错误
}

func (e *mountError) Error() string {
    var srcType string
    if e.srcFile != nil {
        srcType = string(e.srcFile.Type)
    }
    return fmt.Sprintf("%s failed: src=%s, srcType=%s, dst=%s, flags=%s, data=%s: %v",
                       e.op, e.source, srcType, e.target,
                       stringifyMountFlags(e.flags), e.data, e.err)
}

// 挂载标志的可读化
func stringifyMountFlags(flags uintptr) string {
    var opts []string
    if flags&unix.MS_RDONLY != 0 {
        opts = append(opts, "ro")
    }
    if flags&unix.MS_NOSUID != 0 {
        opts = append(opts, "nosuid")
    }
    if flags&unix.MS_NODEV != 0 {
        opts = append(opts, "nodev")
    }
    if flags&unix.MS_NOEXEC != 0 {
        opts = append(opts, "noexec")
    }
    if flags&unix.MS_BIND != 0 {
        opts = append(opts, "bind")
    }
    // ... 更多标志
    
    if len(opts) == 0 {
        return "0"
    }
    return strings.Join(opts, ",")
}
```

### 6.3 只读文件系统加固

```go
// libcontainer/rootfs_linux.go:388
func finalizeRootfs(config *configs.Config) error {
    // 1. 重新挂载延迟只读的文件系统
    for _, mount := range config.Mounts {
        if mount.Flags&unix.MS_RDONLY != unix.MS_RDONLY {
            continue
        }
        
        // tmpfs 和 /dev 延迟只读处理
        if mount.Device == "tmpfs" || utils.CleanPath(mount.Destination) == "/dev" {
            if err := remountReadonly(mount); err != nil {
                return fmt.Errorf("failed to remount %s as readonly: %w", 
                                 mount.Destination, err)
            }
        }
    }
    
    // 2. 设置根文件系统只读
    if config.Readonlyfs {
        if err := setReadonly(); err != nil {
            return fmt.Errorf("failed to set rootfs readonly: %w", err)
        }
    }
    
    // 3. 应用 umask
    if config.Umask != nil {
        unix.Umask(int(*config.Umask))
    } else {
        unix.Umask(0o022)  // 默认 umask
    }
    
    return nil
}

func setReadonly() error {
    // 重新挂载根文件系统为只读
    return mount("/", "/", "", unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, "")
}
```

## 7. 实践练习

### 7.1 基础挂载实验

```bash
#!/bin/bash
# 实验 1: 理解不同挂载类型

# 创建实验环境
mkdir -p /tmp/rootfs/{bin,etc,proc,sys,dev,tmp}
mkdir -p /tmp/host-data

# 1. bind 挂载实验
echo "host content" > /tmp/host-data/file.txt
mount --bind /tmp/host-data /tmp/rootfs/tmp
ls /tmp/rootfs/tmp/  # 应该看到 file.txt

# 2. tmpfs 挂载实验
mount -t tmpfs tmpfs /tmp/rootfs/dev -o size=10M,mode=755
echo "tmpfs content" > /tmp/rootfs/dev/tmpfile
ls /tmp/rootfs/dev/

# 3. proc 挂载实验
mount -t proc proc /tmp/rootfs/proc
ls /tmp/rootfs/proc/  # 看到proc内容

# 4. 测试挂载传播
mkdir -p /tmp/test-propagation/{source,target}
mount --bind /tmp/test-propagation/source /tmp/test-propagation/target

# 共享传播
mount --make-shared /tmp/test-propagation/target
mount --bind /tmp/host-data /tmp/test-propagation/target/shared

# 检查传播效果
ls /tmp/test-propagation/source/  # 应该看到shared目录

# 清理
umount -R /tmp/rootfs
umount -R /tmp/test-propagation
```

### 7.2 容器文件系统构建

```bash
#!/bin/bash
# 实验 2: 手动构建容器文件系统

create_container_rootfs() {
    local rootfs="/tmp/container-rootfs"
    local old_root="/tmp/old-root"
    
    # 1. 准备基础rootfs
    mkdir -p "$rootfs"/{bin,etc,lib,proc,sys,dev,tmp}
    
    # 复制必要的可执行文件
    cp /bin/sh "$rootfs/bin/"
    cp /bin/ls "$rootfs/bin/"
    cp /bin/cat "$rootfs/bin/"
    
    # 复制库文件
    ldd /bin/sh | grep -o '/lib[^ ]*' | while read lib; do
        mkdir -p "$rootfs$(dirname "$lib")"
        cp "$lib" "$rootfs$lib"
    done
    
    # 2. 设置挂载传播
    mount --make-private /
    
    # 3. bind挂载rootfs到自身
    mount --bind "$rootfs" "$rootfs"
    
    # 4. 切换到新namespace中执行
    unshare --mount --pid --fork /bin/bash -c "
        # 在新的mount namespace中
        cd '$rootfs'
        
        # 挂载特殊文件系统
        mount -t proc proc proc/
        mount -t sysfs sysfs sys/
        mount -t tmpfs tmpfs tmp/ -o size=100M
        
        # 创建设备节点
        mkdir -p dev
        mknod dev/null c 1 3
        mknod dev/zero c 1 5
        mknod dev/random c 1 8
        
        # 创建符号链接
        ln -sf /proc/self/fd dev/fd
        ln -sf /proc/self/fd/0 dev/stdin
        ln -sf /proc/self/fd/1 dev/stdout
        ln -sf /proc/self/fd/2 dev/stderr
        
        # 执行pivot_root
        mkdir -p '$old_root'
        pivot_root . '$old_root'
        
        # 卸载旧根
        umount /$old_root 2>/dev/null || true
        rmdir /$old_root 2>/dev/null || true
        
        # 进入容器环境
        cd /
        exec /bin/sh
    "
}

# 执行实验
create_container_rootfs
```

### 7.3 挂载选项解析测试

```go
// 实验 3: 理解挂载选项解析
package main

import (
    "fmt"
    "strings"
    "golang.org/x/sys/unix"
)

func parseMountOptions(options []string) {
    var flags int
    var data []string
    
    mountFlags := map[string]struct{clear bool; flag int}{
        "ro":     {false, unix.MS_RDONLY},
        "rw":     {true, unix.MS_RDONLY},
        "nosuid": {false, unix.MS_NOSUID},
        "suid":   {true, unix.MS_NOSUID},
        "bind":   {false, unix.MS_BIND},
        "rbind":  {false, unix.MS_BIND | unix.MS_REC},
    }
    
    for _, opt := range options {
        if f, exists := mountFlags[opt]; exists {
            if f.clear {
                flags &= ^f.flag
                fmt.Printf("Cleared flag: %s\n", opt)
            } else {
                flags |= f.flag
                fmt.Printf("Set flag: %s\n", opt)
            }
        } else {
            data = append(data, opt)
        }
    }
    
    fmt.Printf("Final flags: %d\n", flags)
    fmt.Printf("Data: %s\n", strings.Join(data, ","))
}

func main() {
    // 测试不同选项组合
    fmt.Println("=== Test 1: ro,nosuid,bind ===")
    parseMountOptions([]string{"ro", "nosuid", "bind"})
    
    fmt.Println("\n=== Test 2: rw,suid,rbind,size=100M ===")
    parseMountOptions([]string{"rw", "suid", "rbind", "size=100M"})
    
    fmt.Println("\n=== Test 3: ro then rw ===")
    parseMountOptions([]string{"ro", "rw"})
}
```

### 7.4 文件系统安全测试

```bash
#!/bin/bash
# 实验 4: 测试文件系统安全机制

test_path_traversal() {
    echo "=== Path Traversal Test ==="
    
    # 创建容器rootfs
    mkdir -p /tmp/container/{rootfs,host-secret}
    echo "secret content" > /tmp/container/host-secret/secret.txt
    
    # 测试路径遍历防护
    ln -sf ../host-secret /tmp/container/rootfs/escape
    
    # runc会防止这种符号链接逃逸
    echo "Attempting to access: /tmp/container/rootfs/escape/secret.txt"
    
    # 模拟securejoin检查
    if readlink /tmp/container/rootfs/escape | grep -q "\.\."; then
        echo "Path traversal detected and blocked!"
    fi
}

test_proc_mount_security() {
    echo "=== /proc Mount Security Test ==="
    
    mkdir -p /tmp/test-proc/rootfs/proc
    
    # 允许的/proc挂载
    echo "Testing allowed /proc paths:"
    for path in "/proc/cpuinfo" "/proc/meminfo" "/proc/uptime"; do
        echo "  $path - ALLOWED"
    done
    
    # 禁止的/proc挂载
    echo "Testing forbidden /proc paths:"
    for path in "/proc/1/maps" "/proc/sys/kernel/core_pattern" "/proc/kcore"; do
        echo "  $path - BLOCKED"
    done
}

test_bind_mount_flags() {
    echo "=== Bind Mount Flags Test ==="
    
    # 创建源目录和文件
    mkdir -p /tmp/bind-test/source
    echo "test" > /tmp/bind-test/source/file.txt
    chmod 777 /tmp/bind-test/source/file.txt
    
    # 测试只读bind挂载
    mkdir -p /tmp/bind-test/target
    mount --bind /tmp/bind-test/source /tmp/bind-test/target
    
    # 尝试重新挂载为只读
    mount -o remount,ro /tmp/bind-test/target
    
    # 测试写入（应该失败）
    if echo "write test" > /tmp/bind-test/target/file.txt 2>/dev/null; then
        echo "ERROR: Read-only bind mount failed!"
    else
        echo "SUCCESS: Read-only bind mount working"
    fi
    
    umount /tmp/bind-test/target
}

# 运行测试
test_path_traversal
test_proc_mount_security  
test_bind_mount_flags

# 清理
rm -rf /tmp/container /tmp/test-proc /tmp/bind-test
```

## 8. 故障排除和调试

### 8.1 常见挂载问题诊断

#### 权限问题

```bash
# 检查当前挂载情况
mount | grep "container\|runc"

# 检查文件系统权限
ls -la /proc/self/ns/mnt  # mount namespace
ls -la /sys/fs/cgroup     # cgroup文件系统

# 检查用户权限
id
groups
cat /proc/self/uid_map
cat /proc/self/gid_map
```

#### 挂载传播问题

```bash
# 检查挂载传播属性
grep -E "shared|slave|private" /proc/self/mountinfo

# 查看特定挂载点的传播属性
findmnt -o TARGET,PROPAGATION /

# 修复传播属性
mount --make-private /
mount --make-slave /
```

### 8.2 调试工具和方法

```bash
# strace 跟踪挂载系统调用
strace -f -e trace=mount,umount,pivot_root runc create container

# 使用 nsenter 进入容器的 mount namespace
nsenter -m -p -t $(docker inspect -f '{{.State.Pid}}' container) /bin/sh

# 检查容器内的挂载情况
nsenter -m -t PID cat /proc/mounts
nsenter -m -t PID findmnt

# 调试 runc 挂载过程
RUNC_DEBUG=1 runc create container 2>&1 | grep -i mount
```

### 8.3 性能分析

```bash
# 测量挂载操作时间
time runc create container

# 分析I/O性能
iostat -x 1 10 &
runc run container
kill %1

# 内存使用分析
/usr/bin/time -v runc run container
```

## 9. 思考题

### 9.1 架构设计思考

1. **rootfs切换方式**: pivot_root vs MS_MOVE vs chroot 的优缺点对比，什么场景下选择哪种方式？

2. **挂载传播**: 为什么容器需要 MS_SLAVE 传播属性？如果使用 MS_SHARED 会有什么风险？

3. **bind挂载复杂性**: 为什么 bind 挂载需要 remount 来应用标志？locked flags 问题如何更优雅地解决？

### 9.2 安全性思考

4. **/proc安全**: 除了白名单机制，还有什么方法可以增强 /proc 挂载的安全性？

5. **路径遍历**: securejoin 机制能否防御所有的路径遍历攻击？还有什么潜在漏洞？

6. **idmapped mounts**: idmapped mounts 在什么场景下最有价值？有什么安全风险？

### 9.3 性能优化思考

7. **挂载开销**: 大量挂载点对容器启动性能的影响？如何优化？

8. **文件系统选择**: 不同 rootfs 文件系统 (ext4/xfs/overlay) 对性能的影响？

9. **内存使用**: tmpfs 的内存使用如何控制？何时选择 tmpfs vs bind mount？

## 10. 扩展阅读

### 10.1 Linux 内核文档

- [Mount namespaces](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)
- [pivot_root(2)](https://man7.org/linux/man-pages/man2/pivot_root.2.html)
- [mount(2)](https://man7.org/linux/man-pages/man2/mount.2.html)
- [mount_setattr(2)](https://man7.org/linux/man-pages/man2/mount_setattr.2.html)

### 10.2 文件系统技术

- [VFS (Virtual File System)](https://www.kernel.org/doc/Documentation/filesystems/vfs.txt)
- [Bind Mounts](https://lwn.net/Articles/281157/)
- [Mount propagation](https://lwn.net/Articles/159077/)
- [Idmapped mounts](https://lwn.net/Articles/837566/)

### 10.3 容器技术深入

- [Container filesystems](https://medium.com/containers-world/filesystem-technology-container-6cfbeac6c0dc)
- [OverlayFS and containers](https://arkfox.com/archive/overlayfs/)
- [Container security with mount namespaces](https://blog.quarkslab.com/mount-namespace-linux-kernel.html)

## 🎯 模块总结

通过本模块的学习，你应该已经掌握了：

✅ **Rootfs 切换机制**：理解三种切换方式和适用场景  
✅ **挂载类型处理**：掌握各种文件系统的专门处理逻辑  
✅ **安全防护机制**：理解路径安全、proc检查等防护措施  
✅ **配置解析系统**：熟悉挂载选项的多层映射和解析流程  
✅ **故障排除能力**：具备挂载问题诊断和性能优化技能  

**下一步**: 进入 [模块 6: 安全特性实现](./06-安全特性实现.md)，学习容器安全机制的具体实现。